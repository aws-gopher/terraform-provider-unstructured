// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package resource_source

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
)

func SourceResourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"azure": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"account_key": schema.StringAttribute{
						Optional: true,
					},
					"account_name": schema.StringAttribute{
						Optional: true,
					},
					"connection_string": schema.StringAttribute{
						Optional: true,
					},
					"recursive": schema.BoolAttribute{
						Optional: true,
						Computed: true,
					},
					"remote_url": schema.StringAttribute{
						Required: true,
					},
					"sas_token": schema.StringAttribute{
						Optional: true,
					},
				},
				CustomType: AzureType{
					ObjectType: types.ObjectType{
						AttrTypes: AzureValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
			},
			"box": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"box_app_config": schema.StringAttribute{
						Required: true,
					},
					"recursive": schema.BoolAttribute{
						Optional: true,
						Computed: true,
					},
					"remote_url": schema.StringAttribute{
						Required: true,
					},
				},
				CustomType: BoxType{
					ObjectType: types.ObjectType{
						AttrTypes: BoxValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
			},
			"confluence": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"api_token": schema.StringAttribute{
						Optional: true,
					},
					"cloud": schema.BoolAttribute{
						Optional: true,
					},
					"extract_files": schema.BoolAttribute{
						Optional: true,
					},
					"extract_images": schema.BoolAttribute{
						Optional: true,
					},
					"max_num_of_docs_from_each_space": schema.Int64Attribute{
						Optional: true,
					},
					"max_num_of_spaces": schema.Int64Attribute{
						Optional: true,
					},
					"password": schema.StringAttribute{
						Optional: true,
					},
					"spaces": schema.ListAttribute{
						ElementType: types.StringType,
						Optional:    true,
					},
					"token": schema.StringAttribute{
						Optional: true,
					},
					"url": schema.StringAttribute{
						Required: true,
					},
					"username": schema.StringAttribute{
						Required: true,
					},
				},
				CustomType: ConfluenceType{
					ObjectType: types.ObjectType{
						AttrTypes: ConfluenceValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
			},
			"couchbase": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"batch_size": schema.Int64Attribute{
						Required: true,
					},
					"bucket": schema.StringAttribute{
						Required: true,
					},
					"collection": schema.StringAttribute{
						Optional: true,
					},
					"collection_id": schema.StringAttribute{
						Required: true,
					},
					"connection_string": schema.StringAttribute{
						Required: true,
					},
					"password": schema.StringAttribute{
						Required: true,
					},
					"scope": schema.StringAttribute{
						Optional: true,
					},
					"username": schema.StringAttribute{
						Required: true,
					},
				},
				CustomType: CouchbaseType{
					ObjectType: types.ObjectType{
						AttrTypes: CouchbaseValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
			},
			"created_at": schema.StringAttribute{
				Computed: true,
			},
			"databricks_volumes": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"catalog": schema.StringAttribute{
						Required: true,
					},
					"client_id": schema.StringAttribute{
						Required: true,
					},
					"client_secret": schema.StringAttribute{
						Required: true,
					},
					"host": schema.StringAttribute{
						Required: true,
					},
					"schema": schema.StringAttribute{
						Optional: true,
					},
					"volume": schema.StringAttribute{
						Required: true,
					},
					"volume_path": schema.StringAttribute{
						Required: true,
					},
				},
				CustomType: DatabricksVolumesType{
					ObjectType: types.ObjectType{
						AttrTypes: DatabricksVolumesValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
			},
			"dropbox": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"recursive": schema.BoolAttribute{
						Optional: true,
						Computed: true,
					},
					"remote_url": schema.StringAttribute{
						Required: true,
					},
					"token": schema.StringAttribute{
						Required: true,
					},
				},
				CustomType: DropboxType{
					ObjectType: types.ObjectType{
						AttrTypes: DropboxValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
			},
			"elasticsearch": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"es_api_key": schema.StringAttribute{
						Required: true,
					},
					"hosts": schema.ListAttribute{
						ElementType: types.StringType,
						Required:    true,
					},
					"index_name": schema.StringAttribute{
						Required: true,
					},
				},
				CustomType: ElasticsearchType{
					ObjectType: types.ObjectType{
						AttrTypes: ElasticsearchValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
			},
			"gcs": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"recursive": schema.BoolAttribute{
						Optional: true,
						Computed: true,
					},
					"remote_url": schema.StringAttribute{
						Required: true,
					},
					"service_account_key": schema.StringAttribute{
						Required: true,
					},
				},
				CustomType: GcsType{
					ObjectType: types.ObjectType{
						AttrTypes: GcsValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
			},
			"google_drive": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"drive_id": schema.StringAttribute{
						Required: true,
					},
					"extensions": schema.ListAttribute{
						ElementType: types.StringType,
						Optional:    true,
					},
					"recursive": schema.BoolAttribute{
						Optional: true,
						Computed: true,
					},
					"service_account_key": schema.StringAttribute{
						Required: true,
					},
				},
				CustomType: GoogleDriveType{
					ObjectType: types.ObjectType{
						AttrTypes: GoogleDriveValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
			},
			"id": schema.StringAttribute{
				Computed: true,
			},
			"jira": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"boards": schema.ListAttribute{
						ElementType: types.StringType,
						Optional:    true,
					},
					"cloud": schema.BoolAttribute{
						Optional: true,
					},
					"download_attachments": schema.BoolAttribute{
						Optional: true,
					},
					"issues": schema.ListAttribute{
						ElementType: types.StringType,
						Optional:    true,
					},
					"password": schema.StringAttribute{
						Optional: true,
					},
					"projects": schema.ListAttribute{
						ElementType: types.StringType,
						Optional:    true,
					},
					"status_filters": schema.ListAttribute{
						ElementType: types.StringType,
						Optional:    true,
					},
					"token": schema.StringAttribute{
						Optional: true,
					},
					"url": schema.StringAttribute{
						Required: true,
					},
					"username": schema.StringAttribute{
						Required: true,
					},
				},
				CustomType: JiraType{
					ObjectType: types.ObjectType{
						AttrTypes: JiraValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
			},
			"kafka_cloud": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"bootstrap_servers": schema.StringAttribute{
						Required: true,
					},
					"group_id": schema.StringAttribute{
						Optional: true,
					},
					"kafka_api_key": schema.StringAttribute{
						Required: true,
					},
					"num_messages_to_consume": schema.Int64Attribute{
						Optional: true,
					},
					"port": schema.Int64Attribute{
						Optional: true,
					},
					"secret": schema.StringAttribute{
						Required: true,
					},
					"topic": schema.StringAttribute{
						Required: true,
					},
				},
				CustomType: KafkaCloudType{
					ObjectType: types.ObjectType{
						AttrTypes: KafkaCloudValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
			},
			"mongodb": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"collection": schema.StringAttribute{
						Required: true,
					},
					"database": schema.StringAttribute{
						Required: true,
					},
					"uri": schema.StringAttribute{
						Required: true,
					},
				},
				CustomType: MongodbType{
					ObjectType: types.ObjectType{
						AttrTypes: MongodbValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
			},
			"name": schema.StringAttribute{
				Required: true,
			},
			"onedrive": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"authority_url": schema.StringAttribute{
						Required: true,
					},
					"client_cred": schema.StringAttribute{
						Required: true,
					},
					"client_id": schema.StringAttribute{
						Required: true,
					},
					"path": schema.StringAttribute{
						Required: true,
					},
					"recursive": schema.BoolAttribute{
						Optional: true,
						Computed: true,
					},
					"tenant": schema.StringAttribute{
						Required: true,
					},
					"user_pname": schema.StringAttribute{
						Required: true,
					},
				},
				CustomType: OnedriveType{
					ObjectType: types.ObjectType{
						AttrTypes: OnedriveValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
			},
			"outlook": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"authority_url": schema.StringAttribute{
						Optional: true,
					},
					"client_cred": schema.StringAttribute{
						Required: true,
					},
					"client_id": schema.StringAttribute{
						Required: true,
					},
					"outlook_folders": schema.ListAttribute{
						ElementType: types.StringType,
						Optional:    true,
					},
					"recursive": schema.BoolAttribute{
						Optional: true,
						Computed: true,
					},
					"tenant": schema.StringAttribute{
						Optional: true,
					},
					"user_email": schema.StringAttribute{
						Required: true,
					},
				},
				CustomType: OutlookType{
					ObjectType: types.ObjectType{
						AttrTypes: OutlookValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
			},
			"postgres": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"batch_size": schema.Int64Attribute{
						Required: true,
					},
					"database": schema.StringAttribute{
						Required: true,
					},
					"fields": schema.ListAttribute{
						ElementType: types.StringType,
						Optional:    true,
					},
					"host": schema.StringAttribute{
						Required: true,
					},
					"id_column": schema.StringAttribute{
						Optional: true,
						Computed: true,
					},
					"password": schema.StringAttribute{
						Required: true,
					},
					"port": schema.Int64Attribute{
						Required: true,
					},
					"table_name": schema.StringAttribute{
						Required: true,
					},
					"username": schema.StringAttribute{
						Required: true,
					},
				},
				CustomType: PostgresType{
					ObjectType: types.ObjectType{
						AttrTypes: PostgresValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
			},
			"s3": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"anonymous": schema.BoolAttribute{
						Optional: true,
						Computed: true,
					},
					"endpoint_url": schema.StringAttribute{
						Optional: true,
					},
					"key": schema.StringAttribute{
						Optional: true,
					},
					"recursive": schema.BoolAttribute{
						Optional: true,
						Computed: true,
					},
					"remote_url": schema.StringAttribute{
						Required: true,
					},
					"secret": schema.StringAttribute{
						Optional: true,
					},
					"token": schema.StringAttribute{
						Optional: true,
					},
				},
				CustomType: S3Type{
					ObjectType: types.ObjectType{
						AttrTypes: S3Value{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
			},
			"salesforce": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"categories": schema.ListAttribute{
						ElementType: types.StringType,
						Required:    true,
					},
					"consumer_key": schema.StringAttribute{
						Required: true,
					},
					"private_key": schema.StringAttribute{
						Required: true,
					},
					"username": schema.StringAttribute{
						Required: true,
					},
				},
				CustomType: SalesforceType{
					ObjectType: types.ObjectType{
						AttrTypes: SalesforceValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
			},
			"sharepoint": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"authority_url": schema.StringAttribute{
						Optional: true,
					},
					"client_cred": schema.StringAttribute{
						Required: true,
					},
					"client_id": schema.StringAttribute{
						Required: true,
					},
					"path": schema.StringAttribute{
						Optional: true,
					},
					"recursive": schema.BoolAttribute{
						Optional: true,
						Computed: true,
					},
					"site": schema.StringAttribute{
						Required: true,
					},
					"tenant": schema.StringAttribute{
						Required: true,
					},
					"user_pname": schema.StringAttribute{
						Required: true,
					},
				},
				CustomType: SharepointType{
					ObjectType: types.ObjectType{
						AttrTypes: SharepointValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
			},
			"snowflake": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"account": schema.StringAttribute{
						Required: true,
					},
					"batch_size": schema.Int64Attribute{
						Optional: true,
					},
					"database": schema.StringAttribute{
						Required: true,
					},
					"fields": schema.ListAttribute{
						ElementType: types.StringType,
						Optional:    true,
					},
					"host": schema.StringAttribute{
						Required: true,
					},
					"id_column": schema.StringAttribute{
						Required: true,
					},
					"password": schema.StringAttribute{
						Required: true,
					},
					"port": schema.Int64Attribute{
						Optional: true,
					},
					"role": schema.StringAttribute{
						Required: true,
					},
					"schema": schema.StringAttribute{
						Optional: true,
					},
					"table_name": schema.StringAttribute{
						Required: true,
					},
					"user": schema.StringAttribute{
						Required: true,
					},
				},
				CustomType: SnowflakeType{
					ObjectType: types.ObjectType{
						AttrTypes: SnowflakeValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
			},
			"updated_at": schema.StringAttribute{
				Computed: true,
			},
			"zendesk": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"api_token": schema.StringAttribute{
						Required: true,
					},
					"batch_size": schema.Int64Attribute{
						Optional: true,
					},
					"email": schema.StringAttribute{
						Required: true,
					},
					"item_type": schema.StringAttribute{
						Optional: true,
					},
					"subdomain": schema.StringAttribute{
						Required: true,
					},
				},
				CustomType: ZendeskType{
					ObjectType: types.ObjectType{
						AttrTypes: ZendeskValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
			},
		},
	}
}

type SourceModel struct {
	Azure             AzureValue             `tfsdk:"azure"`
	Box               BoxValue               `tfsdk:"box"`
	Confluence        ConfluenceValue        `tfsdk:"confluence"`
	Couchbase         CouchbaseValue         `tfsdk:"couchbase"`
	CreatedAt         types.String           `tfsdk:"created_at"`
	DatabricksVolumes DatabricksVolumesValue `tfsdk:"databricks_volumes"`
	Dropbox           DropboxValue           `tfsdk:"dropbox"`
	Elasticsearch     ElasticsearchValue     `tfsdk:"elasticsearch"`
	Gcs               GcsValue               `tfsdk:"gcs"`
	GoogleDrive       GoogleDriveValue       `tfsdk:"google_drive"`
	Id                types.String           `tfsdk:"id"`
	Jira              JiraValue              `tfsdk:"jira"`
	KafkaCloud        KafkaCloudValue        `tfsdk:"kafka_cloud"`
	Mongodb           MongodbValue           `tfsdk:"mongodb"`
	Name              types.String           `tfsdk:"name"`
	Onedrive          OnedriveValue          `tfsdk:"onedrive"`
	Outlook           OutlookValue           `tfsdk:"outlook"`
	Postgres          PostgresValue          `tfsdk:"postgres"`
	S3                S3Value                `tfsdk:"s3"`
	Salesforce        SalesforceValue        `tfsdk:"salesforce"`
	Sharepoint        SharepointValue        `tfsdk:"sharepoint"`
	Snowflake         SnowflakeValue         `tfsdk:"snowflake"`
	UpdatedAt         types.String           `tfsdk:"updated_at"`
	Zendesk           ZendeskValue           `tfsdk:"zendesk"`
}

var _ basetypes.ObjectTypable = AzureType{}

type AzureType struct {
	basetypes.ObjectType
}

func (t AzureType) Equal(o attr.Type) bool {
	other, ok := o.(AzureType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AzureType) String() string {
	return "AzureType"
}

func (t AzureType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	accountKeyAttribute, ok := attributes["account_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`account_key is missing from object`)

		return nil, diags
	}

	accountKeyVal, ok := accountKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`account_key expected to be basetypes.StringValue, was: %T`, accountKeyAttribute))
	}

	accountNameAttribute, ok := attributes["account_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`account_name is missing from object`)

		return nil, diags
	}

	accountNameVal, ok := accountNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`account_name expected to be basetypes.StringValue, was: %T`, accountNameAttribute))
	}

	connectionStringAttribute, ok := attributes["connection_string"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`connection_string is missing from object`)

		return nil, diags
	}

	connectionStringVal, ok := connectionStringAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`connection_string expected to be basetypes.StringValue, was: %T`, connectionStringAttribute))
	}

	recursiveAttribute, ok := attributes["recursive"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`recursive is missing from object`)

		return nil, diags
	}

	recursiveVal, ok := recursiveAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`recursive expected to be basetypes.BoolValue, was: %T`, recursiveAttribute))
	}

	remoteUrlAttribute, ok := attributes["remote_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remote_url is missing from object`)

		return nil, diags
	}

	remoteUrlVal, ok := remoteUrlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remote_url expected to be basetypes.StringValue, was: %T`, remoteUrlAttribute))
	}

	sasTokenAttribute, ok := attributes["sas_token"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sas_token is missing from object`)

		return nil, diags
	}

	sasTokenVal, ok := sasTokenAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sas_token expected to be basetypes.StringValue, was: %T`, sasTokenAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AzureValue{
		AccountKey:       accountKeyVal,
		AccountName:      accountNameVal,
		ConnectionString: connectionStringVal,
		Recursive:        recursiveVal,
		RemoteUrl:        remoteUrlVal,
		SasToken:         sasTokenVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewAzureValueNull() AzureValue {
	return AzureValue{
		state: attr.ValueStateNull,
	}
}

func NewAzureValueUnknown() AzureValue {
	return AzureValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAzureValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AzureValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AzureValue Attribute Value",
				"While creating a AzureValue value, a missing attribute value was detected. "+
					"A AzureValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AzureValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AzureValue Attribute Type",
				"While creating a AzureValue value, an invalid attribute value was detected. "+
					"A AzureValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AzureValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AzureValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AzureValue Attribute Value",
				"While creating a AzureValue value, an extra attribute value was detected. "+
					"A AzureValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AzureValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAzureValueUnknown(), diags
	}

	accountKeyAttribute, ok := attributes["account_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`account_key is missing from object`)

		return NewAzureValueUnknown(), diags
	}

	accountKeyVal, ok := accountKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`account_key expected to be basetypes.StringValue, was: %T`, accountKeyAttribute))
	}

	accountNameAttribute, ok := attributes["account_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`account_name is missing from object`)

		return NewAzureValueUnknown(), diags
	}

	accountNameVal, ok := accountNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`account_name expected to be basetypes.StringValue, was: %T`, accountNameAttribute))
	}

	connectionStringAttribute, ok := attributes["connection_string"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`connection_string is missing from object`)

		return NewAzureValueUnknown(), diags
	}

	connectionStringVal, ok := connectionStringAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`connection_string expected to be basetypes.StringValue, was: %T`, connectionStringAttribute))
	}

	recursiveAttribute, ok := attributes["recursive"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`recursive is missing from object`)

		return NewAzureValueUnknown(), diags
	}

	recursiveVal, ok := recursiveAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`recursive expected to be basetypes.BoolValue, was: %T`, recursiveAttribute))
	}

	remoteUrlAttribute, ok := attributes["remote_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remote_url is missing from object`)

		return NewAzureValueUnknown(), diags
	}

	remoteUrlVal, ok := remoteUrlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remote_url expected to be basetypes.StringValue, was: %T`, remoteUrlAttribute))
	}

	sasTokenAttribute, ok := attributes["sas_token"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sas_token is missing from object`)

		return NewAzureValueUnknown(), diags
	}

	sasTokenVal, ok := sasTokenAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sas_token expected to be basetypes.StringValue, was: %T`, sasTokenAttribute))
	}

	if diags.HasError() {
		return NewAzureValueUnknown(), diags
	}

	return AzureValue{
		AccountKey:       accountKeyVal,
		AccountName:      accountNameVal,
		ConnectionString: connectionStringVal,
		Recursive:        recursiveVal,
		RemoteUrl:        remoteUrlVal,
		SasToken:         sasTokenVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewAzureValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AzureValue {
	object, diags := NewAzureValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAzureValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AzureType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAzureValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAzureValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAzureValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAzureValueMust(AzureValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AzureType) ValueType(ctx context.Context) attr.Value {
	return AzureValue{}
}

var _ basetypes.ObjectValuable = AzureValue{}

type AzureValue struct {
	AccountKey       basetypes.StringValue `tfsdk:"account_key"`
	AccountName      basetypes.StringValue `tfsdk:"account_name"`
	ConnectionString basetypes.StringValue `tfsdk:"connection_string"`
	Recursive        basetypes.BoolValue   `tfsdk:"recursive"`
	RemoteUrl        basetypes.StringValue `tfsdk:"remote_url"`
	SasToken         basetypes.StringValue `tfsdk:"sas_token"`
	state            attr.ValueState
}

func (v AzureValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 6)

	var val tftypes.Value
	var err error

	attrTypes["account_key"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["account_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["connection_string"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["recursive"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["remote_url"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["sas_token"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 6)

		val, err = v.AccountKey.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["account_key"] = val

		val, err = v.AccountName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["account_name"] = val

		val, err = v.ConnectionString.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["connection_string"] = val

		val, err = v.Recursive.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["recursive"] = val

		val, err = v.RemoteUrl.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["remote_url"] = val

		val, err = v.SasToken.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["sas_token"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AzureValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AzureValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AzureValue) String() string {
	return "AzureValue"
}

func (v AzureValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"account_key":       basetypes.StringType{},
		"account_name":      basetypes.StringType{},
		"connection_string": basetypes.StringType{},
		"recursive":         basetypes.BoolType{},
		"remote_url":        basetypes.StringType{},
		"sas_token":         basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"account_key":       v.AccountKey,
			"account_name":      v.AccountName,
			"connection_string": v.ConnectionString,
			"recursive":         v.Recursive,
			"remote_url":        v.RemoteUrl,
			"sas_token":         v.SasToken,
		})

	return objVal, diags
}

func (v AzureValue) Equal(o attr.Value) bool {
	other, ok := o.(AzureValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AccountKey.Equal(other.AccountKey) {
		return false
	}

	if !v.AccountName.Equal(other.AccountName) {
		return false
	}

	if !v.ConnectionString.Equal(other.ConnectionString) {
		return false
	}

	if !v.Recursive.Equal(other.Recursive) {
		return false
	}

	if !v.RemoteUrl.Equal(other.RemoteUrl) {
		return false
	}

	if !v.SasToken.Equal(other.SasToken) {
		return false
	}

	return true
}

func (v AzureValue) Type(ctx context.Context) attr.Type {
	return AzureType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AzureValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"account_key":       basetypes.StringType{},
		"account_name":      basetypes.StringType{},
		"connection_string": basetypes.StringType{},
		"recursive":         basetypes.BoolType{},
		"remote_url":        basetypes.StringType{},
		"sas_token":         basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = BoxType{}

type BoxType struct {
	basetypes.ObjectType
}

func (t BoxType) Equal(o attr.Type) bool {
	other, ok := o.(BoxType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t BoxType) String() string {
	return "BoxType"
}

func (t BoxType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	boxAppConfigAttribute, ok := attributes["box_app_config"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`box_app_config is missing from object`)

		return nil, diags
	}

	boxAppConfigVal, ok := boxAppConfigAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`box_app_config expected to be basetypes.StringValue, was: %T`, boxAppConfigAttribute))
	}

	recursiveAttribute, ok := attributes["recursive"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`recursive is missing from object`)

		return nil, diags
	}

	recursiveVal, ok := recursiveAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`recursive expected to be basetypes.BoolValue, was: %T`, recursiveAttribute))
	}

	remoteUrlAttribute, ok := attributes["remote_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remote_url is missing from object`)

		return nil, diags
	}

	remoteUrlVal, ok := remoteUrlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remote_url expected to be basetypes.StringValue, was: %T`, remoteUrlAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return BoxValue{
		BoxAppConfig: boxAppConfigVal,
		Recursive:    recursiveVal,
		RemoteUrl:    remoteUrlVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewBoxValueNull() BoxValue {
	return BoxValue{
		state: attr.ValueStateNull,
	}
}

func NewBoxValueUnknown() BoxValue {
	return BoxValue{
		state: attr.ValueStateUnknown,
	}
}

func NewBoxValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (BoxValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing BoxValue Attribute Value",
				"While creating a BoxValue value, a missing attribute value was detected. "+
					"A BoxValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BoxValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid BoxValue Attribute Type",
				"While creating a BoxValue value, an invalid attribute value was detected. "+
					"A BoxValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BoxValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("BoxValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra BoxValue Attribute Value",
				"While creating a BoxValue value, an extra attribute value was detected. "+
					"A BoxValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra BoxValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewBoxValueUnknown(), diags
	}

	boxAppConfigAttribute, ok := attributes["box_app_config"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`box_app_config is missing from object`)

		return NewBoxValueUnknown(), diags
	}

	boxAppConfigVal, ok := boxAppConfigAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`box_app_config expected to be basetypes.StringValue, was: %T`, boxAppConfigAttribute))
	}

	recursiveAttribute, ok := attributes["recursive"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`recursive is missing from object`)

		return NewBoxValueUnknown(), diags
	}

	recursiveVal, ok := recursiveAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`recursive expected to be basetypes.BoolValue, was: %T`, recursiveAttribute))
	}

	remoteUrlAttribute, ok := attributes["remote_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remote_url is missing from object`)

		return NewBoxValueUnknown(), diags
	}

	remoteUrlVal, ok := remoteUrlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remote_url expected to be basetypes.StringValue, was: %T`, remoteUrlAttribute))
	}

	if diags.HasError() {
		return NewBoxValueUnknown(), diags
	}

	return BoxValue{
		BoxAppConfig: boxAppConfigVal,
		Recursive:    recursiveVal,
		RemoteUrl:    remoteUrlVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewBoxValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) BoxValue {
	object, diags := NewBoxValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewBoxValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t BoxType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewBoxValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewBoxValueUnknown(), nil
	}

	if in.IsNull() {
		return NewBoxValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewBoxValueMust(BoxValue{}.AttributeTypes(ctx), attributes), nil
}

func (t BoxType) ValueType(ctx context.Context) attr.Value {
	return BoxValue{}
}

var _ basetypes.ObjectValuable = BoxValue{}

type BoxValue struct {
	BoxAppConfig basetypes.StringValue `tfsdk:"box_app_config"`
	Recursive    basetypes.BoolValue   `tfsdk:"recursive"`
	RemoteUrl    basetypes.StringValue `tfsdk:"remote_url"`
	state        attr.ValueState
}

func (v BoxValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["box_app_config"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["recursive"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["remote_url"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.BoxAppConfig.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["box_app_config"] = val

		val, err = v.Recursive.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["recursive"] = val

		val, err = v.RemoteUrl.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["remote_url"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v BoxValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v BoxValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v BoxValue) String() string {
	return "BoxValue"
}

func (v BoxValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"box_app_config": basetypes.StringType{},
		"recursive":      basetypes.BoolType{},
		"remote_url":     basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"box_app_config": v.BoxAppConfig,
			"recursive":      v.Recursive,
			"remote_url":     v.RemoteUrl,
		})

	return objVal, diags
}

func (v BoxValue) Equal(o attr.Value) bool {
	other, ok := o.(BoxValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.BoxAppConfig.Equal(other.BoxAppConfig) {
		return false
	}

	if !v.Recursive.Equal(other.Recursive) {
		return false
	}

	if !v.RemoteUrl.Equal(other.RemoteUrl) {
		return false
	}

	return true
}

func (v BoxValue) Type(ctx context.Context) attr.Type {
	return BoxType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v BoxValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"box_app_config": basetypes.StringType{},
		"recursive":      basetypes.BoolType{},
		"remote_url":     basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = ConfluenceType{}

type ConfluenceType struct {
	basetypes.ObjectType
}

func (t ConfluenceType) Equal(o attr.Type) bool {
	other, ok := o.(ConfluenceType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ConfluenceType) String() string {
	return "ConfluenceType"
}

func (t ConfluenceType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	apiTokenAttribute, ok := attributes["api_token"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`api_token is missing from object`)

		return nil, diags
	}

	apiTokenVal, ok := apiTokenAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`api_token expected to be basetypes.StringValue, was: %T`, apiTokenAttribute))
	}

	cloudAttribute, ok := attributes["cloud"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cloud is missing from object`)

		return nil, diags
	}

	cloudVal, ok := cloudAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cloud expected to be basetypes.BoolValue, was: %T`, cloudAttribute))
	}

	extractFilesAttribute, ok := attributes["extract_files"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`extract_files is missing from object`)

		return nil, diags
	}

	extractFilesVal, ok := extractFilesAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`extract_files expected to be basetypes.BoolValue, was: %T`, extractFilesAttribute))
	}

	extractImagesAttribute, ok := attributes["extract_images"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`extract_images is missing from object`)

		return nil, diags
	}

	extractImagesVal, ok := extractImagesAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`extract_images expected to be basetypes.BoolValue, was: %T`, extractImagesAttribute))
	}

	maxNumOfDocsFromEachSpaceAttribute, ok := attributes["max_num_of_docs_from_each_space"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_num_of_docs_from_each_space is missing from object`)

		return nil, diags
	}

	maxNumOfDocsFromEachSpaceVal, ok := maxNumOfDocsFromEachSpaceAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_num_of_docs_from_each_space expected to be basetypes.Int64Value, was: %T`, maxNumOfDocsFromEachSpaceAttribute))
	}

	maxNumOfSpacesAttribute, ok := attributes["max_num_of_spaces"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_num_of_spaces is missing from object`)

		return nil, diags
	}

	maxNumOfSpacesVal, ok := maxNumOfSpacesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_num_of_spaces expected to be basetypes.Int64Value, was: %T`, maxNumOfSpacesAttribute))
	}

	passwordAttribute, ok := attributes["password"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`password is missing from object`)

		return nil, diags
	}

	passwordVal, ok := passwordAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`password expected to be basetypes.StringValue, was: %T`, passwordAttribute))
	}

	spacesAttribute, ok := attributes["spaces"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`spaces is missing from object`)

		return nil, diags
	}

	spacesVal, ok := spacesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`spaces expected to be basetypes.ListValue, was: %T`, spacesAttribute))
	}

	tokenAttribute, ok := attributes["token"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`token is missing from object`)

		return nil, diags
	}

	tokenVal, ok := tokenAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`token expected to be basetypes.StringValue, was: %T`, tokenAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return nil, diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	usernameAttribute, ok := attributes["username"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`username is missing from object`)

		return nil, diags
	}

	usernameVal, ok := usernameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`username expected to be basetypes.StringValue, was: %T`, usernameAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ConfluenceValue{
		ApiToken:                  apiTokenVal,
		Cloud:                     cloudVal,
		ExtractFiles:              extractFilesVal,
		ExtractImages:             extractImagesVal,
		MaxNumOfDocsFromEachSpace: maxNumOfDocsFromEachSpaceVal,
		MaxNumOfSpaces:            maxNumOfSpacesVal,
		Password:                  passwordVal,
		Spaces:                    spacesVal,
		Token:                     tokenVal,
		Url:                       urlVal,
		Username:                  usernameVal,
		state:                     attr.ValueStateKnown,
	}, diags
}

func NewConfluenceValueNull() ConfluenceValue {
	return ConfluenceValue{
		state: attr.ValueStateNull,
	}
}

func NewConfluenceValueUnknown() ConfluenceValue {
	return ConfluenceValue{
		state: attr.ValueStateUnknown,
	}
}

func NewConfluenceValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ConfluenceValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ConfluenceValue Attribute Value",
				"While creating a ConfluenceValue value, a missing attribute value was detected. "+
					"A ConfluenceValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ConfluenceValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ConfluenceValue Attribute Type",
				"While creating a ConfluenceValue value, an invalid attribute value was detected. "+
					"A ConfluenceValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ConfluenceValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ConfluenceValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ConfluenceValue Attribute Value",
				"While creating a ConfluenceValue value, an extra attribute value was detected. "+
					"A ConfluenceValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ConfluenceValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewConfluenceValueUnknown(), diags
	}

	apiTokenAttribute, ok := attributes["api_token"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`api_token is missing from object`)

		return NewConfluenceValueUnknown(), diags
	}

	apiTokenVal, ok := apiTokenAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`api_token expected to be basetypes.StringValue, was: %T`, apiTokenAttribute))
	}

	cloudAttribute, ok := attributes["cloud"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cloud is missing from object`)

		return NewConfluenceValueUnknown(), diags
	}

	cloudVal, ok := cloudAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cloud expected to be basetypes.BoolValue, was: %T`, cloudAttribute))
	}

	extractFilesAttribute, ok := attributes["extract_files"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`extract_files is missing from object`)

		return NewConfluenceValueUnknown(), diags
	}

	extractFilesVal, ok := extractFilesAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`extract_files expected to be basetypes.BoolValue, was: %T`, extractFilesAttribute))
	}

	extractImagesAttribute, ok := attributes["extract_images"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`extract_images is missing from object`)

		return NewConfluenceValueUnknown(), diags
	}

	extractImagesVal, ok := extractImagesAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`extract_images expected to be basetypes.BoolValue, was: %T`, extractImagesAttribute))
	}

	maxNumOfDocsFromEachSpaceAttribute, ok := attributes["max_num_of_docs_from_each_space"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_num_of_docs_from_each_space is missing from object`)

		return NewConfluenceValueUnknown(), diags
	}

	maxNumOfDocsFromEachSpaceVal, ok := maxNumOfDocsFromEachSpaceAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_num_of_docs_from_each_space expected to be basetypes.Int64Value, was: %T`, maxNumOfDocsFromEachSpaceAttribute))
	}

	maxNumOfSpacesAttribute, ok := attributes["max_num_of_spaces"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_num_of_spaces is missing from object`)

		return NewConfluenceValueUnknown(), diags
	}

	maxNumOfSpacesVal, ok := maxNumOfSpacesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_num_of_spaces expected to be basetypes.Int64Value, was: %T`, maxNumOfSpacesAttribute))
	}

	passwordAttribute, ok := attributes["password"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`password is missing from object`)

		return NewConfluenceValueUnknown(), diags
	}

	passwordVal, ok := passwordAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`password expected to be basetypes.StringValue, was: %T`, passwordAttribute))
	}

	spacesAttribute, ok := attributes["spaces"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`spaces is missing from object`)

		return NewConfluenceValueUnknown(), diags
	}

	spacesVal, ok := spacesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`spaces expected to be basetypes.ListValue, was: %T`, spacesAttribute))
	}

	tokenAttribute, ok := attributes["token"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`token is missing from object`)

		return NewConfluenceValueUnknown(), diags
	}

	tokenVal, ok := tokenAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`token expected to be basetypes.StringValue, was: %T`, tokenAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return NewConfluenceValueUnknown(), diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	usernameAttribute, ok := attributes["username"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`username is missing from object`)

		return NewConfluenceValueUnknown(), diags
	}

	usernameVal, ok := usernameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`username expected to be basetypes.StringValue, was: %T`, usernameAttribute))
	}

	if diags.HasError() {
		return NewConfluenceValueUnknown(), diags
	}

	return ConfluenceValue{
		ApiToken:                  apiTokenVal,
		Cloud:                     cloudVal,
		ExtractFiles:              extractFilesVal,
		ExtractImages:             extractImagesVal,
		MaxNumOfDocsFromEachSpace: maxNumOfDocsFromEachSpaceVal,
		MaxNumOfSpaces:            maxNumOfSpacesVal,
		Password:                  passwordVal,
		Spaces:                    spacesVal,
		Token:                     tokenVal,
		Url:                       urlVal,
		Username:                  usernameVal,
		state:                     attr.ValueStateKnown,
	}, diags
}

func NewConfluenceValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ConfluenceValue {
	object, diags := NewConfluenceValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewConfluenceValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ConfluenceType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewConfluenceValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewConfluenceValueUnknown(), nil
	}

	if in.IsNull() {
		return NewConfluenceValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewConfluenceValueMust(ConfluenceValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ConfluenceType) ValueType(ctx context.Context) attr.Value {
	return ConfluenceValue{}
}

var _ basetypes.ObjectValuable = ConfluenceValue{}

type ConfluenceValue struct {
	ApiToken                  basetypes.StringValue `tfsdk:"api_token"`
	Cloud                     basetypes.BoolValue   `tfsdk:"cloud"`
	ExtractFiles              basetypes.BoolValue   `tfsdk:"extract_files"`
	ExtractImages             basetypes.BoolValue   `tfsdk:"extract_images"`
	MaxNumOfDocsFromEachSpace basetypes.Int64Value  `tfsdk:"max_num_of_docs_from_each_space"`
	MaxNumOfSpaces            basetypes.Int64Value  `tfsdk:"max_num_of_spaces"`
	Password                  basetypes.StringValue `tfsdk:"password"`
	Spaces                    basetypes.ListValue   `tfsdk:"spaces"`
	Token                     basetypes.StringValue `tfsdk:"token"`
	Url                       basetypes.StringValue `tfsdk:"url"`
	Username                  basetypes.StringValue `tfsdk:"username"`
	state                     attr.ValueState
}

func (v ConfluenceValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 11)

	var val tftypes.Value
	var err error

	attrTypes["api_token"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["cloud"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["extract_files"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["extract_images"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["max_num_of_docs_from_each_space"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["max_num_of_spaces"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["password"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["spaces"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["token"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["url"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["username"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 11)

		val, err = v.ApiToken.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["api_token"] = val

		val, err = v.Cloud.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cloud"] = val

		val, err = v.ExtractFiles.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["extract_files"] = val

		val, err = v.ExtractImages.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["extract_images"] = val

		val, err = v.MaxNumOfDocsFromEachSpace.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_num_of_docs_from_each_space"] = val

		val, err = v.MaxNumOfSpaces.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_num_of_spaces"] = val

		val, err = v.Password.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["password"] = val

		val, err = v.Spaces.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["spaces"] = val

		val, err = v.Token.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["token"] = val

		val, err = v.Url.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["url"] = val

		val, err = v.Username.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["username"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ConfluenceValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ConfluenceValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ConfluenceValue) String() string {
	return "ConfluenceValue"
}

func (v ConfluenceValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var spacesVal basetypes.ListValue
	switch {
	case v.Spaces.IsUnknown():
		spacesVal = types.ListUnknown(types.StringType)
	case v.Spaces.IsNull():
		spacesVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		spacesVal, d = types.ListValue(types.StringType, v.Spaces.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"api_token":                       basetypes.StringType{},
			"cloud":                           basetypes.BoolType{},
			"extract_files":                   basetypes.BoolType{},
			"extract_images":                  basetypes.BoolType{},
			"max_num_of_docs_from_each_space": basetypes.Int64Type{},
			"max_num_of_spaces":               basetypes.Int64Type{},
			"password":                        basetypes.StringType{},
			"spaces": basetypes.ListType{
				ElemType: types.StringType,
			},
			"token":    basetypes.StringType{},
			"url":      basetypes.StringType{},
			"username": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"api_token":                       basetypes.StringType{},
		"cloud":                           basetypes.BoolType{},
		"extract_files":                   basetypes.BoolType{},
		"extract_images":                  basetypes.BoolType{},
		"max_num_of_docs_from_each_space": basetypes.Int64Type{},
		"max_num_of_spaces":               basetypes.Int64Type{},
		"password":                        basetypes.StringType{},
		"spaces": basetypes.ListType{
			ElemType: types.StringType,
		},
		"token":    basetypes.StringType{},
		"url":      basetypes.StringType{},
		"username": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"api_token":                       v.ApiToken,
			"cloud":                           v.Cloud,
			"extract_files":                   v.ExtractFiles,
			"extract_images":                  v.ExtractImages,
			"max_num_of_docs_from_each_space": v.MaxNumOfDocsFromEachSpace,
			"max_num_of_spaces":               v.MaxNumOfSpaces,
			"password":                        v.Password,
			"spaces":                          spacesVal,
			"token":                           v.Token,
			"url":                             v.Url,
			"username":                        v.Username,
		})

	return objVal, diags
}

func (v ConfluenceValue) Equal(o attr.Value) bool {
	other, ok := o.(ConfluenceValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ApiToken.Equal(other.ApiToken) {
		return false
	}

	if !v.Cloud.Equal(other.Cloud) {
		return false
	}

	if !v.ExtractFiles.Equal(other.ExtractFiles) {
		return false
	}

	if !v.ExtractImages.Equal(other.ExtractImages) {
		return false
	}

	if !v.MaxNumOfDocsFromEachSpace.Equal(other.MaxNumOfDocsFromEachSpace) {
		return false
	}

	if !v.MaxNumOfSpaces.Equal(other.MaxNumOfSpaces) {
		return false
	}

	if !v.Password.Equal(other.Password) {
		return false
	}

	if !v.Spaces.Equal(other.Spaces) {
		return false
	}

	if !v.Token.Equal(other.Token) {
		return false
	}

	if !v.Url.Equal(other.Url) {
		return false
	}

	if !v.Username.Equal(other.Username) {
		return false
	}

	return true
}

func (v ConfluenceValue) Type(ctx context.Context) attr.Type {
	return ConfluenceType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ConfluenceValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"api_token":                       basetypes.StringType{},
		"cloud":                           basetypes.BoolType{},
		"extract_files":                   basetypes.BoolType{},
		"extract_images":                  basetypes.BoolType{},
		"max_num_of_docs_from_each_space": basetypes.Int64Type{},
		"max_num_of_spaces":               basetypes.Int64Type{},
		"password":                        basetypes.StringType{},
		"spaces": basetypes.ListType{
			ElemType: types.StringType,
		},
		"token":    basetypes.StringType{},
		"url":      basetypes.StringType{},
		"username": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = CouchbaseType{}

type CouchbaseType struct {
	basetypes.ObjectType
}

func (t CouchbaseType) Equal(o attr.Type) bool {
	other, ok := o.(CouchbaseType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t CouchbaseType) String() string {
	return "CouchbaseType"
}

func (t CouchbaseType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	batchSizeAttribute, ok := attributes["batch_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`batch_size is missing from object`)

		return nil, diags
	}

	batchSizeVal, ok := batchSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`batch_size expected to be basetypes.Int64Value, was: %T`, batchSizeAttribute))
	}

	bucketAttribute, ok := attributes["bucket"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bucket is missing from object`)

		return nil, diags
	}

	bucketVal, ok := bucketAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bucket expected to be basetypes.StringValue, was: %T`, bucketAttribute))
	}

	collectionAttribute, ok := attributes["collection"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`collection is missing from object`)

		return nil, diags
	}

	collectionVal, ok := collectionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`collection expected to be basetypes.StringValue, was: %T`, collectionAttribute))
	}

	collectionIdAttribute, ok := attributes["collection_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`collection_id is missing from object`)

		return nil, diags
	}

	collectionIdVal, ok := collectionIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`collection_id expected to be basetypes.StringValue, was: %T`, collectionIdAttribute))
	}

	connectionStringAttribute, ok := attributes["connection_string"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`connection_string is missing from object`)

		return nil, diags
	}

	connectionStringVal, ok := connectionStringAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`connection_string expected to be basetypes.StringValue, was: %T`, connectionStringAttribute))
	}

	passwordAttribute, ok := attributes["password"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`password is missing from object`)

		return nil, diags
	}

	passwordVal, ok := passwordAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`password expected to be basetypes.StringValue, was: %T`, passwordAttribute))
	}

	scopeAttribute, ok := attributes["scope"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`scope is missing from object`)

		return nil, diags
	}

	scopeVal, ok := scopeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`scope expected to be basetypes.StringValue, was: %T`, scopeAttribute))
	}

	usernameAttribute, ok := attributes["username"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`username is missing from object`)

		return nil, diags
	}

	usernameVal, ok := usernameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`username expected to be basetypes.StringValue, was: %T`, usernameAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return CouchbaseValue{
		BatchSize:        batchSizeVal,
		Bucket:           bucketVal,
		Collection:       collectionVal,
		CollectionId:     collectionIdVal,
		ConnectionString: connectionStringVal,
		Password:         passwordVal,
		Scope:            scopeVal,
		Username:         usernameVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewCouchbaseValueNull() CouchbaseValue {
	return CouchbaseValue{
		state: attr.ValueStateNull,
	}
}

func NewCouchbaseValueUnknown() CouchbaseValue {
	return CouchbaseValue{
		state: attr.ValueStateUnknown,
	}
}

func NewCouchbaseValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (CouchbaseValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing CouchbaseValue Attribute Value",
				"While creating a CouchbaseValue value, a missing attribute value was detected. "+
					"A CouchbaseValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CouchbaseValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid CouchbaseValue Attribute Type",
				"While creating a CouchbaseValue value, an invalid attribute value was detected. "+
					"A CouchbaseValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CouchbaseValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("CouchbaseValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra CouchbaseValue Attribute Value",
				"While creating a CouchbaseValue value, an extra attribute value was detected. "+
					"A CouchbaseValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra CouchbaseValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewCouchbaseValueUnknown(), diags
	}

	batchSizeAttribute, ok := attributes["batch_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`batch_size is missing from object`)

		return NewCouchbaseValueUnknown(), diags
	}

	batchSizeVal, ok := batchSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`batch_size expected to be basetypes.Int64Value, was: %T`, batchSizeAttribute))
	}

	bucketAttribute, ok := attributes["bucket"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bucket is missing from object`)

		return NewCouchbaseValueUnknown(), diags
	}

	bucketVal, ok := bucketAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bucket expected to be basetypes.StringValue, was: %T`, bucketAttribute))
	}

	collectionAttribute, ok := attributes["collection"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`collection is missing from object`)

		return NewCouchbaseValueUnknown(), diags
	}

	collectionVal, ok := collectionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`collection expected to be basetypes.StringValue, was: %T`, collectionAttribute))
	}

	collectionIdAttribute, ok := attributes["collection_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`collection_id is missing from object`)

		return NewCouchbaseValueUnknown(), diags
	}

	collectionIdVal, ok := collectionIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`collection_id expected to be basetypes.StringValue, was: %T`, collectionIdAttribute))
	}

	connectionStringAttribute, ok := attributes["connection_string"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`connection_string is missing from object`)

		return NewCouchbaseValueUnknown(), diags
	}

	connectionStringVal, ok := connectionStringAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`connection_string expected to be basetypes.StringValue, was: %T`, connectionStringAttribute))
	}

	passwordAttribute, ok := attributes["password"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`password is missing from object`)

		return NewCouchbaseValueUnknown(), diags
	}

	passwordVal, ok := passwordAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`password expected to be basetypes.StringValue, was: %T`, passwordAttribute))
	}

	scopeAttribute, ok := attributes["scope"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`scope is missing from object`)

		return NewCouchbaseValueUnknown(), diags
	}

	scopeVal, ok := scopeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`scope expected to be basetypes.StringValue, was: %T`, scopeAttribute))
	}

	usernameAttribute, ok := attributes["username"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`username is missing from object`)

		return NewCouchbaseValueUnknown(), diags
	}

	usernameVal, ok := usernameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`username expected to be basetypes.StringValue, was: %T`, usernameAttribute))
	}

	if diags.HasError() {
		return NewCouchbaseValueUnknown(), diags
	}

	return CouchbaseValue{
		BatchSize:        batchSizeVal,
		Bucket:           bucketVal,
		Collection:       collectionVal,
		CollectionId:     collectionIdVal,
		ConnectionString: connectionStringVal,
		Password:         passwordVal,
		Scope:            scopeVal,
		Username:         usernameVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewCouchbaseValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) CouchbaseValue {
	object, diags := NewCouchbaseValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewCouchbaseValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t CouchbaseType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewCouchbaseValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewCouchbaseValueUnknown(), nil
	}

	if in.IsNull() {
		return NewCouchbaseValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewCouchbaseValueMust(CouchbaseValue{}.AttributeTypes(ctx), attributes), nil
}

func (t CouchbaseType) ValueType(ctx context.Context) attr.Value {
	return CouchbaseValue{}
}

var _ basetypes.ObjectValuable = CouchbaseValue{}

type CouchbaseValue struct {
	BatchSize        basetypes.Int64Value  `tfsdk:"batch_size"`
	Bucket           basetypes.StringValue `tfsdk:"bucket"`
	Collection       basetypes.StringValue `tfsdk:"collection"`
	CollectionId     basetypes.StringValue `tfsdk:"collection_id"`
	ConnectionString basetypes.StringValue `tfsdk:"connection_string"`
	Password         basetypes.StringValue `tfsdk:"password"`
	Scope            basetypes.StringValue `tfsdk:"scope"`
	Username         basetypes.StringValue `tfsdk:"username"`
	state            attr.ValueState
}

func (v CouchbaseValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 8)

	var val tftypes.Value
	var err error

	attrTypes["batch_size"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["bucket"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["collection"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["collection_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["connection_string"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["password"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["scope"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["username"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 8)

		val, err = v.BatchSize.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["batch_size"] = val

		val, err = v.Bucket.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bucket"] = val

		val, err = v.Collection.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["collection"] = val

		val, err = v.CollectionId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["collection_id"] = val

		val, err = v.ConnectionString.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["connection_string"] = val

		val, err = v.Password.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["password"] = val

		val, err = v.Scope.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["scope"] = val

		val, err = v.Username.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["username"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v CouchbaseValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v CouchbaseValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v CouchbaseValue) String() string {
	return "CouchbaseValue"
}

func (v CouchbaseValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"batch_size":        basetypes.Int64Type{},
		"bucket":            basetypes.StringType{},
		"collection":        basetypes.StringType{},
		"collection_id":     basetypes.StringType{},
		"connection_string": basetypes.StringType{},
		"password":          basetypes.StringType{},
		"scope":             basetypes.StringType{},
		"username":          basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"batch_size":        v.BatchSize,
			"bucket":            v.Bucket,
			"collection":        v.Collection,
			"collection_id":     v.CollectionId,
			"connection_string": v.ConnectionString,
			"password":          v.Password,
			"scope":             v.Scope,
			"username":          v.Username,
		})

	return objVal, diags
}

func (v CouchbaseValue) Equal(o attr.Value) bool {
	other, ok := o.(CouchbaseValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.BatchSize.Equal(other.BatchSize) {
		return false
	}

	if !v.Bucket.Equal(other.Bucket) {
		return false
	}

	if !v.Collection.Equal(other.Collection) {
		return false
	}

	if !v.CollectionId.Equal(other.CollectionId) {
		return false
	}

	if !v.ConnectionString.Equal(other.ConnectionString) {
		return false
	}

	if !v.Password.Equal(other.Password) {
		return false
	}

	if !v.Scope.Equal(other.Scope) {
		return false
	}

	if !v.Username.Equal(other.Username) {
		return false
	}

	return true
}

func (v CouchbaseValue) Type(ctx context.Context) attr.Type {
	return CouchbaseType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v CouchbaseValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"batch_size":        basetypes.Int64Type{},
		"bucket":            basetypes.StringType{},
		"collection":        basetypes.StringType{},
		"collection_id":     basetypes.StringType{},
		"connection_string": basetypes.StringType{},
		"password":          basetypes.StringType{},
		"scope":             basetypes.StringType{},
		"username":          basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = DatabricksVolumesType{}

type DatabricksVolumesType struct {
	basetypes.ObjectType
}

func (t DatabricksVolumesType) Equal(o attr.Type) bool {
	other, ok := o.(DatabricksVolumesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t DatabricksVolumesType) String() string {
	return "DatabricksVolumesType"
}

func (t DatabricksVolumesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	catalogAttribute, ok := attributes["catalog"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`catalog is missing from object`)

		return nil, diags
	}

	catalogVal, ok := catalogAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`catalog expected to be basetypes.StringValue, was: %T`, catalogAttribute))
	}

	clientIdAttribute, ok := attributes["client_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`client_id is missing from object`)

		return nil, diags
	}

	clientIdVal, ok := clientIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`client_id expected to be basetypes.StringValue, was: %T`, clientIdAttribute))
	}

	clientSecretAttribute, ok := attributes["client_secret"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`client_secret is missing from object`)

		return nil, diags
	}

	clientSecretVal, ok := clientSecretAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`client_secret expected to be basetypes.StringValue, was: %T`, clientSecretAttribute))
	}

	hostAttribute, ok := attributes["host"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`host is missing from object`)

		return nil, diags
	}

	hostVal, ok := hostAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`host expected to be basetypes.StringValue, was: %T`, hostAttribute))
	}

	schemaAttribute, ok := attributes["schema"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`schema is missing from object`)

		return nil, diags
	}

	schemaVal, ok := schemaAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`schema expected to be basetypes.StringValue, was: %T`, schemaAttribute))
	}

	volumeAttribute, ok := attributes["volume"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume is missing from object`)

		return nil, diags
	}

	volumeVal, ok := volumeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume expected to be basetypes.StringValue, was: %T`, volumeAttribute))
	}

	volumePathAttribute, ok := attributes["volume_path"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_path is missing from object`)

		return nil, diags
	}

	volumePathVal, ok := volumePathAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_path expected to be basetypes.StringValue, was: %T`, volumePathAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return DatabricksVolumesValue{
		Catalog:      catalogVal,
		ClientId:     clientIdVal,
		ClientSecret: clientSecretVal,
		Host:         hostVal,
		Schema:       schemaVal,
		Volume:       volumeVal,
		VolumePath:   volumePathVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewDatabricksVolumesValueNull() DatabricksVolumesValue {
	return DatabricksVolumesValue{
		state: attr.ValueStateNull,
	}
}

func NewDatabricksVolumesValueUnknown() DatabricksVolumesValue {
	return DatabricksVolumesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDatabricksVolumesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (DatabricksVolumesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing DatabricksVolumesValue Attribute Value",
				"While creating a DatabricksVolumesValue value, a missing attribute value was detected. "+
					"A DatabricksVolumesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DatabricksVolumesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid DatabricksVolumesValue Attribute Type",
				"While creating a DatabricksVolumesValue value, an invalid attribute value was detected. "+
					"A DatabricksVolumesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DatabricksVolumesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("DatabricksVolumesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra DatabricksVolumesValue Attribute Value",
				"While creating a DatabricksVolumesValue value, an extra attribute value was detected. "+
					"A DatabricksVolumesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra DatabricksVolumesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDatabricksVolumesValueUnknown(), diags
	}

	catalogAttribute, ok := attributes["catalog"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`catalog is missing from object`)

		return NewDatabricksVolumesValueUnknown(), diags
	}

	catalogVal, ok := catalogAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`catalog expected to be basetypes.StringValue, was: %T`, catalogAttribute))
	}

	clientIdAttribute, ok := attributes["client_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`client_id is missing from object`)

		return NewDatabricksVolumesValueUnknown(), diags
	}

	clientIdVal, ok := clientIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`client_id expected to be basetypes.StringValue, was: %T`, clientIdAttribute))
	}

	clientSecretAttribute, ok := attributes["client_secret"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`client_secret is missing from object`)

		return NewDatabricksVolumesValueUnknown(), diags
	}

	clientSecretVal, ok := clientSecretAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`client_secret expected to be basetypes.StringValue, was: %T`, clientSecretAttribute))
	}

	hostAttribute, ok := attributes["host"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`host is missing from object`)

		return NewDatabricksVolumesValueUnknown(), diags
	}

	hostVal, ok := hostAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`host expected to be basetypes.StringValue, was: %T`, hostAttribute))
	}

	schemaAttribute, ok := attributes["schema"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`schema is missing from object`)

		return NewDatabricksVolumesValueUnknown(), diags
	}

	schemaVal, ok := schemaAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`schema expected to be basetypes.StringValue, was: %T`, schemaAttribute))
	}

	volumeAttribute, ok := attributes["volume"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume is missing from object`)

		return NewDatabricksVolumesValueUnknown(), diags
	}

	volumeVal, ok := volumeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume expected to be basetypes.StringValue, was: %T`, volumeAttribute))
	}

	volumePathAttribute, ok := attributes["volume_path"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_path is missing from object`)

		return NewDatabricksVolumesValueUnknown(), diags
	}

	volumePathVal, ok := volumePathAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_path expected to be basetypes.StringValue, was: %T`, volumePathAttribute))
	}

	if diags.HasError() {
		return NewDatabricksVolumesValueUnknown(), diags
	}

	return DatabricksVolumesValue{
		Catalog:      catalogVal,
		ClientId:     clientIdVal,
		ClientSecret: clientSecretVal,
		Host:         hostVal,
		Schema:       schemaVal,
		Volume:       volumeVal,
		VolumePath:   volumePathVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewDatabricksVolumesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) DatabricksVolumesValue {
	object, diags := NewDatabricksVolumesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDatabricksVolumesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t DatabricksVolumesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDatabricksVolumesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDatabricksVolumesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDatabricksVolumesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDatabricksVolumesValueMust(DatabricksVolumesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t DatabricksVolumesType) ValueType(ctx context.Context) attr.Value {
	return DatabricksVolumesValue{}
}

var _ basetypes.ObjectValuable = DatabricksVolumesValue{}

type DatabricksVolumesValue struct {
	Catalog      basetypes.StringValue `tfsdk:"catalog"`
	ClientId     basetypes.StringValue `tfsdk:"client_id"`
	ClientSecret basetypes.StringValue `tfsdk:"client_secret"`
	Host         basetypes.StringValue `tfsdk:"host"`
	Schema       basetypes.StringValue `tfsdk:"schema"`
	Volume       basetypes.StringValue `tfsdk:"volume"`
	VolumePath   basetypes.StringValue `tfsdk:"volume_path"`
	state        attr.ValueState
}

func (v DatabricksVolumesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 7)

	var val tftypes.Value
	var err error

	attrTypes["catalog"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["client_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["client_secret"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["host"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["schema"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["volume"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["volume_path"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 7)

		val, err = v.Catalog.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["catalog"] = val

		val, err = v.ClientId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["client_id"] = val

		val, err = v.ClientSecret.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["client_secret"] = val

		val, err = v.Host.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["host"] = val

		val, err = v.Schema.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["schema"] = val

		val, err = v.Volume.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["volume"] = val

		val, err = v.VolumePath.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["volume_path"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v DatabricksVolumesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v DatabricksVolumesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v DatabricksVolumesValue) String() string {
	return "DatabricksVolumesValue"
}

func (v DatabricksVolumesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"catalog":       basetypes.StringType{},
		"client_id":     basetypes.StringType{},
		"client_secret": basetypes.StringType{},
		"host":          basetypes.StringType{},
		"schema":        basetypes.StringType{},
		"volume":        basetypes.StringType{},
		"volume_path":   basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"catalog":       v.Catalog,
			"client_id":     v.ClientId,
			"client_secret": v.ClientSecret,
			"host":          v.Host,
			"schema":        v.Schema,
			"volume":        v.Volume,
			"volume_path":   v.VolumePath,
		})

	return objVal, diags
}

func (v DatabricksVolumesValue) Equal(o attr.Value) bool {
	other, ok := o.(DatabricksVolumesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Catalog.Equal(other.Catalog) {
		return false
	}

	if !v.ClientId.Equal(other.ClientId) {
		return false
	}

	if !v.ClientSecret.Equal(other.ClientSecret) {
		return false
	}

	if !v.Host.Equal(other.Host) {
		return false
	}

	if !v.Schema.Equal(other.Schema) {
		return false
	}

	if !v.Volume.Equal(other.Volume) {
		return false
	}

	if !v.VolumePath.Equal(other.VolumePath) {
		return false
	}

	return true
}

func (v DatabricksVolumesValue) Type(ctx context.Context) attr.Type {
	return DatabricksVolumesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v DatabricksVolumesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"catalog":       basetypes.StringType{},
		"client_id":     basetypes.StringType{},
		"client_secret": basetypes.StringType{},
		"host":          basetypes.StringType{},
		"schema":        basetypes.StringType{},
		"volume":        basetypes.StringType{},
		"volume_path":   basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = DropboxType{}

type DropboxType struct {
	basetypes.ObjectType
}

func (t DropboxType) Equal(o attr.Type) bool {
	other, ok := o.(DropboxType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t DropboxType) String() string {
	return "DropboxType"
}

func (t DropboxType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	recursiveAttribute, ok := attributes["recursive"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`recursive is missing from object`)

		return nil, diags
	}

	recursiveVal, ok := recursiveAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`recursive expected to be basetypes.BoolValue, was: %T`, recursiveAttribute))
	}

	remoteUrlAttribute, ok := attributes["remote_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remote_url is missing from object`)

		return nil, diags
	}

	remoteUrlVal, ok := remoteUrlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remote_url expected to be basetypes.StringValue, was: %T`, remoteUrlAttribute))
	}

	tokenAttribute, ok := attributes["token"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`token is missing from object`)

		return nil, diags
	}

	tokenVal, ok := tokenAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`token expected to be basetypes.StringValue, was: %T`, tokenAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return DropboxValue{
		Recursive: recursiveVal,
		RemoteUrl: remoteUrlVal,
		Token:     tokenVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewDropboxValueNull() DropboxValue {
	return DropboxValue{
		state: attr.ValueStateNull,
	}
}

func NewDropboxValueUnknown() DropboxValue {
	return DropboxValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDropboxValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (DropboxValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing DropboxValue Attribute Value",
				"While creating a DropboxValue value, a missing attribute value was detected. "+
					"A DropboxValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DropboxValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid DropboxValue Attribute Type",
				"While creating a DropboxValue value, an invalid attribute value was detected. "+
					"A DropboxValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DropboxValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("DropboxValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra DropboxValue Attribute Value",
				"While creating a DropboxValue value, an extra attribute value was detected. "+
					"A DropboxValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra DropboxValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDropboxValueUnknown(), diags
	}

	recursiveAttribute, ok := attributes["recursive"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`recursive is missing from object`)

		return NewDropboxValueUnknown(), diags
	}

	recursiveVal, ok := recursiveAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`recursive expected to be basetypes.BoolValue, was: %T`, recursiveAttribute))
	}

	remoteUrlAttribute, ok := attributes["remote_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remote_url is missing from object`)

		return NewDropboxValueUnknown(), diags
	}

	remoteUrlVal, ok := remoteUrlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remote_url expected to be basetypes.StringValue, was: %T`, remoteUrlAttribute))
	}

	tokenAttribute, ok := attributes["token"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`token is missing from object`)

		return NewDropboxValueUnknown(), diags
	}

	tokenVal, ok := tokenAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`token expected to be basetypes.StringValue, was: %T`, tokenAttribute))
	}

	if diags.HasError() {
		return NewDropboxValueUnknown(), diags
	}

	return DropboxValue{
		Recursive: recursiveVal,
		RemoteUrl: remoteUrlVal,
		Token:     tokenVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewDropboxValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) DropboxValue {
	object, diags := NewDropboxValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDropboxValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t DropboxType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDropboxValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDropboxValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDropboxValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDropboxValueMust(DropboxValue{}.AttributeTypes(ctx), attributes), nil
}

func (t DropboxType) ValueType(ctx context.Context) attr.Value {
	return DropboxValue{}
}

var _ basetypes.ObjectValuable = DropboxValue{}

type DropboxValue struct {
	Recursive basetypes.BoolValue   `tfsdk:"recursive"`
	RemoteUrl basetypes.StringValue `tfsdk:"remote_url"`
	Token     basetypes.StringValue `tfsdk:"token"`
	state     attr.ValueState
}

func (v DropboxValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["recursive"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["remote_url"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["token"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Recursive.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["recursive"] = val

		val, err = v.RemoteUrl.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["remote_url"] = val

		val, err = v.Token.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["token"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v DropboxValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v DropboxValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v DropboxValue) String() string {
	return "DropboxValue"
}

func (v DropboxValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"recursive":  basetypes.BoolType{},
		"remote_url": basetypes.StringType{},
		"token":      basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"recursive":  v.Recursive,
			"remote_url": v.RemoteUrl,
			"token":      v.Token,
		})

	return objVal, diags
}

func (v DropboxValue) Equal(o attr.Value) bool {
	other, ok := o.(DropboxValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Recursive.Equal(other.Recursive) {
		return false
	}

	if !v.RemoteUrl.Equal(other.RemoteUrl) {
		return false
	}

	if !v.Token.Equal(other.Token) {
		return false
	}

	return true
}

func (v DropboxValue) Type(ctx context.Context) attr.Type {
	return DropboxType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v DropboxValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"recursive":  basetypes.BoolType{},
		"remote_url": basetypes.StringType{},
		"token":      basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = ElasticsearchType{}

type ElasticsearchType struct {
	basetypes.ObjectType
}

func (t ElasticsearchType) Equal(o attr.Type) bool {
	other, ok := o.(ElasticsearchType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ElasticsearchType) String() string {
	return "ElasticsearchType"
}

func (t ElasticsearchType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	esApiKeyAttribute, ok := attributes["es_api_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`es_api_key is missing from object`)

		return nil, diags
	}

	esApiKeyVal, ok := esApiKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`es_api_key expected to be basetypes.StringValue, was: %T`, esApiKeyAttribute))
	}

	hostsAttribute, ok := attributes["hosts"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`hosts is missing from object`)

		return nil, diags
	}

	hostsVal, ok := hostsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`hosts expected to be basetypes.ListValue, was: %T`, hostsAttribute))
	}

	indexNameAttribute, ok := attributes["index_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`index_name is missing from object`)

		return nil, diags
	}

	indexNameVal, ok := indexNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`index_name expected to be basetypes.StringValue, was: %T`, indexNameAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ElasticsearchValue{
		EsApiKey:  esApiKeyVal,
		Hosts:     hostsVal,
		IndexName: indexNameVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewElasticsearchValueNull() ElasticsearchValue {
	return ElasticsearchValue{
		state: attr.ValueStateNull,
	}
}

func NewElasticsearchValueUnknown() ElasticsearchValue {
	return ElasticsearchValue{
		state: attr.ValueStateUnknown,
	}
}

func NewElasticsearchValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ElasticsearchValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ElasticsearchValue Attribute Value",
				"While creating a ElasticsearchValue value, a missing attribute value was detected. "+
					"A ElasticsearchValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ElasticsearchValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ElasticsearchValue Attribute Type",
				"While creating a ElasticsearchValue value, an invalid attribute value was detected. "+
					"A ElasticsearchValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ElasticsearchValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ElasticsearchValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ElasticsearchValue Attribute Value",
				"While creating a ElasticsearchValue value, an extra attribute value was detected. "+
					"A ElasticsearchValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ElasticsearchValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewElasticsearchValueUnknown(), diags
	}

	esApiKeyAttribute, ok := attributes["es_api_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`es_api_key is missing from object`)

		return NewElasticsearchValueUnknown(), diags
	}

	esApiKeyVal, ok := esApiKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`es_api_key expected to be basetypes.StringValue, was: %T`, esApiKeyAttribute))
	}

	hostsAttribute, ok := attributes["hosts"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`hosts is missing from object`)

		return NewElasticsearchValueUnknown(), diags
	}

	hostsVal, ok := hostsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`hosts expected to be basetypes.ListValue, was: %T`, hostsAttribute))
	}

	indexNameAttribute, ok := attributes["index_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`index_name is missing from object`)

		return NewElasticsearchValueUnknown(), diags
	}

	indexNameVal, ok := indexNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`index_name expected to be basetypes.StringValue, was: %T`, indexNameAttribute))
	}

	if diags.HasError() {
		return NewElasticsearchValueUnknown(), diags
	}

	return ElasticsearchValue{
		EsApiKey:  esApiKeyVal,
		Hosts:     hostsVal,
		IndexName: indexNameVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewElasticsearchValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ElasticsearchValue {
	object, diags := NewElasticsearchValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewElasticsearchValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ElasticsearchType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewElasticsearchValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewElasticsearchValueUnknown(), nil
	}

	if in.IsNull() {
		return NewElasticsearchValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewElasticsearchValueMust(ElasticsearchValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ElasticsearchType) ValueType(ctx context.Context) attr.Value {
	return ElasticsearchValue{}
}

var _ basetypes.ObjectValuable = ElasticsearchValue{}

type ElasticsearchValue struct {
	EsApiKey  basetypes.StringValue `tfsdk:"es_api_key"`
	Hosts     basetypes.ListValue   `tfsdk:"hosts"`
	IndexName basetypes.StringValue `tfsdk:"index_name"`
	state     attr.ValueState
}

func (v ElasticsearchValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["es_api_key"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["hosts"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["index_name"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.EsApiKey.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["es_api_key"] = val

		val, err = v.Hosts.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["hosts"] = val

		val, err = v.IndexName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["index_name"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ElasticsearchValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ElasticsearchValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ElasticsearchValue) String() string {
	return "ElasticsearchValue"
}

func (v ElasticsearchValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var hostsVal basetypes.ListValue
	switch {
	case v.Hosts.IsUnknown():
		hostsVal = types.ListUnknown(types.StringType)
	case v.Hosts.IsNull():
		hostsVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		hostsVal, d = types.ListValue(types.StringType, v.Hosts.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"es_api_key": basetypes.StringType{},
			"hosts": basetypes.ListType{
				ElemType: types.StringType,
			},
			"index_name": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"es_api_key": basetypes.StringType{},
		"hosts": basetypes.ListType{
			ElemType: types.StringType,
		},
		"index_name": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"es_api_key": v.EsApiKey,
			"hosts":      hostsVal,
			"index_name": v.IndexName,
		})

	return objVal, diags
}

func (v ElasticsearchValue) Equal(o attr.Value) bool {
	other, ok := o.(ElasticsearchValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.EsApiKey.Equal(other.EsApiKey) {
		return false
	}

	if !v.Hosts.Equal(other.Hosts) {
		return false
	}

	if !v.IndexName.Equal(other.IndexName) {
		return false
	}

	return true
}

func (v ElasticsearchValue) Type(ctx context.Context) attr.Type {
	return ElasticsearchType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ElasticsearchValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"es_api_key": basetypes.StringType{},
		"hosts": basetypes.ListType{
			ElemType: types.StringType,
		},
		"index_name": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = GcsType{}

type GcsType struct {
	basetypes.ObjectType
}

func (t GcsType) Equal(o attr.Type) bool {
	other, ok := o.(GcsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t GcsType) String() string {
	return "GcsType"
}

func (t GcsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	recursiveAttribute, ok := attributes["recursive"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`recursive is missing from object`)

		return nil, diags
	}

	recursiveVal, ok := recursiveAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`recursive expected to be basetypes.BoolValue, was: %T`, recursiveAttribute))
	}

	remoteUrlAttribute, ok := attributes["remote_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remote_url is missing from object`)

		return nil, diags
	}

	remoteUrlVal, ok := remoteUrlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remote_url expected to be basetypes.StringValue, was: %T`, remoteUrlAttribute))
	}

	serviceAccountKeyAttribute, ok := attributes["service_account_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`service_account_key is missing from object`)

		return nil, diags
	}

	serviceAccountKeyVal, ok := serviceAccountKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`service_account_key expected to be basetypes.StringValue, was: %T`, serviceAccountKeyAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return GcsValue{
		Recursive:         recursiveVal,
		RemoteUrl:         remoteUrlVal,
		ServiceAccountKey: serviceAccountKeyVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewGcsValueNull() GcsValue {
	return GcsValue{
		state: attr.ValueStateNull,
	}
}

func NewGcsValueUnknown() GcsValue {
	return GcsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewGcsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (GcsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing GcsValue Attribute Value",
				"While creating a GcsValue value, a missing attribute value was detected. "+
					"A GcsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("GcsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid GcsValue Attribute Type",
				"While creating a GcsValue value, an invalid attribute value was detected. "+
					"A GcsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("GcsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("GcsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra GcsValue Attribute Value",
				"While creating a GcsValue value, an extra attribute value was detected. "+
					"A GcsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra GcsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewGcsValueUnknown(), diags
	}

	recursiveAttribute, ok := attributes["recursive"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`recursive is missing from object`)

		return NewGcsValueUnknown(), diags
	}

	recursiveVal, ok := recursiveAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`recursive expected to be basetypes.BoolValue, was: %T`, recursiveAttribute))
	}

	remoteUrlAttribute, ok := attributes["remote_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remote_url is missing from object`)

		return NewGcsValueUnknown(), diags
	}

	remoteUrlVal, ok := remoteUrlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remote_url expected to be basetypes.StringValue, was: %T`, remoteUrlAttribute))
	}

	serviceAccountKeyAttribute, ok := attributes["service_account_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`service_account_key is missing from object`)

		return NewGcsValueUnknown(), diags
	}

	serviceAccountKeyVal, ok := serviceAccountKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`service_account_key expected to be basetypes.StringValue, was: %T`, serviceAccountKeyAttribute))
	}

	if diags.HasError() {
		return NewGcsValueUnknown(), diags
	}

	return GcsValue{
		Recursive:         recursiveVal,
		RemoteUrl:         remoteUrlVal,
		ServiceAccountKey: serviceAccountKeyVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewGcsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) GcsValue {
	object, diags := NewGcsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewGcsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t GcsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewGcsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewGcsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewGcsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewGcsValueMust(GcsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t GcsType) ValueType(ctx context.Context) attr.Value {
	return GcsValue{}
}

var _ basetypes.ObjectValuable = GcsValue{}

type GcsValue struct {
	Recursive         basetypes.BoolValue   `tfsdk:"recursive"`
	RemoteUrl         basetypes.StringValue `tfsdk:"remote_url"`
	ServiceAccountKey basetypes.StringValue `tfsdk:"service_account_key"`
	state             attr.ValueState
}

func (v GcsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["recursive"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["remote_url"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["service_account_key"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Recursive.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["recursive"] = val

		val, err = v.RemoteUrl.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["remote_url"] = val

		val, err = v.ServiceAccountKey.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["service_account_key"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v GcsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v GcsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v GcsValue) String() string {
	return "GcsValue"
}

func (v GcsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"recursive":           basetypes.BoolType{},
		"remote_url":          basetypes.StringType{},
		"service_account_key": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"recursive":           v.Recursive,
			"remote_url":          v.RemoteUrl,
			"service_account_key": v.ServiceAccountKey,
		})

	return objVal, diags
}

func (v GcsValue) Equal(o attr.Value) bool {
	other, ok := o.(GcsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Recursive.Equal(other.Recursive) {
		return false
	}

	if !v.RemoteUrl.Equal(other.RemoteUrl) {
		return false
	}

	if !v.ServiceAccountKey.Equal(other.ServiceAccountKey) {
		return false
	}

	return true
}

func (v GcsValue) Type(ctx context.Context) attr.Type {
	return GcsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v GcsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"recursive":           basetypes.BoolType{},
		"remote_url":          basetypes.StringType{},
		"service_account_key": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = GoogleDriveType{}

type GoogleDriveType struct {
	basetypes.ObjectType
}

func (t GoogleDriveType) Equal(o attr.Type) bool {
	other, ok := o.(GoogleDriveType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t GoogleDriveType) String() string {
	return "GoogleDriveType"
}

func (t GoogleDriveType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	driveIdAttribute, ok := attributes["drive_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`drive_id is missing from object`)

		return nil, diags
	}

	driveIdVal, ok := driveIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`drive_id expected to be basetypes.StringValue, was: %T`, driveIdAttribute))
	}

	extensionsAttribute, ok := attributes["extensions"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`extensions is missing from object`)

		return nil, diags
	}

	extensionsVal, ok := extensionsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`extensions expected to be basetypes.ListValue, was: %T`, extensionsAttribute))
	}

	recursiveAttribute, ok := attributes["recursive"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`recursive is missing from object`)

		return nil, diags
	}

	recursiveVal, ok := recursiveAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`recursive expected to be basetypes.BoolValue, was: %T`, recursiveAttribute))
	}

	serviceAccountKeyAttribute, ok := attributes["service_account_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`service_account_key is missing from object`)

		return nil, diags
	}

	serviceAccountKeyVal, ok := serviceAccountKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`service_account_key expected to be basetypes.StringValue, was: %T`, serviceAccountKeyAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return GoogleDriveValue{
		DriveId:           driveIdVal,
		Extensions:        extensionsVal,
		Recursive:         recursiveVal,
		ServiceAccountKey: serviceAccountKeyVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewGoogleDriveValueNull() GoogleDriveValue {
	return GoogleDriveValue{
		state: attr.ValueStateNull,
	}
}

func NewGoogleDriveValueUnknown() GoogleDriveValue {
	return GoogleDriveValue{
		state: attr.ValueStateUnknown,
	}
}

func NewGoogleDriveValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (GoogleDriveValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing GoogleDriveValue Attribute Value",
				"While creating a GoogleDriveValue value, a missing attribute value was detected. "+
					"A GoogleDriveValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("GoogleDriveValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid GoogleDriveValue Attribute Type",
				"While creating a GoogleDriveValue value, an invalid attribute value was detected. "+
					"A GoogleDriveValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("GoogleDriveValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("GoogleDriveValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra GoogleDriveValue Attribute Value",
				"While creating a GoogleDriveValue value, an extra attribute value was detected. "+
					"A GoogleDriveValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra GoogleDriveValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewGoogleDriveValueUnknown(), diags
	}

	driveIdAttribute, ok := attributes["drive_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`drive_id is missing from object`)

		return NewGoogleDriveValueUnknown(), diags
	}

	driveIdVal, ok := driveIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`drive_id expected to be basetypes.StringValue, was: %T`, driveIdAttribute))
	}

	extensionsAttribute, ok := attributes["extensions"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`extensions is missing from object`)

		return NewGoogleDriveValueUnknown(), diags
	}

	extensionsVal, ok := extensionsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`extensions expected to be basetypes.ListValue, was: %T`, extensionsAttribute))
	}

	recursiveAttribute, ok := attributes["recursive"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`recursive is missing from object`)

		return NewGoogleDriveValueUnknown(), diags
	}

	recursiveVal, ok := recursiveAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`recursive expected to be basetypes.BoolValue, was: %T`, recursiveAttribute))
	}

	serviceAccountKeyAttribute, ok := attributes["service_account_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`service_account_key is missing from object`)

		return NewGoogleDriveValueUnknown(), diags
	}

	serviceAccountKeyVal, ok := serviceAccountKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`service_account_key expected to be basetypes.StringValue, was: %T`, serviceAccountKeyAttribute))
	}

	if diags.HasError() {
		return NewGoogleDriveValueUnknown(), diags
	}

	return GoogleDriveValue{
		DriveId:           driveIdVal,
		Extensions:        extensionsVal,
		Recursive:         recursiveVal,
		ServiceAccountKey: serviceAccountKeyVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewGoogleDriveValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) GoogleDriveValue {
	object, diags := NewGoogleDriveValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewGoogleDriveValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t GoogleDriveType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewGoogleDriveValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewGoogleDriveValueUnknown(), nil
	}

	if in.IsNull() {
		return NewGoogleDriveValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewGoogleDriveValueMust(GoogleDriveValue{}.AttributeTypes(ctx), attributes), nil
}

func (t GoogleDriveType) ValueType(ctx context.Context) attr.Value {
	return GoogleDriveValue{}
}

var _ basetypes.ObjectValuable = GoogleDriveValue{}

type GoogleDriveValue struct {
	DriveId           basetypes.StringValue `tfsdk:"drive_id"`
	Extensions        basetypes.ListValue   `tfsdk:"extensions"`
	Recursive         basetypes.BoolValue   `tfsdk:"recursive"`
	ServiceAccountKey basetypes.StringValue `tfsdk:"service_account_key"`
	state             attr.ValueState
}

func (v GoogleDriveValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["drive_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["extensions"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["recursive"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["service_account_key"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.DriveId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["drive_id"] = val

		val, err = v.Extensions.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["extensions"] = val

		val, err = v.Recursive.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["recursive"] = val

		val, err = v.ServiceAccountKey.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["service_account_key"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v GoogleDriveValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v GoogleDriveValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v GoogleDriveValue) String() string {
	return "GoogleDriveValue"
}

func (v GoogleDriveValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var extensionsVal basetypes.ListValue
	switch {
	case v.Extensions.IsUnknown():
		extensionsVal = types.ListUnknown(types.StringType)
	case v.Extensions.IsNull():
		extensionsVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		extensionsVal, d = types.ListValue(types.StringType, v.Extensions.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"drive_id": basetypes.StringType{},
			"extensions": basetypes.ListType{
				ElemType: types.StringType,
			},
			"recursive":           basetypes.BoolType{},
			"service_account_key": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"drive_id": basetypes.StringType{},
		"extensions": basetypes.ListType{
			ElemType: types.StringType,
		},
		"recursive":           basetypes.BoolType{},
		"service_account_key": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"drive_id":            v.DriveId,
			"extensions":          extensionsVal,
			"recursive":           v.Recursive,
			"service_account_key": v.ServiceAccountKey,
		})

	return objVal, diags
}

func (v GoogleDriveValue) Equal(o attr.Value) bool {
	other, ok := o.(GoogleDriveValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.DriveId.Equal(other.DriveId) {
		return false
	}

	if !v.Extensions.Equal(other.Extensions) {
		return false
	}

	if !v.Recursive.Equal(other.Recursive) {
		return false
	}

	if !v.ServiceAccountKey.Equal(other.ServiceAccountKey) {
		return false
	}

	return true
}

func (v GoogleDriveValue) Type(ctx context.Context) attr.Type {
	return GoogleDriveType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v GoogleDriveValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"drive_id": basetypes.StringType{},
		"extensions": basetypes.ListType{
			ElemType: types.StringType,
		},
		"recursive":           basetypes.BoolType{},
		"service_account_key": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = JiraType{}

type JiraType struct {
	basetypes.ObjectType
}

func (t JiraType) Equal(o attr.Type) bool {
	other, ok := o.(JiraType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t JiraType) String() string {
	return "JiraType"
}

func (t JiraType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	boardsAttribute, ok := attributes["boards"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`boards is missing from object`)

		return nil, diags
	}

	boardsVal, ok := boardsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`boards expected to be basetypes.ListValue, was: %T`, boardsAttribute))
	}

	cloudAttribute, ok := attributes["cloud"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cloud is missing from object`)

		return nil, diags
	}

	cloudVal, ok := cloudAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cloud expected to be basetypes.BoolValue, was: %T`, cloudAttribute))
	}

	downloadAttachmentsAttribute, ok := attributes["download_attachments"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`download_attachments is missing from object`)

		return nil, diags
	}

	downloadAttachmentsVal, ok := downloadAttachmentsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`download_attachments expected to be basetypes.BoolValue, was: %T`, downloadAttachmentsAttribute))
	}

	issuesAttribute, ok := attributes["issues"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`issues is missing from object`)

		return nil, diags
	}

	issuesVal, ok := issuesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`issues expected to be basetypes.ListValue, was: %T`, issuesAttribute))
	}

	passwordAttribute, ok := attributes["password"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`password is missing from object`)

		return nil, diags
	}

	passwordVal, ok := passwordAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`password expected to be basetypes.StringValue, was: %T`, passwordAttribute))
	}

	projectsAttribute, ok := attributes["projects"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`projects is missing from object`)

		return nil, diags
	}

	projectsVal, ok := projectsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`projects expected to be basetypes.ListValue, was: %T`, projectsAttribute))
	}

	statusFiltersAttribute, ok := attributes["status_filters"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status_filters is missing from object`)

		return nil, diags
	}

	statusFiltersVal, ok := statusFiltersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status_filters expected to be basetypes.ListValue, was: %T`, statusFiltersAttribute))
	}

	tokenAttribute, ok := attributes["token"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`token is missing from object`)

		return nil, diags
	}

	tokenVal, ok := tokenAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`token expected to be basetypes.StringValue, was: %T`, tokenAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return nil, diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	usernameAttribute, ok := attributes["username"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`username is missing from object`)

		return nil, diags
	}

	usernameVal, ok := usernameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`username expected to be basetypes.StringValue, was: %T`, usernameAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return JiraValue{
		Boards:              boardsVal,
		Cloud:               cloudVal,
		DownloadAttachments: downloadAttachmentsVal,
		Issues:              issuesVal,
		Password:            passwordVal,
		Projects:            projectsVal,
		StatusFilters:       statusFiltersVal,
		Token:               tokenVal,
		Url:                 urlVal,
		Username:            usernameVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewJiraValueNull() JiraValue {
	return JiraValue{
		state: attr.ValueStateNull,
	}
}

func NewJiraValueUnknown() JiraValue {
	return JiraValue{
		state: attr.ValueStateUnknown,
	}
}

func NewJiraValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (JiraValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing JiraValue Attribute Value",
				"While creating a JiraValue value, a missing attribute value was detected. "+
					"A JiraValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("JiraValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid JiraValue Attribute Type",
				"While creating a JiraValue value, an invalid attribute value was detected. "+
					"A JiraValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("JiraValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("JiraValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra JiraValue Attribute Value",
				"While creating a JiraValue value, an extra attribute value was detected. "+
					"A JiraValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra JiraValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewJiraValueUnknown(), diags
	}

	boardsAttribute, ok := attributes["boards"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`boards is missing from object`)

		return NewJiraValueUnknown(), diags
	}

	boardsVal, ok := boardsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`boards expected to be basetypes.ListValue, was: %T`, boardsAttribute))
	}

	cloudAttribute, ok := attributes["cloud"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cloud is missing from object`)

		return NewJiraValueUnknown(), diags
	}

	cloudVal, ok := cloudAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cloud expected to be basetypes.BoolValue, was: %T`, cloudAttribute))
	}

	downloadAttachmentsAttribute, ok := attributes["download_attachments"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`download_attachments is missing from object`)

		return NewJiraValueUnknown(), diags
	}

	downloadAttachmentsVal, ok := downloadAttachmentsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`download_attachments expected to be basetypes.BoolValue, was: %T`, downloadAttachmentsAttribute))
	}

	issuesAttribute, ok := attributes["issues"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`issues is missing from object`)

		return NewJiraValueUnknown(), diags
	}

	issuesVal, ok := issuesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`issues expected to be basetypes.ListValue, was: %T`, issuesAttribute))
	}

	passwordAttribute, ok := attributes["password"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`password is missing from object`)

		return NewJiraValueUnknown(), diags
	}

	passwordVal, ok := passwordAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`password expected to be basetypes.StringValue, was: %T`, passwordAttribute))
	}

	projectsAttribute, ok := attributes["projects"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`projects is missing from object`)

		return NewJiraValueUnknown(), diags
	}

	projectsVal, ok := projectsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`projects expected to be basetypes.ListValue, was: %T`, projectsAttribute))
	}

	statusFiltersAttribute, ok := attributes["status_filters"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status_filters is missing from object`)

		return NewJiraValueUnknown(), diags
	}

	statusFiltersVal, ok := statusFiltersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status_filters expected to be basetypes.ListValue, was: %T`, statusFiltersAttribute))
	}

	tokenAttribute, ok := attributes["token"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`token is missing from object`)

		return NewJiraValueUnknown(), diags
	}

	tokenVal, ok := tokenAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`token expected to be basetypes.StringValue, was: %T`, tokenAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return NewJiraValueUnknown(), diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	usernameAttribute, ok := attributes["username"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`username is missing from object`)

		return NewJiraValueUnknown(), diags
	}

	usernameVal, ok := usernameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`username expected to be basetypes.StringValue, was: %T`, usernameAttribute))
	}

	if diags.HasError() {
		return NewJiraValueUnknown(), diags
	}

	return JiraValue{
		Boards:              boardsVal,
		Cloud:               cloudVal,
		DownloadAttachments: downloadAttachmentsVal,
		Issues:              issuesVal,
		Password:            passwordVal,
		Projects:            projectsVal,
		StatusFilters:       statusFiltersVal,
		Token:               tokenVal,
		Url:                 urlVal,
		Username:            usernameVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewJiraValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) JiraValue {
	object, diags := NewJiraValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewJiraValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t JiraType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewJiraValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewJiraValueUnknown(), nil
	}

	if in.IsNull() {
		return NewJiraValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewJiraValueMust(JiraValue{}.AttributeTypes(ctx), attributes), nil
}

func (t JiraType) ValueType(ctx context.Context) attr.Value {
	return JiraValue{}
}

var _ basetypes.ObjectValuable = JiraValue{}

type JiraValue struct {
	Boards              basetypes.ListValue   `tfsdk:"boards"`
	Cloud               basetypes.BoolValue   `tfsdk:"cloud"`
	DownloadAttachments basetypes.BoolValue   `tfsdk:"download_attachments"`
	Issues              basetypes.ListValue   `tfsdk:"issues"`
	Password            basetypes.StringValue `tfsdk:"password"`
	Projects            basetypes.ListValue   `tfsdk:"projects"`
	StatusFilters       basetypes.ListValue   `tfsdk:"status_filters"`
	Token               basetypes.StringValue `tfsdk:"token"`
	Url                 basetypes.StringValue `tfsdk:"url"`
	Username            basetypes.StringValue `tfsdk:"username"`
	state               attr.ValueState
}

func (v JiraValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 10)

	var val tftypes.Value
	var err error

	attrTypes["boards"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["cloud"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["download_attachments"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["issues"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["password"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["projects"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["status_filters"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["token"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["url"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["username"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 10)

		val, err = v.Boards.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["boards"] = val

		val, err = v.Cloud.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cloud"] = val

		val, err = v.DownloadAttachments.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["download_attachments"] = val

		val, err = v.Issues.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["issues"] = val

		val, err = v.Password.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["password"] = val

		val, err = v.Projects.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["projects"] = val

		val, err = v.StatusFilters.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["status_filters"] = val

		val, err = v.Token.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["token"] = val

		val, err = v.Url.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["url"] = val

		val, err = v.Username.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["username"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v JiraValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v JiraValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v JiraValue) String() string {
	return "JiraValue"
}

func (v JiraValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var boardsVal basetypes.ListValue
	switch {
	case v.Boards.IsUnknown():
		boardsVal = types.ListUnknown(types.StringType)
	case v.Boards.IsNull():
		boardsVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		boardsVal, d = types.ListValue(types.StringType, v.Boards.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"boards": basetypes.ListType{
				ElemType: types.StringType,
			},
			"cloud":                basetypes.BoolType{},
			"download_attachments": basetypes.BoolType{},
			"issues": basetypes.ListType{
				ElemType: types.StringType,
			},
			"password": basetypes.StringType{},
			"projects": basetypes.ListType{
				ElemType: types.StringType,
			},
			"status_filters": basetypes.ListType{
				ElemType: types.StringType,
			},
			"token":    basetypes.StringType{},
			"url":      basetypes.StringType{},
			"username": basetypes.StringType{},
		}), diags
	}

	var issuesVal basetypes.ListValue
	switch {
	case v.Issues.IsUnknown():
		issuesVal = types.ListUnknown(types.StringType)
	case v.Issues.IsNull():
		issuesVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		issuesVal, d = types.ListValue(types.StringType, v.Issues.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"boards": basetypes.ListType{
				ElemType: types.StringType,
			},
			"cloud":                basetypes.BoolType{},
			"download_attachments": basetypes.BoolType{},
			"issues": basetypes.ListType{
				ElemType: types.StringType,
			},
			"password": basetypes.StringType{},
			"projects": basetypes.ListType{
				ElemType: types.StringType,
			},
			"status_filters": basetypes.ListType{
				ElemType: types.StringType,
			},
			"token":    basetypes.StringType{},
			"url":      basetypes.StringType{},
			"username": basetypes.StringType{},
		}), diags
	}

	var projectsVal basetypes.ListValue
	switch {
	case v.Projects.IsUnknown():
		projectsVal = types.ListUnknown(types.StringType)
	case v.Projects.IsNull():
		projectsVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		projectsVal, d = types.ListValue(types.StringType, v.Projects.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"boards": basetypes.ListType{
				ElemType: types.StringType,
			},
			"cloud":                basetypes.BoolType{},
			"download_attachments": basetypes.BoolType{},
			"issues": basetypes.ListType{
				ElemType: types.StringType,
			},
			"password": basetypes.StringType{},
			"projects": basetypes.ListType{
				ElemType: types.StringType,
			},
			"status_filters": basetypes.ListType{
				ElemType: types.StringType,
			},
			"token":    basetypes.StringType{},
			"url":      basetypes.StringType{},
			"username": basetypes.StringType{},
		}), diags
	}

	var statusFiltersVal basetypes.ListValue
	switch {
	case v.StatusFilters.IsUnknown():
		statusFiltersVal = types.ListUnknown(types.StringType)
	case v.StatusFilters.IsNull():
		statusFiltersVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		statusFiltersVal, d = types.ListValue(types.StringType, v.StatusFilters.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"boards": basetypes.ListType{
				ElemType: types.StringType,
			},
			"cloud":                basetypes.BoolType{},
			"download_attachments": basetypes.BoolType{},
			"issues": basetypes.ListType{
				ElemType: types.StringType,
			},
			"password": basetypes.StringType{},
			"projects": basetypes.ListType{
				ElemType: types.StringType,
			},
			"status_filters": basetypes.ListType{
				ElemType: types.StringType,
			},
			"token":    basetypes.StringType{},
			"url":      basetypes.StringType{},
			"username": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"boards": basetypes.ListType{
			ElemType: types.StringType,
		},
		"cloud":                basetypes.BoolType{},
		"download_attachments": basetypes.BoolType{},
		"issues": basetypes.ListType{
			ElemType: types.StringType,
		},
		"password": basetypes.StringType{},
		"projects": basetypes.ListType{
			ElemType: types.StringType,
		},
		"status_filters": basetypes.ListType{
			ElemType: types.StringType,
		},
		"token":    basetypes.StringType{},
		"url":      basetypes.StringType{},
		"username": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"boards":               boardsVal,
			"cloud":                v.Cloud,
			"download_attachments": v.DownloadAttachments,
			"issues":               issuesVal,
			"password":             v.Password,
			"projects":             projectsVal,
			"status_filters":       statusFiltersVal,
			"token":                v.Token,
			"url":                  v.Url,
			"username":             v.Username,
		})

	return objVal, diags
}

func (v JiraValue) Equal(o attr.Value) bool {
	other, ok := o.(JiraValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Boards.Equal(other.Boards) {
		return false
	}

	if !v.Cloud.Equal(other.Cloud) {
		return false
	}

	if !v.DownloadAttachments.Equal(other.DownloadAttachments) {
		return false
	}

	if !v.Issues.Equal(other.Issues) {
		return false
	}

	if !v.Password.Equal(other.Password) {
		return false
	}

	if !v.Projects.Equal(other.Projects) {
		return false
	}

	if !v.StatusFilters.Equal(other.StatusFilters) {
		return false
	}

	if !v.Token.Equal(other.Token) {
		return false
	}

	if !v.Url.Equal(other.Url) {
		return false
	}

	if !v.Username.Equal(other.Username) {
		return false
	}

	return true
}

func (v JiraValue) Type(ctx context.Context) attr.Type {
	return JiraType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v JiraValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"boards": basetypes.ListType{
			ElemType: types.StringType,
		},
		"cloud":                basetypes.BoolType{},
		"download_attachments": basetypes.BoolType{},
		"issues": basetypes.ListType{
			ElemType: types.StringType,
		},
		"password": basetypes.StringType{},
		"projects": basetypes.ListType{
			ElemType: types.StringType,
		},
		"status_filters": basetypes.ListType{
			ElemType: types.StringType,
		},
		"token":    basetypes.StringType{},
		"url":      basetypes.StringType{},
		"username": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = KafkaCloudType{}

type KafkaCloudType struct {
	basetypes.ObjectType
}

func (t KafkaCloudType) Equal(o attr.Type) bool {
	other, ok := o.(KafkaCloudType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t KafkaCloudType) String() string {
	return "KafkaCloudType"
}

func (t KafkaCloudType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	bootstrapServersAttribute, ok := attributes["bootstrap_servers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bootstrap_servers is missing from object`)

		return nil, diags
	}

	bootstrapServersVal, ok := bootstrapServersAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bootstrap_servers expected to be basetypes.StringValue, was: %T`, bootstrapServersAttribute))
	}

	groupIdAttribute, ok := attributes["group_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`group_id is missing from object`)

		return nil, diags
	}

	groupIdVal, ok := groupIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`group_id expected to be basetypes.StringValue, was: %T`, groupIdAttribute))
	}

	kafkaApiKeyAttribute, ok := attributes["kafka_api_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`kafka_api_key is missing from object`)

		return nil, diags
	}

	kafkaApiKeyVal, ok := kafkaApiKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`kafka_api_key expected to be basetypes.StringValue, was: %T`, kafkaApiKeyAttribute))
	}

	numMessagesToConsumeAttribute, ok := attributes["num_messages_to_consume"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`num_messages_to_consume is missing from object`)

		return nil, diags
	}

	numMessagesToConsumeVal, ok := numMessagesToConsumeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`num_messages_to_consume expected to be basetypes.Int64Value, was: %T`, numMessagesToConsumeAttribute))
	}

	portAttribute, ok := attributes["port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port is missing from object`)

		return nil, diags
	}

	portVal, ok := portAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port expected to be basetypes.Int64Value, was: %T`, portAttribute))
	}

	secretAttribute, ok := attributes["secret"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`secret is missing from object`)

		return nil, diags
	}

	secretVal, ok := secretAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`secret expected to be basetypes.StringValue, was: %T`, secretAttribute))
	}

	topicAttribute, ok := attributes["topic"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`topic is missing from object`)

		return nil, diags
	}

	topicVal, ok := topicAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`topic expected to be basetypes.StringValue, was: %T`, topicAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return KafkaCloudValue{
		BootstrapServers:     bootstrapServersVal,
		GroupId:              groupIdVal,
		KafkaApiKey:          kafkaApiKeyVal,
		NumMessagesToConsume: numMessagesToConsumeVal,
		Port:                 portVal,
		Secret:               secretVal,
		Topic:                topicVal,
		state:                attr.ValueStateKnown,
	}, diags
}

func NewKafkaCloudValueNull() KafkaCloudValue {
	return KafkaCloudValue{
		state: attr.ValueStateNull,
	}
}

func NewKafkaCloudValueUnknown() KafkaCloudValue {
	return KafkaCloudValue{
		state: attr.ValueStateUnknown,
	}
}

func NewKafkaCloudValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (KafkaCloudValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing KafkaCloudValue Attribute Value",
				"While creating a KafkaCloudValue value, a missing attribute value was detected. "+
					"A KafkaCloudValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("KafkaCloudValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid KafkaCloudValue Attribute Type",
				"While creating a KafkaCloudValue value, an invalid attribute value was detected. "+
					"A KafkaCloudValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("KafkaCloudValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("KafkaCloudValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra KafkaCloudValue Attribute Value",
				"While creating a KafkaCloudValue value, an extra attribute value was detected. "+
					"A KafkaCloudValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra KafkaCloudValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewKafkaCloudValueUnknown(), diags
	}

	bootstrapServersAttribute, ok := attributes["bootstrap_servers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bootstrap_servers is missing from object`)

		return NewKafkaCloudValueUnknown(), diags
	}

	bootstrapServersVal, ok := bootstrapServersAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bootstrap_servers expected to be basetypes.StringValue, was: %T`, bootstrapServersAttribute))
	}

	groupIdAttribute, ok := attributes["group_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`group_id is missing from object`)

		return NewKafkaCloudValueUnknown(), diags
	}

	groupIdVal, ok := groupIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`group_id expected to be basetypes.StringValue, was: %T`, groupIdAttribute))
	}

	kafkaApiKeyAttribute, ok := attributes["kafka_api_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`kafka_api_key is missing from object`)

		return NewKafkaCloudValueUnknown(), diags
	}

	kafkaApiKeyVal, ok := kafkaApiKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`kafka_api_key expected to be basetypes.StringValue, was: %T`, kafkaApiKeyAttribute))
	}

	numMessagesToConsumeAttribute, ok := attributes["num_messages_to_consume"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`num_messages_to_consume is missing from object`)

		return NewKafkaCloudValueUnknown(), diags
	}

	numMessagesToConsumeVal, ok := numMessagesToConsumeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`num_messages_to_consume expected to be basetypes.Int64Value, was: %T`, numMessagesToConsumeAttribute))
	}

	portAttribute, ok := attributes["port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port is missing from object`)

		return NewKafkaCloudValueUnknown(), diags
	}

	portVal, ok := portAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port expected to be basetypes.Int64Value, was: %T`, portAttribute))
	}

	secretAttribute, ok := attributes["secret"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`secret is missing from object`)

		return NewKafkaCloudValueUnknown(), diags
	}

	secretVal, ok := secretAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`secret expected to be basetypes.StringValue, was: %T`, secretAttribute))
	}

	topicAttribute, ok := attributes["topic"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`topic is missing from object`)

		return NewKafkaCloudValueUnknown(), diags
	}

	topicVal, ok := topicAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`topic expected to be basetypes.StringValue, was: %T`, topicAttribute))
	}

	if diags.HasError() {
		return NewKafkaCloudValueUnknown(), diags
	}

	return KafkaCloudValue{
		BootstrapServers:     bootstrapServersVal,
		GroupId:              groupIdVal,
		KafkaApiKey:          kafkaApiKeyVal,
		NumMessagesToConsume: numMessagesToConsumeVal,
		Port:                 portVal,
		Secret:               secretVal,
		Topic:                topicVal,
		state:                attr.ValueStateKnown,
	}, diags
}

func NewKafkaCloudValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) KafkaCloudValue {
	object, diags := NewKafkaCloudValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewKafkaCloudValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t KafkaCloudType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewKafkaCloudValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewKafkaCloudValueUnknown(), nil
	}

	if in.IsNull() {
		return NewKafkaCloudValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewKafkaCloudValueMust(KafkaCloudValue{}.AttributeTypes(ctx), attributes), nil
}

func (t KafkaCloudType) ValueType(ctx context.Context) attr.Value {
	return KafkaCloudValue{}
}

var _ basetypes.ObjectValuable = KafkaCloudValue{}

type KafkaCloudValue struct {
	BootstrapServers     basetypes.StringValue `tfsdk:"bootstrap_servers"`
	GroupId              basetypes.StringValue `tfsdk:"group_id"`
	KafkaApiKey          basetypes.StringValue `tfsdk:"kafka_api_key"`
	NumMessagesToConsume basetypes.Int64Value  `tfsdk:"num_messages_to_consume"`
	Port                 basetypes.Int64Value  `tfsdk:"port"`
	Secret               basetypes.StringValue `tfsdk:"secret"`
	Topic                basetypes.StringValue `tfsdk:"topic"`
	state                attr.ValueState
}

func (v KafkaCloudValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 7)

	var val tftypes.Value
	var err error

	attrTypes["bootstrap_servers"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["group_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["kafka_api_key"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["num_messages_to_consume"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["port"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["secret"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["topic"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 7)

		val, err = v.BootstrapServers.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bootstrap_servers"] = val

		val, err = v.GroupId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["group_id"] = val

		val, err = v.KafkaApiKey.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["kafka_api_key"] = val

		val, err = v.NumMessagesToConsume.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["num_messages_to_consume"] = val

		val, err = v.Port.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port"] = val

		val, err = v.Secret.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["secret"] = val

		val, err = v.Topic.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["topic"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v KafkaCloudValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v KafkaCloudValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v KafkaCloudValue) String() string {
	return "KafkaCloudValue"
}

func (v KafkaCloudValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"bootstrap_servers":       basetypes.StringType{},
		"group_id":                basetypes.StringType{},
		"kafka_api_key":           basetypes.StringType{},
		"num_messages_to_consume": basetypes.Int64Type{},
		"port":                    basetypes.Int64Type{},
		"secret":                  basetypes.StringType{},
		"topic":                   basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"bootstrap_servers":       v.BootstrapServers,
			"group_id":                v.GroupId,
			"kafka_api_key":           v.KafkaApiKey,
			"num_messages_to_consume": v.NumMessagesToConsume,
			"port":                    v.Port,
			"secret":                  v.Secret,
			"topic":                   v.Topic,
		})

	return objVal, diags
}

func (v KafkaCloudValue) Equal(o attr.Value) bool {
	other, ok := o.(KafkaCloudValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.BootstrapServers.Equal(other.BootstrapServers) {
		return false
	}

	if !v.GroupId.Equal(other.GroupId) {
		return false
	}

	if !v.KafkaApiKey.Equal(other.KafkaApiKey) {
		return false
	}

	if !v.NumMessagesToConsume.Equal(other.NumMessagesToConsume) {
		return false
	}

	if !v.Port.Equal(other.Port) {
		return false
	}

	if !v.Secret.Equal(other.Secret) {
		return false
	}

	if !v.Topic.Equal(other.Topic) {
		return false
	}

	return true
}

func (v KafkaCloudValue) Type(ctx context.Context) attr.Type {
	return KafkaCloudType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v KafkaCloudValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"bootstrap_servers":       basetypes.StringType{},
		"group_id":                basetypes.StringType{},
		"kafka_api_key":           basetypes.StringType{},
		"num_messages_to_consume": basetypes.Int64Type{},
		"port":                    basetypes.Int64Type{},
		"secret":                  basetypes.StringType{},
		"topic":                   basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = MongodbType{}

type MongodbType struct {
	basetypes.ObjectType
}

func (t MongodbType) Equal(o attr.Type) bool {
	other, ok := o.(MongodbType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t MongodbType) String() string {
	return "MongodbType"
}

func (t MongodbType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	collectionAttribute, ok := attributes["collection"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`collection is missing from object`)

		return nil, diags
	}

	collectionVal, ok := collectionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`collection expected to be basetypes.StringValue, was: %T`, collectionAttribute))
	}

	databaseAttribute, ok := attributes["database"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`database is missing from object`)

		return nil, diags
	}

	databaseVal, ok := databaseAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`database expected to be basetypes.StringValue, was: %T`, databaseAttribute))
	}

	uriAttribute, ok := attributes["uri"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uri is missing from object`)

		return nil, diags
	}

	uriVal, ok := uriAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uri expected to be basetypes.StringValue, was: %T`, uriAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return MongodbValue{
		Collection: collectionVal,
		Database:   databaseVal,
		Uri:        uriVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewMongodbValueNull() MongodbValue {
	return MongodbValue{
		state: attr.ValueStateNull,
	}
}

func NewMongodbValueUnknown() MongodbValue {
	return MongodbValue{
		state: attr.ValueStateUnknown,
	}
}

func NewMongodbValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (MongodbValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing MongodbValue Attribute Value",
				"While creating a MongodbValue value, a missing attribute value was detected. "+
					"A MongodbValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MongodbValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid MongodbValue Attribute Type",
				"While creating a MongodbValue value, an invalid attribute value was detected. "+
					"A MongodbValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MongodbValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("MongodbValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra MongodbValue Attribute Value",
				"While creating a MongodbValue value, an extra attribute value was detected. "+
					"A MongodbValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra MongodbValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMongodbValueUnknown(), diags
	}

	collectionAttribute, ok := attributes["collection"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`collection is missing from object`)

		return NewMongodbValueUnknown(), diags
	}

	collectionVal, ok := collectionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`collection expected to be basetypes.StringValue, was: %T`, collectionAttribute))
	}

	databaseAttribute, ok := attributes["database"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`database is missing from object`)

		return NewMongodbValueUnknown(), diags
	}

	databaseVal, ok := databaseAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`database expected to be basetypes.StringValue, was: %T`, databaseAttribute))
	}

	uriAttribute, ok := attributes["uri"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uri is missing from object`)

		return NewMongodbValueUnknown(), diags
	}

	uriVal, ok := uriAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uri expected to be basetypes.StringValue, was: %T`, uriAttribute))
	}

	if diags.HasError() {
		return NewMongodbValueUnknown(), diags
	}

	return MongodbValue{
		Collection: collectionVal,
		Database:   databaseVal,
		Uri:        uriVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewMongodbValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) MongodbValue {
	object, diags := NewMongodbValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMongodbValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t MongodbType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMongodbValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMongodbValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMongodbValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMongodbValueMust(MongodbValue{}.AttributeTypes(ctx), attributes), nil
}

func (t MongodbType) ValueType(ctx context.Context) attr.Value {
	return MongodbValue{}
}

var _ basetypes.ObjectValuable = MongodbValue{}

type MongodbValue struct {
	Collection basetypes.StringValue `tfsdk:"collection"`
	Database   basetypes.StringValue `tfsdk:"database"`
	Uri        basetypes.StringValue `tfsdk:"uri"`
	state      attr.ValueState
}

func (v MongodbValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["collection"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["database"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["uri"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Collection.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["collection"] = val

		val, err = v.Database.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["database"] = val

		val, err = v.Uri.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["uri"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v MongodbValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v MongodbValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v MongodbValue) String() string {
	return "MongodbValue"
}

func (v MongodbValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"collection": basetypes.StringType{},
		"database":   basetypes.StringType{},
		"uri":        basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"collection": v.Collection,
			"database":   v.Database,
			"uri":        v.Uri,
		})

	return objVal, diags
}

func (v MongodbValue) Equal(o attr.Value) bool {
	other, ok := o.(MongodbValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Collection.Equal(other.Collection) {
		return false
	}

	if !v.Database.Equal(other.Database) {
		return false
	}

	if !v.Uri.Equal(other.Uri) {
		return false
	}

	return true
}

func (v MongodbValue) Type(ctx context.Context) attr.Type {
	return MongodbType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v MongodbValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"collection": basetypes.StringType{},
		"database":   basetypes.StringType{},
		"uri":        basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = OnedriveType{}

type OnedriveType struct {
	basetypes.ObjectType
}

func (t OnedriveType) Equal(o attr.Type) bool {
	other, ok := o.(OnedriveType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t OnedriveType) String() string {
	return "OnedriveType"
}

func (t OnedriveType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	authorityUrlAttribute, ok := attributes["authority_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`authority_url is missing from object`)

		return nil, diags
	}

	authorityUrlVal, ok := authorityUrlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`authority_url expected to be basetypes.StringValue, was: %T`, authorityUrlAttribute))
	}

	clientCredAttribute, ok := attributes["client_cred"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`client_cred is missing from object`)

		return nil, diags
	}

	clientCredVal, ok := clientCredAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`client_cred expected to be basetypes.StringValue, was: %T`, clientCredAttribute))
	}

	clientIdAttribute, ok := attributes["client_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`client_id is missing from object`)

		return nil, diags
	}

	clientIdVal, ok := clientIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`client_id expected to be basetypes.StringValue, was: %T`, clientIdAttribute))
	}

	pathAttribute, ok := attributes["path"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`path is missing from object`)

		return nil, diags
	}

	pathVal, ok := pathAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`path expected to be basetypes.StringValue, was: %T`, pathAttribute))
	}

	recursiveAttribute, ok := attributes["recursive"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`recursive is missing from object`)

		return nil, diags
	}

	recursiveVal, ok := recursiveAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`recursive expected to be basetypes.BoolValue, was: %T`, recursiveAttribute))
	}

	tenantAttribute, ok := attributes["tenant"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tenant is missing from object`)

		return nil, diags
	}

	tenantVal, ok := tenantAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tenant expected to be basetypes.StringValue, was: %T`, tenantAttribute))
	}

	userPnameAttribute, ok := attributes["user_pname"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`user_pname is missing from object`)

		return nil, diags
	}

	userPnameVal, ok := userPnameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`user_pname expected to be basetypes.StringValue, was: %T`, userPnameAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return OnedriveValue{
		AuthorityUrl: authorityUrlVal,
		ClientCred:   clientCredVal,
		ClientId:     clientIdVal,
		Path:         pathVal,
		Recursive:    recursiveVal,
		Tenant:       tenantVal,
		UserPname:    userPnameVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewOnedriveValueNull() OnedriveValue {
	return OnedriveValue{
		state: attr.ValueStateNull,
	}
}

func NewOnedriveValueUnknown() OnedriveValue {
	return OnedriveValue{
		state: attr.ValueStateUnknown,
	}
}

func NewOnedriveValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (OnedriveValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing OnedriveValue Attribute Value",
				"While creating a OnedriveValue value, a missing attribute value was detected. "+
					"A OnedriveValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OnedriveValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid OnedriveValue Attribute Type",
				"While creating a OnedriveValue value, an invalid attribute value was detected. "+
					"A OnedriveValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OnedriveValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("OnedriveValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra OnedriveValue Attribute Value",
				"While creating a OnedriveValue value, an extra attribute value was detected. "+
					"A OnedriveValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra OnedriveValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewOnedriveValueUnknown(), diags
	}

	authorityUrlAttribute, ok := attributes["authority_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`authority_url is missing from object`)

		return NewOnedriveValueUnknown(), diags
	}

	authorityUrlVal, ok := authorityUrlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`authority_url expected to be basetypes.StringValue, was: %T`, authorityUrlAttribute))
	}

	clientCredAttribute, ok := attributes["client_cred"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`client_cred is missing from object`)

		return NewOnedriveValueUnknown(), diags
	}

	clientCredVal, ok := clientCredAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`client_cred expected to be basetypes.StringValue, was: %T`, clientCredAttribute))
	}

	clientIdAttribute, ok := attributes["client_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`client_id is missing from object`)

		return NewOnedriveValueUnknown(), diags
	}

	clientIdVal, ok := clientIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`client_id expected to be basetypes.StringValue, was: %T`, clientIdAttribute))
	}

	pathAttribute, ok := attributes["path"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`path is missing from object`)

		return NewOnedriveValueUnknown(), diags
	}

	pathVal, ok := pathAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`path expected to be basetypes.StringValue, was: %T`, pathAttribute))
	}

	recursiveAttribute, ok := attributes["recursive"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`recursive is missing from object`)

		return NewOnedriveValueUnknown(), diags
	}

	recursiveVal, ok := recursiveAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`recursive expected to be basetypes.BoolValue, was: %T`, recursiveAttribute))
	}

	tenantAttribute, ok := attributes["tenant"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tenant is missing from object`)

		return NewOnedriveValueUnknown(), diags
	}

	tenantVal, ok := tenantAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tenant expected to be basetypes.StringValue, was: %T`, tenantAttribute))
	}

	userPnameAttribute, ok := attributes["user_pname"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`user_pname is missing from object`)

		return NewOnedriveValueUnknown(), diags
	}

	userPnameVal, ok := userPnameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`user_pname expected to be basetypes.StringValue, was: %T`, userPnameAttribute))
	}

	if diags.HasError() {
		return NewOnedriveValueUnknown(), diags
	}

	return OnedriveValue{
		AuthorityUrl: authorityUrlVal,
		ClientCred:   clientCredVal,
		ClientId:     clientIdVal,
		Path:         pathVal,
		Recursive:    recursiveVal,
		Tenant:       tenantVal,
		UserPname:    userPnameVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewOnedriveValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) OnedriveValue {
	object, diags := NewOnedriveValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewOnedriveValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t OnedriveType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewOnedriveValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewOnedriveValueUnknown(), nil
	}

	if in.IsNull() {
		return NewOnedriveValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewOnedriveValueMust(OnedriveValue{}.AttributeTypes(ctx), attributes), nil
}

func (t OnedriveType) ValueType(ctx context.Context) attr.Value {
	return OnedriveValue{}
}

var _ basetypes.ObjectValuable = OnedriveValue{}

type OnedriveValue struct {
	AuthorityUrl basetypes.StringValue `tfsdk:"authority_url"`
	ClientCred   basetypes.StringValue `tfsdk:"client_cred"`
	ClientId     basetypes.StringValue `tfsdk:"client_id"`
	Path         basetypes.StringValue `tfsdk:"path"`
	Recursive    basetypes.BoolValue   `tfsdk:"recursive"`
	Tenant       basetypes.StringValue `tfsdk:"tenant"`
	UserPname    basetypes.StringValue `tfsdk:"user_pname"`
	state        attr.ValueState
}

func (v OnedriveValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 7)

	var val tftypes.Value
	var err error

	attrTypes["authority_url"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["client_cred"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["client_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["path"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["recursive"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["tenant"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["user_pname"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 7)

		val, err = v.AuthorityUrl.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["authority_url"] = val

		val, err = v.ClientCred.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["client_cred"] = val

		val, err = v.ClientId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["client_id"] = val

		val, err = v.Path.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["path"] = val

		val, err = v.Recursive.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["recursive"] = val

		val, err = v.Tenant.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tenant"] = val

		val, err = v.UserPname.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["user_pname"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v OnedriveValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v OnedriveValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v OnedriveValue) String() string {
	return "OnedriveValue"
}

func (v OnedriveValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"authority_url": basetypes.StringType{},
		"client_cred":   basetypes.StringType{},
		"client_id":     basetypes.StringType{},
		"path":          basetypes.StringType{},
		"recursive":     basetypes.BoolType{},
		"tenant":        basetypes.StringType{},
		"user_pname":    basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"authority_url": v.AuthorityUrl,
			"client_cred":   v.ClientCred,
			"client_id":     v.ClientId,
			"path":          v.Path,
			"recursive":     v.Recursive,
			"tenant":        v.Tenant,
			"user_pname":    v.UserPname,
		})

	return objVal, diags
}

func (v OnedriveValue) Equal(o attr.Value) bool {
	other, ok := o.(OnedriveValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AuthorityUrl.Equal(other.AuthorityUrl) {
		return false
	}

	if !v.ClientCred.Equal(other.ClientCred) {
		return false
	}

	if !v.ClientId.Equal(other.ClientId) {
		return false
	}

	if !v.Path.Equal(other.Path) {
		return false
	}

	if !v.Recursive.Equal(other.Recursive) {
		return false
	}

	if !v.Tenant.Equal(other.Tenant) {
		return false
	}

	if !v.UserPname.Equal(other.UserPname) {
		return false
	}

	return true
}

func (v OnedriveValue) Type(ctx context.Context) attr.Type {
	return OnedriveType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v OnedriveValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"authority_url": basetypes.StringType{},
		"client_cred":   basetypes.StringType{},
		"client_id":     basetypes.StringType{},
		"path":          basetypes.StringType{},
		"recursive":     basetypes.BoolType{},
		"tenant":        basetypes.StringType{},
		"user_pname":    basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = OutlookType{}

type OutlookType struct {
	basetypes.ObjectType
}

func (t OutlookType) Equal(o attr.Type) bool {
	other, ok := o.(OutlookType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t OutlookType) String() string {
	return "OutlookType"
}

func (t OutlookType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	authorityUrlAttribute, ok := attributes["authority_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`authority_url is missing from object`)

		return nil, diags
	}

	authorityUrlVal, ok := authorityUrlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`authority_url expected to be basetypes.StringValue, was: %T`, authorityUrlAttribute))
	}

	clientCredAttribute, ok := attributes["client_cred"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`client_cred is missing from object`)

		return nil, diags
	}

	clientCredVal, ok := clientCredAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`client_cred expected to be basetypes.StringValue, was: %T`, clientCredAttribute))
	}

	clientIdAttribute, ok := attributes["client_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`client_id is missing from object`)

		return nil, diags
	}

	clientIdVal, ok := clientIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`client_id expected to be basetypes.StringValue, was: %T`, clientIdAttribute))
	}

	outlookFoldersAttribute, ok := attributes["outlook_folders"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`outlook_folders is missing from object`)

		return nil, diags
	}

	outlookFoldersVal, ok := outlookFoldersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`outlook_folders expected to be basetypes.ListValue, was: %T`, outlookFoldersAttribute))
	}

	recursiveAttribute, ok := attributes["recursive"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`recursive is missing from object`)

		return nil, diags
	}

	recursiveVal, ok := recursiveAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`recursive expected to be basetypes.BoolValue, was: %T`, recursiveAttribute))
	}

	tenantAttribute, ok := attributes["tenant"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tenant is missing from object`)

		return nil, diags
	}

	tenantVal, ok := tenantAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tenant expected to be basetypes.StringValue, was: %T`, tenantAttribute))
	}

	userEmailAttribute, ok := attributes["user_email"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`user_email is missing from object`)

		return nil, diags
	}

	userEmailVal, ok := userEmailAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`user_email expected to be basetypes.StringValue, was: %T`, userEmailAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return OutlookValue{
		AuthorityUrl:   authorityUrlVal,
		ClientCred:     clientCredVal,
		ClientId:       clientIdVal,
		OutlookFolders: outlookFoldersVal,
		Recursive:      recursiveVal,
		Tenant:         tenantVal,
		UserEmail:      userEmailVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewOutlookValueNull() OutlookValue {
	return OutlookValue{
		state: attr.ValueStateNull,
	}
}

func NewOutlookValueUnknown() OutlookValue {
	return OutlookValue{
		state: attr.ValueStateUnknown,
	}
}

func NewOutlookValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (OutlookValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing OutlookValue Attribute Value",
				"While creating a OutlookValue value, a missing attribute value was detected. "+
					"A OutlookValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OutlookValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid OutlookValue Attribute Type",
				"While creating a OutlookValue value, an invalid attribute value was detected. "+
					"A OutlookValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OutlookValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("OutlookValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra OutlookValue Attribute Value",
				"While creating a OutlookValue value, an extra attribute value was detected. "+
					"A OutlookValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra OutlookValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewOutlookValueUnknown(), diags
	}

	authorityUrlAttribute, ok := attributes["authority_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`authority_url is missing from object`)

		return NewOutlookValueUnknown(), diags
	}

	authorityUrlVal, ok := authorityUrlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`authority_url expected to be basetypes.StringValue, was: %T`, authorityUrlAttribute))
	}

	clientCredAttribute, ok := attributes["client_cred"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`client_cred is missing from object`)

		return NewOutlookValueUnknown(), diags
	}

	clientCredVal, ok := clientCredAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`client_cred expected to be basetypes.StringValue, was: %T`, clientCredAttribute))
	}

	clientIdAttribute, ok := attributes["client_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`client_id is missing from object`)

		return NewOutlookValueUnknown(), diags
	}

	clientIdVal, ok := clientIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`client_id expected to be basetypes.StringValue, was: %T`, clientIdAttribute))
	}

	outlookFoldersAttribute, ok := attributes["outlook_folders"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`outlook_folders is missing from object`)

		return NewOutlookValueUnknown(), diags
	}

	outlookFoldersVal, ok := outlookFoldersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`outlook_folders expected to be basetypes.ListValue, was: %T`, outlookFoldersAttribute))
	}

	recursiveAttribute, ok := attributes["recursive"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`recursive is missing from object`)

		return NewOutlookValueUnknown(), diags
	}

	recursiveVal, ok := recursiveAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`recursive expected to be basetypes.BoolValue, was: %T`, recursiveAttribute))
	}

	tenantAttribute, ok := attributes["tenant"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tenant is missing from object`)

		return NewOutlookValueUnknown(), diags
	}

	tenantVal, ok := tenantAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tenant expected to be basetypes.StringValue, was: %T`, tenantAttribute))
	}

	userEmailAttribute, ok := attributes["user_email"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`user_email is missing from object`)

		return NewOutlookValueUnknown(), diags
	}

	userEmailVal, ok := userEmailAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`user_email expected to be basetypes.StringValue, was: %T`, userEmailAttribute))
	}

	if diags.HasError() {
		return NewOutlookValueUnknown(), diags
	}

	return OutlookValue{
		AuthorityUrl:   authorityUrlVal,
		ClientCred:     clientCredVal,
		ClientId:       clientIdVal,
		OutlookFolders: outlookFoldersVal,
		Recursive:      recursiveVal,
		Tenant:         tenantVal,
		UserEmail:      userEmailVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewOutlookValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) OutlookValue {
	object, diags := NewOutlookValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewOutlookValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t OutlookType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewOutlookValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewOutlookValueUnknown(), nil
	}

	if in.IsNull() {
		return NewOutlookValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewOutlookValueMust(OutlookValue{}.AttributeTypes(ctx), attributes), nil
}

func (t OutlookType) ValueType(ctx context.Context) attr.Value {
	return OutlookValue{}
}

var _ basetypes.ObjectValuable = OutlookValue{}

type OutlookValue struct {
	AuthorityUrl   basetypes.StringValue `tfsdk:"authority_url"`
	ClientCred     basetypes.StringValue `tfsdk:"client_cred"`
	ClientId       basetypes.StringValue `tfsdk:"client_id"`
	OutlookFolders basetypes.ListValue   `tfsdk:"outlook_folders"`
	Recursive      basetypes.BoolValue   `tfsdk:"recursive"`
	Tenant         basetypes.StringValue `tfsdk:"tenant"`
	UserEmail      basetypes.StringValue `tfsdk:"user_email"`
	state          attr.ValueState
}

func (v OutlookValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 7)

	var val tftypes.Value
	var err error

	attrTypes["authority_url"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["client_cred"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["client_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["outlook_folders"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["recursive"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["tenant"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["user_email"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 7)

		val, err = v.AuthorityUrl.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["authority_url"] = val

		val, err = v.ClientCred.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["client_cred"] = val

		val, err = v.ClientId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["client_id"] = val

		val, err = v.OutlookFolders.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["outlook_folders"] = val

		val, err = v.Recursive.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["recursive"] = val

		val, err = v.Tenant.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tenant"] = val

		val, err = v.UserEmail.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["user_email"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v OutlookValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v OutlookValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v OutlookValue) String() string {
	return "OutlookValue"
}

func (v OutlookValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var outlookFoldersVal basetypes.ListValue
	switch {
	case v.OutlookFolders.IsUnknown():
		outlookFoldersVal = types.ListUnknown(types.StringType)
	case v.OutlookFolders.IsNull():
		outlookFoldersVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		outlookFoldersVal, d = types.ListValue(types.StringType, v.OutlookFolders.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"authority_url": basetypes.StringType{},
			"client_cred":   basetypes.StringType{},
			"client_id":     basetypes.StringType{},
			"outlook_folders": basetypes.ListType{
				ElemType: types.StringType,
			},
			"recursive":  basetypes.BoolType{},
			"tenant":     basetypes.StringType{},
			"user_email": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"authority_url": basetypes.StringType{},
		"client_cred":   basetypes.StringType{},
		"client_id":     basetypes.StringType{},
		"outlook_folders": basetypes.ListType{
			ElemType: types.StringType,
		},
		"recursive":  basetypes.BoolType{},
		"tenant":     basetypes.StringType{},
		"user_email": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"authority_url":   v.AuthorityUrl,
			"client_cred":     v.ClientCred,
			"client_id":       v.ClientId,
			"outlook_folders": outlookFoldersVal,
			"recursive":       v.Recursive,
			"tenant":          v.Tenant,
			"user_email":      v.UserEmail,
		})

	return objVal, diags
}

func (v OutlookValue) Equal(o attr.Value) bool {
	other, ok := o.(OutlookValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AuthorityUrl.Equal(other.AuthorityUrl) {
		return false
	}

	if !v.ClientCred.Equal(other.ClientCred) {
		return false
	}

	if !v.ClientId.Equal(other.ClientId) {
		return false
	}

	if !v.OutlookFolders.Equal(other.OutlookFolders) {
		return false
	}

	if !v.Recursive.Equal(other.Recursive) {
		return false
	}

	if !v.Tenant.Equal(other.Tenant) {
		return false
	}

	if !v.UserEmail.Equal(other.UserEmail) {
		return false
	}

	return true
}

func (v OutlookValue) Type(ctx context.Context) attr.Type {
	return OutlookType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v OutlookValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"authority_url": basetypes.StringType{},
		"client_cred":   basetypes.StringType{},
		"client_id":     basetypes.StringType{},
		"outlook_folders": basetypes.ListType{
			ElemType: types.StringType,
		},
		"recursive":  basetypes.BoolType{},
		"tenant":     basetypes.StringType{},
		"user_email": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = PostgresType{}

type PostgresType struct {
	basetypes.ObjectType
}

func (t PostgresType) Equal(o attr.Type) bool {
	other, ok := o.(PostgresType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PostgresType) String() string {
	return "PostgresType"
}

func (t PostgresType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	batchSizeAttribute, ok := attributes["batch_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`batch_size is missing from object`)

		return nil, diags
	}

	batchSizeVal, ok := batchSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`batch_size expected to be basetypes.Int64Value, was: %T`, batchSizeAttribute))
	}

	databaseAttribute, ok := attributes["database"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`database is missing from object`)

		return nil, diags
	}

	databaseVal, ok := databaseAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`database expected to be basetypes.StringValue, was: %T`, databaseAttribute))
	}

	fieldsAttribute, ok := attributes["fields"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fields is missing from object`)

		return nil, diags
	}

	fieldsVal, ok := fieldsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fields expected to be basetypes.ListValue, was: %T`, fieldsAttribute))
	}

	hostAttribute, ok := attributes["host"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`host is missing from object`)

		return nil, diags
	}

	hostVal, ok := hostAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`host expected to be basetypes.StringValue, was: %T`, hostAttribute))
	}

	idColumnAttribute, ok := attributes["id_column"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id_column is missing from object`)

		return nil, diags
	}

	idColumnVal, ok := idColumnAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id_column expected to be basetypes.StringValue, was: %T`, idColumnAttribute))
	}

	passwordAttribute, ok := attributes["password"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`password is missing from object`)

		return nil, diags
	}

	passwordVal, ok := passwordAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`password expected to be basetypes.StringValue, was: %T`, passwordAttribute))
	}

	portAttribute, ok := attributes["port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port is missing from object`)

		return nil, diags
	}

	portVal, ok := portAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port expected to be basetypes.Int64Value, was: %T`, portAttribute))
	}

	tableNameAttribute, ok := attributes["table_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`table_name is missing from object`)

		return nil, diags
	}

	tableNameVal, ok := tableNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`table_name expected to be basetypes.StringValue, was: %T`, tableNameAttribute))
	}

	usernameAttribute, ok := attributes["username"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`username is missing from object`)

		return nil, diags
	}

	usernameVal, ok := usernameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`username expected to be basetypes.StringValue, was: %T`, usernameAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PostgresValue{
		BatchSize: batchSizeVal,
		Database:  databaseVal,
		Fields:    fieldsVal,
		Host:      hostVal,
		IdColumn:  idColumnVal,
		Password:  passwordVal,
		Port:      portVal,
		TableName: tableNameVal,
		Username:  usernameVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewPostgresValueNull() PostgresValue {
	return PostgresValue{
		state: attr.ValueStateNull,
	}
}

func NewPostgresValueUnknown() PostgresValue {
	return PostgresValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPostgresValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PostgresValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PostgresValue Attribute Value",
				"While creating a PostgresValue value, a missing attribute value was detected. "+
					"A PostgresValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PostgresValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PostgresValue Attribute Type",
				"While creating a PostgresValue value, an invalid attribute value was detected. "+
					"A PostgresValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PostgresValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PostgresValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PostgresValue Attribute Value",
				"While creating a PostgresValue value, an extra attribute value was detected. "+
					"A PostgresValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PostgresValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPostgresValueUnknown(), diags
	}

	batchSizeAttribute, ok := attributes["batch_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`batch_size is missing from object`)

		return NewPostgresValueUnknown(), diags
	}

	batchSizeVal, ok := batchSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`batch_size expected to be basetypes.Int64Value, was: %T`, batchSizeAttribute))
	}

	databaseAttribute, ok := attributes["database"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`database is missing from object`)

		return NewPostgresValueUnknown(), diags
	}

	databaseVal, ok := databaseAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`database expected to be basetypes.StringValue, was: %T`, databaseAttribute))
	}

	fieldsAttribute, ok := attributes["fields"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fields is missing from object`)

		return NewPostgresValueUnknown(), diags
	}

	fieldsVal, ok := fieldsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fields expected to be basetypes.ListValue, was: %T`, fieldsAttribute))
	}

	hostAttribute, ok := attributes["host"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`host is missing from object`)

		return NewPostgresValueUnknown(), diags
	}

	hostVal, ok := hostAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`host expected to be basetypes.StringValue, was: %T`, hostAttribute))
	}

	idColumnAttribute, ok := attributes["id_column"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id_column is missing from object`)

		return NewPostgresValueUnknown(), diags
	}

	idColumnVal, ok := idColumnAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id_column expected to be basetypes.StringValue, was: %T`, idColumnAttribute))
	}

	passwordAttribute, ok := attributes["password"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`password is missing from object`)

		return NewPostgresValueUnknown(), diags
	}

	passwordVal, ok := passwordAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`password expected to be basetypes.StringValue, was: %T`, passwordAttribute))
	}

	portAttribute, ok := attributes["port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port is missing from object`)

		return NewPostgresValueUnknown(), diags
	}

	portVal, ok := portAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port expected to be basetypes.Int64Value, was: %T`, portAttribute))
	}

	tableNameAttribute, ok := attributes["table_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`table_name is missing from object`)

		return NewPostgresValueUnknown(), diags
	}

	tableNameVal, ok := tableNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`table_name expected to be basetypes.StringValue, was: %T`, tableNameAttribute))
	}

	usernameAttribute, ok := attributes["username"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`username is missing from object`)

		return NewPostgresValueUnknown(), diags
	}

	usernameVal, ok := usernameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`username expected to be basetypes.StringValue, was: %T`, usernameAttribute))
	}

	if diags.HasError() {
		return NewPostgresValueUnknown(), diags
	}

	return PostgresValue{
		BatchSize: batchSizeVal,
		Database:  databaseVal,
		Fields:    fieldsVal,
		Host:      hostVal,
		IdColumn:  idColumnVal,
		Password:  passwordVal,
		Port:      portVal,
		TableName: tableNameVal,
		Username:  usernameVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewPostgresValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PostgresValue {
	object, diags := NewPostgresValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPostgresValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PostgresType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPostgresValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPostgresValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPostgresValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPostgresValueMust(PostgresValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PostgresType) ValueType(ctx context.Context) attr.Value {
	return PostgresValue{}
}

var _ basetypes.ObjectValuable = PostgresValue{}

type PostgresValue struct {
	BatchSize basetypes.Int64Value  `tfsdk:"batch_size"`
	Database  basetypes.StringValue `tfsdk:"database"`
	Fields    basetypes.ListValue   `tfsdk:"fields"`
	Host      basetypes.StringValue `tfsdk:"host"`
	IdColumn  basetypes.StringValue `tfsdk:"id_column"`
	Password  basetypes.StringValue `tfsdk:"password"`
	Port      basetypes.Int64Value  `tfsdk:"port"`
	TableName basetypes.StringValue `tfsdk:"table_name"`
	Username  basetypes.StringValue `tfsdk:"username"`
	state     attr.ValueState
}

func (v PostgresValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 9)

	var val tftypes.Value
	var err error

	attrTypes["batch_size"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["database"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["fields"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["host"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["id_column"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["password"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["port"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["table_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["username"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 9)

		val, err = v.BatchSize.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["batch_size"] = val

		val, err = v.Database.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["database"] = val

		val, err = v.Fields.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["fields"] = val

		val, err = v.Host.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["host"] = val

		val, err = v.IdColumn.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id_column"] = val

		val, err = v.Password.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["password"] = val

		val, err = v.Port.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port"] = val

		val, err = v.TableName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["table_name"] = val

		val, err = v.Username.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["username"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PostgresValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PostgresValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PostgresValue) String() string {
	return "PostgresValue"
}

func (v PostgresValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var fieldsVal basetypes.ListValue
	switch {
	case v.Fields.IsUnknown():
		fieldsVal = types.ListUnknown(types.StringType)
	case v.Fields.IsNull():
		fieldsVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		fieldsVal, d = types.ListValue(types.StringType, v.Fields.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"batch_size": basetypes.Int64Type{},
			"database":   basetypes.StringType{},
			"fields": basetypes.ListType{
				ElemType: types.StringType,
			},
			"host":       basetypes.StringType{},
			"id_column":  basetypes.StringType{},
			"password":   basetypes.StringType{},
			"port":       basetypes.Int64Type{},
			"table_name": basetypes.StringType{},
			"username":   basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"batch_size": basetypes.Int64Type{},
		"database":   basetypes.StringType{},
		"fields": basetypes.ListType{
			ElemType: types.StringType,
		},
		"host":       basetypes.StringType{},
		"id_column":  basetypes.StringType{},
		"password":   basetypes.StringType{},
		"port":       basetypes.Int64Type{},
		"table_name": basetypes.StringType{},
		"username":   basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"batch_size": v.BatchSize,
			"database":   v.Database,
			"fields":     fieldsVal,
			"host":       v.Host,
			"id_column":  v.IdColumn,
			"password":   v.Password,
			"port":       v.Port,
			"table_name": v.TableName,
			"username":   v.Username,
		})

	return objVal, diags
}

func (v PostgresValue) Equal(o attr.Value) bool {
	other, ok := o.(PostgresValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.BatchSize.Equal(other.BatchSize) {
		return false
	}

	if !v.Database.Equal(other.Database) {
		return false
	}

	if !v.Fields.Equal(other.Fields) {
		return false
	}

	if !v.Host.Equal(other.Host) {
		return false
	}

	if !v.IdColumn.Equal(other.IdColumn) {
		return false
	}

	if !v.Password.Equal(other.Password) {
		return false
	}

	if !v.Port.Equal(other.Port) {
		return false
	}

	if !v.TableName.Equal(other.TableName) {
		return false
	}

	if !v.Username.Equal(other.Username) {
		return false
	}

	return true
}

func (v PostgresValue) Type(ctx context.Context) attr.Type {
	return PostgresType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PostgresValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"batch_size": basetypes.Int64Type{},
		"database":   basetypes.StringType{},
		"fields": basetypes.ListType{
			ElemType: types.StringType,
		},
		"host":       basetypes.StringType{},
		"id_column":  basetypes.StringType{},
		"password":   basetypes.StringType{},
		"port":       basetypes.Int64Type{},
		"table_name": basetypes.StringType{},
		"username":   basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = S3Type{}

type S3Type struct {
	basetypes.ObjectType
}

func (t S3Type) Equal(o attr.Type) bool {
	other, ok := o.(S3Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t S3Type) String() string {
	return "S3Type"
}

func (t S3Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	anonymousAttribute, ok := attributes["anonymous"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`anonymous is missing from object`)

		return nil, diags
	}

	anonymousVal, ok := anonymousAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`anonymous expected to be basetypes.BoolValue, was: %T`, anonymousAttribute))
	}

	endpointUrlAttribute, ok := attributes["endpoint_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`endpoint_url is missing from object`)

		return nil, diags
	}

	endpointUrlVal, ok := endpointUrlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`endpoint_url expected to be basetypes.StringValue, was: %T`, endpointUrlAttribute))
	}

	keyAttribute, ok := attributes["key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`key is missing from object`)

		return nil, diags
	}

	keyVal, ok := keyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`key expected to be basetypes.StringValue, was: %T`, keyAttribute))
	}

	recursiveAttribute, ok := attributes["recursive"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`recursive is missing from object`)

		return nil, diags
	}

	recursiveVal, ok := recursiveAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`recursive expected to be basetypes.BoolValue, was: %T`, recursiveAttribute))
	}

	remoteUrlAttribute, ok := attributes["remote_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remote_url is missing from object`)

		return nil, diags
	}

	remoteUrlVal, ok := remoteUrlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remote_url expected to be basetypes.StringValue, was: %T`, remoteUrlAttribute))
	}

	secretAttribute, ok := attributes["secret"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`secret is missing from object`)

		return nil, diags
	}

	secretVal, ok := secretAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`secret expected to be basetypes.StringValue, was: %T`, secretAttribute))
	}

	tokenAttribute, ok := attributes["token"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`token is missing from object`)

		return nil, diags
	}

	tokenVal, ok := tokenAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`token expected to be basetypes.StringValue, was: %T`, tokenAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return S3Value{
		Anonymous:   anonymousVal,
		EndpointUrl: endpointUrlVal,
		Key:         keyVal,
		Recursive:   recursiveVal,
		RemoteUrl:   remoteUrlVal,
		Secret:      secretVal,
		Token:       tokenVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewS3ValueNull() S3Value {
	return S3Value{
		state: attr.ValueStateNull,
	}
}

func NewS3ValueUnknown() S3Value {
	return S3Value{
		state: attr.ValueStateUnknown,
	}
}

func NewS3Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (S3Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing S3Value Attribute Value",
				"While creating a S3Value value, a missing attribute value was detected. "+
					"A S3Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("S3Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid S3Value Attribute Type",
				"While creating a S3Value value, an invalid attribute value was detected. "+
					"A S3Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("S3Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("S3Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra S3Value Attribute Value",
				"While creating a S3Value value, an extra attribute value was detected. "+
					"A S3Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra S3Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewS3ValueUnknown(), diags
	}

	anonymousAttribute, ok := attributes["anonymous"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`anonymous is missing from object`)

		return NewS3ValueUnknown(), diags
	}

	anonymousVal, ok := anonymousAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`anonymous expected to be basetypes.BoolValue, was: %T`, anonymousAttribute))
	}

	endpointUrlAttribute, ok := attributes["endpoint_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`endpoint_url is missing from object`)

		return NewS3ValueUnknown(), diags
	}

	endpointUrlVal, ok := endpointUrlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`endpoint_url expected to be basetypes.StringValue, was: %T`, endpointUrlAttribute))
	}

	keyAttribute, ok := attributes["key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`key is missing from object`)

		return NewS3ValueUnknown(), diags
	}

	keyVal, ok := keyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`key expected to be basetypes.StringValue, was: %T`, keyAttribute))
	}

	recursiveAttribute, ok := attributes["recursive"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`recursive is missing from object`)

		return NewS3ValueUnknown(), diags
	}

	recursiveVal, ok := recursiveAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`recursive expected to be basetypes.BoolValue, was: %T`, recursiveAttribute))
	}

	remoteUrlAttribute, ok := attributes["remote_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remote_url is missing from object`)

		return NewS3ValueUnknown(), diags
	}

	remoteUrlVal, ok := remoteUrlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remote_url expected to be basetypes.StringValue, was: %T`, remoteUrlAttribute))
	}

	secretAttribute, ok := attributes["secret"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`secret is missing from object`)

		return NewS3ValueUnknown(), diags
	}

	secretVal, ok := secretAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`secret expected to be basetypes.StringValue, was: %T`, secretAttribute))
	}

	tokenAttribute, ok := attributes["token"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`token is missing from object`)

		return NewS3ValueUnknown(), diags
	}

	tokenVal, ok := tokenAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`token expected to be basetypes.StringValue, was: %T`, tokenAttribute))
	}

	if diags.HasError() {
		return NewS3ValueUnknown(), diags
	}

	return S3Value{
		Anonymous:   anonymousVal,
		EndpointUrl: endpointUrlVal,
		Key:         keyVal,
		Recursive:   recursiveVal,
		RemoteUrl:   remoteUrlVal,
		Secret:      secretVal,
		Token:       tokenVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewS3ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) S3Value {
	object, diags := NewS3Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewS3ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t S3Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewS3ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewS3ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewS3ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewS3ValueMust(S3Value{}.AttributeTypes(ctx), attributes), nil
}

func (t S3Type) ValueType(ctx context.Context) attr.Value {
	return S3Value{}
}

var _ basetypes.ObjectValuable = S3Value{}

type S3Value struct {
	Anonymous   basetypes.BoolValue   `tfsdk:"anonymous"`
	EndpointUrl basetypes.StringValue `tfsdk:"endpoint_url"`
	Key         basetypes.StringValue `tfsdk:"key"`
	Recursive   basetypes.BoolValue   `tfsdk:"recursive"`
	RemoteUrl   basetypes.StringValue `tfsdk:"remote_url"`
	Secret      basetypes.StringValue `tfsdk:"secret"`
	Token       basetypes.StringValue `tfsdk:"token"`
	state       attr.ValueState
}

func (v S3Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 7)

	var val tftypes.Value
	var err error

	attrTypes["anonymous"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["endpoint_url"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["key"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["recursive"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["remote_url"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["secret"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["token"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 7)

		val, err = v.Anonymous.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["anonymous"] = val

		val, err = v.EndpointUrl.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["endpoint_url"] = val

		val, err = v.Key.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["key"] = val

		val, err = v.Recursive.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["recursive"] = val

		val, err = v.RemoteUrl.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["remote_url"] = val

		val, err = v.Secret.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["secret"] = val

		val, err = v.Token.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["token"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v S3Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v S3Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v S3Value) String() string {
	return "S3Value"
}

func (v S3Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"anonymous":    basetypes.BoolType{},
		"endpoint_url": basetypes.StringType{},
		"key":          basetypes.StringType{},
		"recursive":    basetypes.BoolType{},
		"remote_url":   basetypes.StringType{},
		"secret":       basetypes.StringType{},
		"token":        basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"anonymous":    v.Anonymous,
			"endpoint_url": v.EndpointUrl,
			"key":          v.Key,
			"recursive":    v.Recursive,
			"remote_url":   v.RemoteUrl,
			"secret":       v.Secret,
			"token":        v.Token,
		})

	return objVal, diags
}

func (v S3Value) Equal(o attr.Value) bool {
	other, ok := o.(S3Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Anonymous.Equal(other.Anonymous) {
		return false
	}

	if !v.EndpointUrl.Equal(other.EndpointUrl) {
		return false
	}

	if !v.Key.Equal(other.Key) {
		return false
	}

	if !v.Recursive.Equal(other.Recursive) {
		return false
	}

	if !v.RemoteUrl.Equal(other.RemoteUrl) {
		return false
	}

	if !v.Secret.Equal(other.Secret) {
		return false
	}

	if !v.Token.Equal(other.Token) {
		return false
	}

	return true
}

func (v S3Value) Type(ctx context.Context) attr.Type {
	return S3Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v S3Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"anonymous":    basetypes.BoolType{},
		"endpoint_url": basetypes.StringType{},
		"key":          basetypes.StringType{},
		"recursive":    basetypes.BoolType{},
		"remote_url":   basetypes.StringType{},
		"secret":       basetypes.StringType{},
		"token":        basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = SalesforceType{}

type SalesforceType struct {
	basetypes.ObjectType
}

func (t SalesforceType) Equal(o attr.Type) bool {
	other, ok := o.(SalesforceType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SalesforceType) String() string {
	return "SalesforceType"
}

func (t SalesforceType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	categoriesAttribute, ok := attributes["categories"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`categories is missing from object`)

		return nil, diags
	}

	categoriesVal, ok := categoriesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`categories expected to be basetypes.ListValue, was: %T`, categoriesAttribute))
	}

	consumerKeyAttribute, ok := attributes["consumer_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`consumer_key is missing from object`)

		return nil, diags
	}

	consumerKeyVal, ok := consumerKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`consumer_key expected to be basetypes.StringValue, was: %T`, consumerKeyAttribute))
	}

	privateKeyAttribute, ok := attributes["private_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`private_key is missing from object`)

		return nil, diags
	}

	privateKeyVal, ok := privateKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`private_key expected to be basetypes.StringValue, was: %T`, privateKeyAttribute))
	}

	usernameAttribute, ok := attributes["username"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`username is missing from object`)

		return nil, diags
	}

	usernameVal, ok := usernameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`username expected to be basetypes.StringValue, was: %T`, usernameAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SalesforceValue{
		Categories:  categoriesVal,
		ConsumerKey: consumerKeyVal,
		PrivateKey:  privateKeyVal,
		Username:    usernameVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewSalesforceValueNull() SalesforceValue {
	return SalesforceValue{
		state: attr.ValueStateNull,
	}
}

func NewSalesforceValueUnknown() SalesforceValue {
	return SalesforceValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSalesforceValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SalesforceValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SalesforceValue Attribute Value",
				"While creating a SalesforceValue value, a missing attribute value was detected. "+
					"A SalesforceValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SalesforceValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SalesforceValue Attribute Type",
				"While creating a SalesforceValue value, an invalid attribute value was detected. "+
					"A SalesforceValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SalesforceValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SalesforceValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SalesforceValue Attribute Value",
				"While creating a SalesforceValue value, an extra attribute value was detected. "+
					"A SalesforceValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SalesforceValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSalesforceValueUnknown(), diags
	}

	categoriesAttribute, ok := attributes["categories"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`categories is missing from object`)

		return NewSalesforceValueUnknown(), diags
	}

	categoriesVal, ok := categoriesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`categories expected to be basetypes.ListValue, was: %T`, categoriesAttribute))
	}

	consumerKeyAttribute, ok := attributes["consumer_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`consumer_key is missing from object`)

		return NewSalesforceValueUnknown(), diags
	}

	consumerKeyVal, ok := consumerKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`consumer_key expected to be basetypes.StringValue, was: %T`, consumerKeyAttribute))
	}

	privateKeyAttribute, ok := attributes["private_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`private_key is missing from object`)

		return NewSalesforceValueUnknown(), diags
	}

	privateKeyVal, ok := privateKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`private_key expected to be basetypes.StringValue, was: %T`, privateKeyAttribute))
	}

	usernameAttribute, ok := attributes["username"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`username is missing from object`)

		return NewSalesforceValueUnknown(), diags
	}

	usernameVal, ok := usernameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`username expected to be basetypes.StringValue, was: %T`, usernameAttribute))
	}

	if diags.HasError() {
		return NewSalesforceValueUnknown(), diags
	}

	return SalesforceValue{
		Categories:  categoriesVal,
		ConsumerKey: consumerKeyVal,
		PrivateKey:  privateKeyVal,
		Username:    usernameVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewSalesforceValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SalesforceValue {
	object, diags := NewSalesforceValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSalesforceValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SalesforceType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSalesforceValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSalesforceValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSalesforceValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSalesforceValueMust(SalesforceValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SalesforceType) ValueType(ctx context.Context) attr.Value {
	return SalesforceValue{}
}

var _ basetypes.ObjectValuable = SalesforceValue{}

type SalesforceValue struct {
	Categories  basetypes.ListValue   `tfsdk:"categories"`
	ConsumerKey basetypes.StringValue `tfsdk:"consumer_key"`
	PrivateKey  basetypes.StringValue `tfsdk:"private_key"`
	Username    basetypes.StringValue `tfsdk:"username"`
	state       attr.ValueState
}

func (v SalesforceValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["categories"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["consumer_key"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["private_key"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["username"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Categories.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["categories"] = val

		val, err = v.ConsumerKey.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["consumer_key"] = val

		val, err = v.PrivateKey.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["private_key"] = val

		val, err = v.Username.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["username"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SalesforceValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SalesforceValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SalesforceValue) String() string {
	return "SalesforceValue"
}

func (v SalesforceValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var categoriesVal basetypes.ListValue
	switch {
	case v.Categories.IsUnknown():
		categoriesVal = types.ListUnknown(types.StringType)
	case v.Categories.IsNull():
		categoriesVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		categoriesVal, d = types.ListValue(types.StringType, v.Categories.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"categories": basetypes.ListType{
				ElemType: types.StringType,
			},
			"consumer_key": basetypes.StringType{},
			"private_key":  basetypes.StringType{},
			"username":     basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"categories": basetypes.ListType{
			ElemType: types.StringType,
		},
		"consumer_key": basetypes.StringType{},
		"private_key":  basetypes.StringType{},
		"username":     basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"categories":   categoriesVal,
			"consumer_key": v.ConsumerKey,
			"private_key":  v.PrivateKey,
			"username":     v.Username,
		})

	return objVal, diags
}

func (v SalesforceValue) Equal(o attr.Value) bool {
	other, ok := o.(SalesforceValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Categories.Equal(other.Categories) {
		return false
	}

	if !v.ConsumerKey.Equal(other.ConsumerKey) {
		return false
	}

	if !v.PrivateKey.Equal(other.PrivateKey) {
		return false
	}

	if !v.Username.Equal(other.Username) {
		return false
	}

	return true
}

func (v SalesforceValue) Type(ctx context.Context) attr.Type {
	return SalesforceType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SalesforceValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"categories": basetypes.ListType{
			ElemType: types.StringType,
		},
		"consumer_key": basetypes.StringType{},
		"private_key":  basetypes.StringType{},
		"username":     basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = SharepointType{}

type SharepointType struct {
	basetypes.ObjectType
}

func (t SharepointType) Equal(o attr.Type) bool {
	other, ok := o.(SharepointType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SharepointType) String() string {
	return "SharepointType"
}

func (t SharepointType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	authorityUrlAttribute, ok := attributes["authority_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`authority_url is missing from object`)

		return nil, diags
	}

	authorityUrlVal, ok := authorityUrlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`authority_url expected to be basetypes.StringValue, was: %T`, authorityUrlAttribute))
	}

	clientCredAttribute, ok := attributes["client_cred"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`client_cred is missing from object`)

		return nil, diags
	}

	clientCredVal, ok := clientCredAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`client_cred expected to be basetypes.StringValue, was: %T`, clientCredAttribute))
	}

	clientIdAttribute, ok := attributes["client_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`client_id is missing from object`)

		return nil, diags
	}

	clientIdVal, ok := clientIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`client_id expected to be basetypes.StringValue, was: %T`, clientIdAttribute))
	}

	pathAttribute, ok := attributes["path"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`path is missing from object`)

		return nil, diags
	}

	pathVal, ok := pathAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`path expected to be basetypes.StringValue, was: %T`, pathAttribute))
	}

	recursiveAttribute, ok := attributes["recursive"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`recursive is missing from object`)

		return nil, diags
	}

	recursiveVal, ok := recursiveAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`recursive expected to be basetypes.BoolValue, was: %T`, recursiveAttribute))
	}

	siteAttribute, ok := attributes["site"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`site is missing from object`)

		return nil, diags
	}

	siteVal, ok := siteAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`site expected to be basetypes.StringValue, was: %T`, siteAttribute))
	}

	tenantAttribute, ok := attributes["tenant"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tenant is missing from object`)

		return nil, diags
	}

	tenantVal, ok := tenantAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tenant expected to be basetypes.StringValue, was: %T`, tenantAttribute))
	}

	userPnameAttribute, ok := attributes["user_pname"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`user_pname is missing from object`)

		return nil, diags
	}

	userPnameVal, ok := userPnameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`user_pname expected to be basetypes.StringValue, was: %T`, userPnameAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SharepointValue{
		AuthorityUrl: authorityUrlVal,
		ClientCred:   clientCredVal,
		ClientId:     clientIdVal,
		Path:         pathVal,
		Recursive:    recursiveVal,
		Site:         siteVal,
		Tenant:       tenantVal,
		UserPname:    userPnameVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewSharepointValueNull() SharepointValue {
	return SharepointValue{
		state: attr.ValueStateNull,
	}
}

func NewSharepointValueUnknown() SharepointValue {
	return SharepointValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSharepointValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SharepointValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SharepointValue Attribute Value",
				"While creating a SharepointValue value, a missing attribute value was detected. "+
					"A SharepointValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SharepointValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SharepointValue Attribute Type",
				"While creating a SharepointValue value, an invalid attribute value was detected. "+
					"A SharepointValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SharepointValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SharepointValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SharepointValue Attribute Value",
				"While creating a SharepointValue value, an extra attribute value was detected. "+
					"A SharepointValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SharepointValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSharepointValueUnknown(), diags
	}

	authorityUrlAttribute, ok := attributes["authority_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`authority_url is missing from object`)

		return NewSharepointValueUnknown(), diags
	}

	authorityUrlVal, ok := authorityUrlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`authority_url expected to be basetypes.StringValue, was: %T`, authorityUrlAttribute))
	}

	clientCredAttribute, ok := attributes["client_cred"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`client_cred is missing from object`)

		return NewSharepointValueUnknown(), diags
	}

	clientCredVal, ok := clientCredAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`client_cred expected to be basetypes.StringValue, was: %T`, clientCredAttribute))
	}

	clientIdAttribute, ok := attributes["client_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`client_id is missing from object`)

		return NewSharepointValueUnknown(), diags
	}

	clientIdVal, ok := clientIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`client_id expected to be basetypes.StringValue, was: %T`, clientIdAttribute))
	}

	pathAttribute, ok := attributes["path"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`path is missing from object`)

		return NewSharepointValueUnknown(), diags
	}

	pathVal, ok := pathAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`path expected to be basetypes.StringValue, was: %T`, pathAttribute))
	}

	recursiveAttribute, ok := attributes["recursive"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`recursive is missing from object`)

		return NewSharepointValueUnknown(), diags
	}

	recursiveVal, ok := recursiveAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`recursive expected to be basetypes.BoolValue, was: %T`, recursiveAttribute))
	}

	siteAttribute, ok := attributes["site"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`site is missing from object`)

		return NewSharepointValueUnknown(), diags
	}

	siteVal, ok := siteAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`site expected to be basetypes.StringValue, was: %T`, siteAttribute))
	}

	tenantAttribute, ok := attributes["tenant"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tenant is missing from object`)

		return NewSharepointValueUnknown(), diags
	}

	tenantVal, ok := tenantAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tenant expected to be basetypes.StringValue, was: %T`, tenantAttribute))
	}

	userPnameAttribute, ok := attributes["user_pname"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`user_pname is missing from object`)

		return NewSharepointValueUnknown(), diags
	}

	userPnameVal, ok := userPnameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`user_pname expected to be basetypes.StringValue, was: %T`, userPnameAttribute))
	}

	if diags.HasError() {
		return NewSharepointValueUnknown(), diags
	}

	return SharepointValue{
		AuthorityUrl: authorityUrlVal,
		ClientCred:   clientCredVal,
		ClientId:     clientIdVal,
		Path:         pathVal,
		Recursive:    recursiveVal,
		Site:         siteVal,
		Tenant:       tenantVal,
		UserPname:    userPnameVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewSharepointValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SharepointValue {
	object, diags := NewSharepointValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSharepointValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SharepointType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSharepointValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSharepointValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSharepointValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSharepointValueMust(SharepointValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SharepointType) ValueType(ctx context.Context) attr.Value {
	return SharepointValue{}
}

var _ basetypes.ObjectValuable = SharepointValue{}

type SharepointValue struct {
	AuthorityUrl basetypes.StringValue `tfsdk:"authority_url"`
	ClientCred   basetypes.StringValue `tfsdk:"client_cred"`
	ClientId     basetypes.StringValue `tfsdk:"client_id"`
	Path         basetypes.StringValue `tfsdk:"path"`
	Recursive    basetypes.BoolValue   `tfsdk:"recursive"`
	Site         basetypes.StringValue `tfsdk:"site"`
	Tenant       basetypes.StringValue `tfsdk:"tenant"`
	UserPname    basetypes.StringValue `tfsdk:"user_pname"`
	state        attr.ValueState
}

func (v SharepointValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 8)

	var val tftypes.Value
	var err error

	attrTypes["authority_url"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["client_cred"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["client_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["path"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["recursive"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["site"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["tenant"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["user_pname"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 8)

		val, err = v.AuthorityUrl.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["authority_url"] = val

		val, err = v.ClientCred.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["client_cred"] = val

		val, err = v.ClientId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["client_id"] = val

		val, err = v.Path.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["path"] = val

		val, err = v.Recursive.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["recursive"] = val

		val, err = v.Site.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["site"] = val

		val, err = v.Tenant.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tenant"] = val

		val, err = v.UserPname.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["user_pname"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SharepointValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SharepointValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SharepointValue) String() string {
	return "SharepointValue"
}

func (v SharepointValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"authority_url": basetypes.StringType{},
		"client_cred":   basetypes.StringType{},
		"client_id":     basetypes.StringType{},
		"path":          basetypes.StringType{},
		"recursive":     basetypes.BoolType{},
		"site":          basetypes.StringType{},
		"tenant":        basetypes.StringType{},
		"user_pname":    basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"authority_url": v.AuthorityUrl,
			"client_cred":   v.ClientCred,
			"client_id":     v.ClientId,
			"path":          v.Path,
			"recursive":     v.Recursive,
			"site":          v.Site,
			"tenant":        v.Tenant,
			"user_pname":    v.UserPname,
		})

	return objVal, diags
}

func (v SharepointValue) Equal(o attr.Value) bool {
	other, ok := o.(SharepointValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AuthorityUrl.Equal(other.AuthorityUrl) {
		return false
	}

	if !v.ClientCred.Equal(other.ClientCred) {
		return false
	}

	if !v.ClientId.Equal(other.ClientId) {
		return false
	}

	if !v.Path.Equal(other.Path) {
		return false
	}

	if !v.Recursive.Equal(other.Recursive) {
		return false
	}

	if !v.Site.Equal(other.Site) {
		return false
	}

	if !v.Tenant.Equal(other.Tenant) {
		return false
	}

	if !v.UserPname.Equal(other.UserPname) {
		return false
	}

	return true
}

func (v SharepointValue) Type(ctx context.Context) attr.Type {
	return SharepointType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SharepointValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"authority_url": basetypes.StringType{},
		"client_cred":   basetypes.StringType{},
		"client_id":     basetypes.StringType{},
		"path":          basetypes.StringType{},
		"recursive":     basetypes.BoolType{},
		"site":          basetypes.StringType{},
		"tenant":        basetypes.StringType{},
		"user_pname":    basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = SnowflakeType{}

type SnowflakeType struct {
	basetypes.ObjectType
}

func (t SnowflakeType) Equal(o attr.Type) bool {
	other, ok := o.(SnowflakeType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SnowflakeType) String() string {
	return "SnowflakeType"
}

func (t SnowflakeType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	accountAttribute, ok := attributes["account"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`account is missing from object`)

		return nil, diags
	}

	accountVal, ok := accountAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`account expected to be basetypes.StringValue, was: %T`, accountAttribute))
	}

	batchSizeAttribute, ok := attributes["batch_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`batch_size is missing from object`)

		return nil, diags
	}

	batchSizeVal, ok := batchSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`batch_size expected to be basetypes.Int64Value, was: %T`, batchSizeAttribute))
	}

	databaseAttribute, ok := attributes["database"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`database is missing from object`)

		return nil, diags
	}

	databaseVal, ok := databaseAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`database expected to be basetypes.StringValue, was: %T`, databaseAttribute))
	}

	fieldsAttribute, ok := attributes["fields"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fields is missing from object`)

		return nil, diags
	}

	fieldsVal, ok := fieldsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fields expected to be basetypes.ListValue, was: %T`, fieldsAttribute))
	}

	hostAttribute, ok := attributes["host"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`host is missing from object`)

		return nil, diags
	}

	hostVal, ok := hostAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`host expected to be basetypes.StringValue, was: %T`, hostAttribute))
	}

	idColumnAttribute, ok := attributes["id_column"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id_column is missing from object`)

		return nil, diags
	}

	idColumnVal, ok := idColumnAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id_column expected to be basetypes.StringValue, was: %T`, idColumnAttribute))
	}

	passwordAttribute, ok := attributes["password"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`password is missing from object`)

		return nil, diags
	}

	passwordVal, ok := passwordAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`password expected to be basetypes.StringValue, was: %T`, passwordAttribute))
	}

	portAttribute, ok := attributes["port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port is missing from object`)

		return nil, diags
	}

	portVal, ok := portAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port expected to be basetypes.Int64Value, was: %T`, portAttribute))
	}

	roleAttribute, ok := attributes["role"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`role is missing from object`)

		return nil, diags
	}

	roleVal, ok := roleAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`role expected to be basetypes.StringValue, was: %T`, roleAttribute))
	}

	schemaAttribute, ok := attributes["schema"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`schema is missing from object`)

		return nil, diags
	}

	schemaVal, ok := schemaAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`schema expected to be basetypes.StringValue, was: %T`, schemaAttribute))
	}

	tableNameAttribute, ok := attributes["table_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`table_name is missing from object`)

		return nil, diags
	}

	tableNameVal, ok := tableNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`table_name expected to be basetypes.StringValue, was: %T`, tableNameAttribute))
	}

	userAttribute, ok := attributes["user"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`user is missing from object`)

		return nil, diags
	}

	userVal, ok := userAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`user expected to be basetypes.StringValue, was: %T`, userAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SnowflakeValue{
		Account:   accountVal,
		BatchSize: batchSizeVal,
		Database:  databaseVal,
		Fields:    fieldsVal,
		Host:      hostVal,
		IdColumn:  idColumnVal,
		Password:  passwordVal,
		Port:      portVal,
		Role:      roleVal,
		Schema:    schemaVal,
		TableName: tableNameVal,
		User:      userVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewSnowflakeValueNull() SnowflakeValue {
	return SnowflakeValue{
		state: attr.ValueStateNull,
	}
}

func NewSnowflakeValueUnknown() SnowflakeValue {
	return SnowflakeValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSnowflakeValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SnowflakeValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SnowflakeValue Attribute Value",
				"While creating a SnowflakeValue value, a missing attribute value was detected. "+
					"A SnowflakeValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SnowflakeValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SnowflakeValue Attribute Type",
				"While creating a SnowflakeValue value, an invalid attribute value was detected. "+
					"A SnowflakeValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SnowflakeValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SnowflakeValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SnowflakeValue Attribute Value",
				"While creating a SnowflakeValue value, an extra attribute value was detected. "+
					"A SnowflakeValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SnowflakeValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSnowflakeValueUnknown(), diags
	}

	accountAttribute, ok := attributes["account"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`account is missing from object`)

		return NewSnowflakeValueUnknown(), diags
	}

	accountVal, ok := accountAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`account expected to be basetypes.StringValue, was: %T`, accountAttribute))
	}

	batchSizeAttribute, ok := attributes["batch_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`batch_size is missing from object`)

		return NewSnowflakeValueUnknown(), diags
	}

	batchSizeVal, ok := batchSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`batch_size expected to be basetypes.Int64Value, was: %T`, batchSizeAttribute))
	}

	databaseAttribute, ok := attributes["database"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`database is missing from object`)

		return NewSnowflakeValueUnknown(), diags
	}

	databaseVal, ok := databaseAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`database expected to be basetypes.StringValue, was: %T`, databaseAttribute))
	}

	fieldsAttribute, ok := attributes["fields"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fields is missing from object`)

		return NewSnowflakeValueUnknown(), diags
	}

	fieldsVal, ok := fieldsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fields expected to be basetypes.ListValue, was: %T`, fieldsAttribute))
	}

	hostAttribute, ok := attributes["host"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`host is missing from object`)

		return NewSnowflakeValueUnknown(), diags
	}

	hostVal, ok := hostAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`host expected to be basetypes.StringValue, was: %T`, hostAttribute))
	}

	idColumnAttribute, ok := attributes["id_column"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id_column is missing from object`)

		return NewSnowflakeValueUnknown(), diags
	}

	idColumnVal, ok := idColumnAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id_column expected to be basetypes.StringValue, was: %T`, idColumnAttribute))
	}

	passwordAttribute, ok := attributes["password"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`password is missing from object`)

		return NewSnowflakeValueUnknown(), diags
	}

	passwordVal, ok := passwordAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`password expected to be basetypes.StringValue, was: %T`, passwordAttribute))
	}

	portAttribute, ok := attributes["port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port is missing from object`)

		return NewSnowflakeValueUnknown(), diags
	}

	portVal, ok := portAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port expected to be basetypes.Int64Value, was: %T`, portAttribute))
	}

	roleAttribute, ok := attributes["role"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`role is missing from object`)

		return NewSnowflakeValueUnknown(), diags
	}

	roleVal, ok := roleAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`role expected to be basetypes.StringValue, was: %T`, roleAttribute))
	}

	schemaAttribute, ok := attributes["schema"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`schema is missing from object`)

		return NewSnowflakeValueUnknown(), diags
	}

	schemaVal, ok := schemaAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`schema expected to be basetypes.StringValue, was: %T`, schemaAttribute))
	}

	tableNameAttribute, ok := attributes["table_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`table_name is missing from object`)

		return NewSnowflakeValueUnknown(), diags
	}

	tableNameVal, ok := tableNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`table_name expected to be basetypes.StringValue, was: %T`, tableNameAttribute))
	}

	userAttribute, ok := attributes["user"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`user is missing from object`)

		return NewSnowflakeValueUnknown(), diags
	}

	userVal, ok := userAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`user expected to be basetypes.StringValue, was: %T`, userAttribute))
	}

	if diags.HasError() {
		return NewSnowflakeValueUnknown(), diags
	}

	return SnowflakeValue{
		Account:   accountVal,
		BatchSize: batchSizeVal,
		Database:  databaseVal,
		Fields:    fieldsVal,
		Host:      hostVal,
		IdColumn:  idColumnVal,
		Password:  passwordVal,
		Port:      portVal,
		Role:      roleVal,
		Schema:    schemaVal,
		TableName: tableNameVal,
		User:      userVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewSnowflakeValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SnowflakeValue {
	object, diags := NewSnowflakeValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSnowflakeValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SnowflakeType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSnowflakeValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSnowflakeValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSnowflakeValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSnowflakeValueMust(SnowflakeValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SnowflakeType) ValueType(ctx context.Context) attr.Value {
	return SnowflakeValue{}
}

var _ basetypes.ObjectValuable = SnowflakeValue{}

type SnowflakeValue struct {
	Account   basetypes.StringValue `tfsdk:"account"`
	BatchSize basetypes.Int64Value  `tfsdk:"batch_size"`
	Database  basetypes.StringValue `tfsdk:"database"`
	Fields    basetypes.ListValue   `tfsdk:"fields"`
	Host      basetypes.StringValue `tfsdk:"host"`
	IdColumn  basetypes.StringValue `tfsdk:"id_column"`
	Password  basetypes.StringValue `tfsdk:"password"`
	Port      basetypes.Int64Value  `tfsdk:"port"`
	Role      basetypes.StringValue `tfsdk:"role"`
	Schema    basetypes.StringValue `tfsdk:"schema"`
	TableName basetypes.StringValue `tfsdk:"table_name"`
	User      basetypes.StringValue `tfsdk:"user"`
	state     attr.ValueState
}

func (v SnowflakeValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 12)

	var val tftypes.Value
	var err error

	attrTypes["account"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["batch_size"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["database"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["fields"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["host"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["id_column"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["password"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["port"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["role"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["schema"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["table_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["user"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 12)

		val, err = v.Account.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["account"] = val

		val, err = v.BatchSize.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["batch_size"] = val

		val, err = v.Database.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["database"] = val

		val, err = v.Fields.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["fields"] = val

		val, err = v.Host.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["host"] = val

		val, err = v.IdColumn.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id_column"] = val

		val, err = v.Password.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["password"] = val

		val, err = v.Port.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port"] = val

		val, err = v.Role.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["role"] = val

		val, err = v.Schema.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["schema"] = val

		val, err = v.TableName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["table_name"] = val

		val, err = v.User.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["user"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SnowflakeValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SnowflakeValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SnowflakeValue) String() string {
	return "SnowflakeValue"
}

func (v SnowflakeValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var fieldsVal basetypes.ListValue
	switch {
	case v.Fields.IsUnknown():
		fieldsVal = types.ListUnknown(types.StringType)
	case v.Fields.IsNull():
		fieldsVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		fieldsVal, d = types.ListValue(types.StringType, v.Fields.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"account":    basetypes.StringType{},
			"batch_size": basetypes.Int64Type{},
			"database":   basetypes.StringType{},
			"fields": basetypes.ListType{
				ElemType: types.StringType,
			},
			"host":       basetypes.StringType{},
			"id_column":  basetypes.StringType{},
			"password":   basetypes.StringType{},
			"port":       basetypes.Int64Type{},
			"role":       basetypes.StringType{},
			"schema":     basetypes.StringType{},
			"table_name": basetypes.StringType{},
			"user":       basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"account":    basetypes.StringType{},
		"batch_size": basetypes.Int64Type{},
		"database":   basetypes.StringType{},
		"fields": basetypes.ListType{
			ElemType: types.StringType,
		},
		"host":       basetypes.StringType{},
		"id_column":  basetypes.StringType{},
		"password":   basetypes.StringType{},
		"port":       basetypes.Int64Type{},
		"role":       basetypes.StringType{},
		"schema":     basetypes.StringType{},
		"table_name": basetypes.StringType{},
		"user":       basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"account":    v.Account,
			"batch_size": v.BatchSize,
			"database":   v.Database,
			"fields":     fieldsVal,
			"host":       v.Host,
			"id_column":  v.IdColumn,
			"password":   v.Password,
			"port":       v.Port,
			"role":       v.Role,
			"schema":     v.Schema,
			"table_name": v.TableName,
			"user":       v.User,
		})

	return objVal, diags
}

func (v SnowflakeValue) Equal(o attr.Value) bool {
	other, ok := o.(SnowflakeValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Account.Equal(other.Account) {
		return false
	}

	if !v.BatchSize.Equal(other.BatchSize) {
		return false
	}

	if !v.Database.Equal(other.Database) {
		return false
	}

	if !v.Fields.Equal(other.Fields) {
		return false
	}

	if !v.Host.Equal(other.Host) {
		return false
	}

	if !v.IdColumn.Equal(other.IdColumn) {
		return false
	}

	if !v.Password.Equal(other.Password) {
		return false
	}

	if !v.Port.Equal(other.Port) {
		return false
	}

	if !v.Role.Equal(other.Role) {
		return false
	}

	if !v.Schema.Equal(other.Schema) {
		return false
	}

	if !v.TableName.Equal(other.TableName) {
		return false
	}

	if !v.User.Equal(other.User) {
		return false
	}

	return true
}

func (v SnowflakeValue) Type(ctx context.Context) attr.Type {
	return SnowflakeType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SnowflakeValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"account":    basetypes.StringType{},
		"batch_size": basetypes.Int64Type{},
		"database":   basetypes.StringType{},
		"fields": basetypes.ListType{
			ElemType: types.StringType,
		},
		"host":       basetypes.StringType{},
		"id_column":  basetypes.StringType{},
		"password":   basetypes.StringType{},
		"port":       basetypes.Int64Type{},
		"role":       basetypes.StringType{},
		"schema":     basetypes.StringType{},
		"table_name": basetypes.StringType{},
		"user":       basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = ZendeskType{}

type ZendeskType struct {
	basetypes.ObjectType
}

func (t ZendeskType) Equal(o attr.Type) bool {
	other, ok := o.(ZendeskType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ZendeskType) String() string {
	return "ZendeskType"
}

func (t ZendeskType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	apiTokenAttribute, ok := attributes["api_token"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`api_token is missing from object`)

		return nil, diags
	}

	apiTokenVal, ok := apiTokenAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`api_token expected to be basetypes.StringValue, was: %T`, apiTokenAttribute))
	}

	batchSizeAttribute, ok := attributes["batch_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`batch_size is missing from object`)

		return nil, diags
	}

	batchSizeVal, ok := batchSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`batch_size expected to be basetypes.Int64Value, was: %T`, batchSizeAttribute))
	}

	emailAttribute, ok := attributes["email"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`email is missing from object`)

		return nil, diags
	}

	emailVal, ok := emailAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`email expected to be basetypes.StringValue, was: %T`, emailAttribute))
	}

	itemTypeAttribute, ok := attributes["item_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`item_type is missing from object`)

		return nil, diags
	}

	itemTypeVal, ok := itemTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`item_type expected to be basetypes.StringValue, was: %T`, itemTypeAttribute))
	}

	subdomainAttribute, ok := attributes["subdomain"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subdomain is missing from object`)

		return nil, diags
	}

	subdomainVal, ok := subdomainAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subdomain expected to be basetypes.StringValue, was: %T`, subdomainAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ZendeskValue{
		ApiToken:  apiTokenVal,
		BatchSize: batchSizeVal,
		Email:     emailVal,
		ItemType:  itemTypeVal,
		Subdomain: subdomainVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewZendeskValueNull() ZendeskValue {
	return ZendeskValue{
		state: attr.ValueStateNull,
	}
}

func NewZendeskValueUnknown() ZendeskValue {
	return ZendeskValue{
		state: attr.ValueStateUnknown,
	}
}

func NewZendeskValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ZendeskValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ZendeskValue Attribute Value",
				"While creating a ZendeskValue value, a missing attribute value was detected. "+
					"A ZendeskValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ZendeskValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ZendeskValue Attribute Type",
				"While creating a ZendeskValue value, an invalid attribute value was detected. "+
					"A ZendeskValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ZendeskValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ZendeskValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ZendeskValue Attribute Value",
				"While creating a ZendeskValue value, an extra attribute value was detected. "+
					"A ZendeskValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ZendeskValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewZendeskValueUnknown(), diags
	}

	apiTokenAttribute, ok := attributes["api_token"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`api_token is missing from object`)

		return NewZendeskValueUnknown(), diags
	}

	apiTokenVal, ok := apiTokenAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`api_token expected to be basetypes.StringValue, was: %T`, apiTokenAttribute))
	}

	batchSizeAttribute, ok := attributes["batch_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`batch_size is missing from object`)

		return NewZendeskValueUnknown(), diags
	}

	batchSizeVal, ok := batchSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`batch_size expected to be basetypes.Int64Value, was: %T`, batchSizeAttribute))
	}

	emailAttribute, ok := attributes["email"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`email is missing from object`)

		return NewZendeskValueUnknown(), diags
	}

	emailVal, ok := emailAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`email expected to be basetypes.StringValue, was: %T`, emailAttribute))
	}

	itemTypeAttribute, ok := attributes["item_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`item_type is missing from object`)

		return NewZendeskValueUnknown(), diags
	}

	itemTypeVal, ok := itemTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`item_type expected to be basetypes.StringValue, was: %T`, itemTypeAttribute))
	}

	subdomainAttribute, ok := attributes["subdomain"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subdomain is missing from object`)

		return NewZendeskValueUnknown(), diags
	}

	subdomainVal, ok := subdomainAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subdomain expected to be basetypes.StringValue, was: %T`, subdomainAttribute))
	}

	if diags.HasError() {
		return NewZendeskValueUnknown(), diags
	}

	return ZendeskValue{
		ApiToken:  apiTokenVal,
		BatchSize: batchSizeVal,
		Email:     emailVal,
		ItemType:  itemTypeVal,
		Subdomain: subdomainVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewZendeskValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ZendeskValue {
	object, diags := NewZendeskValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewZendeskValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ZendeskType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewZendeskValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewZendeskValueUnknown(), nil
	}

	if in.IsNull() {
		return NewZendeskValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewZendeskValueMust(ZendeskValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ZendeskType) ValueType(ctx context.Context) attr.Value {
	return ZendeskValue{}
}

var _ basetypes.ObjectValuable = ZendeskValue{}

type ZendeskValue struct {
	ApiToken  basetypes.StringValue `tfsdk:"api_token"`
	BatchSize basetypes.Int64Value  `tfsdk:"batch_size"`
	Email     basetypes.StringValue `tfsdk:"email"`
	ItemType  basetypes.StringValue `tfsdk:"item_type"`
	Subdomain basetypes.StringValue `tfsdk:"subdomain"`
	state     attr.ValueState
}

func (v ZendeskValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["api_token"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["batch_size"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["email"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["item_type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["subdomain"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.ApiToken.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["api_token"] = val

		val, err = v.BatchSize.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["batch_size"] = val

		val, err = v.Email.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["email"] = val

		val, err = v.ItemType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["item_type"] = val

		val, err = v.Subdomain.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["subdomain"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ZendeskValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ZendeskValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ZendeskValue) String() string {
	return "ZendeskValue"
}

func (v ZendeskValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"api_token":  basetypes.StringType{},
		"batch_size": basetypes.Int64Type{},
		"email":      basetypes.StringType{},
		"item_type":  basetypes.StringType{},
		"subdomain":  basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"api_token":  v.ApiToken,
			"batch_size": v.BatchSize,
			"email":      v.Email,
			"item_type":  v.ItemType,
			"subdomain":  v.Subdomain,
		})

	return objVal, diags
}

func (v ZendeskValue) Equal(o attr.Value) bool {
	other, ok := o.(ZendeskValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ApiToken.Equal(other.ApiToken) {
		return false
	}

	if !v.BatchSize.Equal(other.BatchSize) {
		return false
	}

	if !v.Email.Equal(other.Email) {
		return false
	}

	if !v.ItemType.Equal(other.ItemType) {
		return false
	}

	if !v.Subdomain.Equal(other.Subdomain) {
		return false
	}

	return true
}

func (v ZendeskValue) Type(ctx context.Context) attr.Type {
	return ZendeskType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ZendeskValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"api_token":  basetypes.StringType{},
		"batch_size": basetypes.Int64Type{},
		"email":      basetypes.StringType{},
		"item_type":  basetypes.StringType{},
		"subdomain":  basetypes.StringType{},
	}
}
