// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package resource_destination

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
)

func DestinationResourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"astradb": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"api_endpoint": schema.StringAttribute{
						Required: true,
					},
					"batch_size": schema.Int64Attribute{
						Required: true,
					},
					"collection_name": schema.StringAttribute{
						Required: true,
					},
					"keyspace": schema.StringAttribute{
						Optional: true,
					},
					"token": schema.StringAttribute{
						Required: true,
					},
				},
				CustomType: AstradbType{
					ObjectType: types.ObjectType{
						AttrTypes: AstradbValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
			},
			"azure_ai_search": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"endpoint": schema.StringAttribute{
						Required: true,
					},
					"index": schema.StringAttribute{
						Required: true,
					},
					"key": schema.StringAttribute{
						Required: true,
					},
				},
				CustomType: AzureAiSearchType{
					ObjectType: types.ObjectType{
						AttrTypes: AzureAiSearchValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
			},
			"couchbase": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"batch_size": schema.Int64Attribute{
						Required: true,
					},
					"bucket": schema.StringAttribute{
						Required: true,
					},
					"collection": schema.StringAttribute{
						Optional: true,
					},
					"collection_id": schema.StringAttribute{
						Required: true,
					},
					"connection_string": schema.StringAttribute{
						Required: true,
					},
					"password": schema.StringAttribute{
						Required: true,
					},
					"scope": schema.StringAttribute{
						Optional: true,
					},
					"username": schema.StringAttribute{
						Required: true,
					},
				},
				CustomType: CouchbaseType{
					ObjectType: types.ObjectType{
						AttrTypes: CouchbaseValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
			},
			"created_at": schema.StringAttribute{
				Computed: true,
			},
			"databricks_volume_delta_tables": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"catalog": schema.StringAttribute{
						Required: true,
					},
					"client_id": schema.StringAttribute{
						Optional: true,
					},
					"client_secret": schema.StringAttribute{
						Optional: true,
					},
					"database": schema.StringAttribute{
						Optional: true,
					},
					"http_path": schema.StringAttribute{
						Required: true,
					},
					"schema": schema.StringAttribute{
						Required: true,
					},
					"server_hostname": schema.StringAttribute{
						Required: true,
					},
					"table_name": schema.StringAttribute{
						Optional: true,
					},
					"token": schema.StringAttribute{
						Optional: true,
					},
					"volume": schema.StringAttribute{
						Required: true,
					},
					"volume_path": schema.StringAttribute{
						Optional: true,
					},
				},
				CustomType: DatabricksVolumeDeltaTablesType{
					ObjectType: types.ObjectType{
						AttrTypes: DatabricksVolumeDeltaTablesValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
			},
			"databricks_volumes": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"catalog": schema.StringAttribute{
						Required: true,
					},
					"client_id": schema.StringAttribute{
						Required: true,
					},
					"client_secret": schema.StringAttribute{
						Required: true,
					},
					"host": schema.StringAttribute{
						Required: true,
					},
					"schema": schema.StringAttribute{
						Optional: true,
					},
					"volume": schema.StringAttribute{
						Required: true,
					},
					"volume_path": schema.StringAttribute{
						Required: true,
					},
				},
				CustomType: DatabricksVolumesType{
					ObjectType: types.ObjectType{
						AttrTypes: DatabricksVolumesValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
			},
			"delta_table": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"aws_access_key_id": schema.StringAttribute{
						Required: true,
					},
					"aws_region": schema.StringAttribute{
						Required: true,
					},
					"aws_secret_access_key": schema.StringAttribute{
						Required: true,
					},
					"table_uri": schema.StringAttribute{
						Required: true,
					},
				},
				CustomType: DeltaTableType{
					ObjectType: types.ObjectType{
						AttrTypes: DeltaTableValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
			},
			"elasticsearch": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"es_api_key": schema.StringAttribute{
						Required: true,
					},
					"hosts": schema.ListAttribute{
						ElementType: types.StringType,
						Required:    true,
					},
					"index_name": schema.StringAttribute{
						Required: true,
					},
				},
				CustomType: ElasticsearchType{
					ObjectType: types.ObjectType{
						AttrTypes: ElasticsearchValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
			},
			"gcs": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"remote_url": schema.StringAttribute{
						Required: true,
					},
					"service_account_key": schema.StringAttribute{
						Required: true,
					},
				},
				CustomType: GcsType{
					ObjectType: types.ObjectType{
						AttrTypes: GcsValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
			},
			"ibm_watsonx_s3": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"access_key_id": schema.StringAttribute{
						Required: true,
					},
					"catalog": schema.StringAttribute{
						Required: true,
					},
					"iam_api_key": schema.StringAttribute{
						Required: true,
					},
					"iceberg_endpoint": schema.StringAttribute{
						Required: true,
					},
					"max_retries": schema.Int64Attribute{
						Optional: true,
					},
					"max_retries_connection": schema.Int64Attribute{
						Optional: true,
					},
					"namespace": schema.StringAttribute{
						Required: true,
					},
					"object_storage_endpoint": schema.StringAttribute{
						Required: true,
					},
					"object_storage_region": schema.StringAttribute{
						Required: true,
					},
					"record_id_key": schema.StringAttribute{
						Optional: true,
					},
					"secret_access_key": schema.StringAttribute{
						Required: true,
					},
					"table": schema.StringAttribute{
						Required: true,
					},
				},
				CustomType: IbmWatsonxS3Type{
					ObjectType: types.ObjectType{
						AttrTypes: IbmWatsonxS3Value{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
			},
			"id": schema.StringAttribute{
				Computed: true,
			},
			"kafka_cloud": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"batch_size": schema.Int64Attribute{
						Optional: true,
					},
					"bootstrap_servers": schema.StringAttribute{
						Required: true,
					},
					"group_id": schema.StringAttribute{
						Optional: true,
					},
					"kafka_api_key": schema.StringAttribute{
						Required: true,
					},
					"port": schema.Int64Attribute{
						Optional: true,
					},
					"secret": schema.StringAttribute{
						Required: true,
					},
					"topic": schema.StringAttribute{
						Required: true,
					},
				},
				CustomType: KafkaCloudType{
					ObjectType: types.ObjectType{
						AttrTypes: KafkaCloudValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
			},
			"milvus": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"collection_name": schema.StringAttribute{
						Required: true,
					},
					"db_name": schema.StringAttribute{
						Optional: true,
					},
					"password": schema.StringAttribute{
						Optional: true,
					},
					"record_id_key": schema.StringAttribute{
						Required: true,
					},
					"token": schema.StringAttribute{
						Optional: true,
					},
					"uri": schema.StringAttribute{
						Required: true,
					},
					"user": schema.StringAttribute{
						Optional: true,
					},
				},
				CustomType: MilvusType{
					ObjectType: types.ObjectType{
						AttrTypes: MilvusValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
			},
			"mongodb": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"collection": schema.StringAttribute{
						Required: true,
					},
					"database": schema.StringAttribute{
						Required: true,
					},
					"uri": schema.StringAttribute{
						Required: true,
					},
				},
				CustomType: MongodbType{
					ObjectType: types.ObjectType{
						AttrTypes: MongodbValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
			},
			"motherduck": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"account": schema.StringAttribute{
						Required: true,
					},
					"batch_size": schema.Int64Attribute{
						Optional: true,
					},
					"database": schema.StringAttribute{
						Required: true,
					},
					"host": schema.StringAttribute{
						Required: true,
					},
					"password": schema.StringAttribute{
						Required: true,
					},
					"port": schema.Int64Attribute{
						Optional: true,
					},
					"record_id_key": schema.StringAttribute{
						Optional: true,
					},
					"role": schema.StringAttribute{
						Required: true,
					},
					"schema": schema.StringAttribute{
						Optional: true,
					},
					"table_name": schema.StringAttribute{
						Optional: true,
					},
					"user": schema.StringAttribute{
						Required: true,
					},
				},
				CustomType: MotherduckType{
					ObjectType: types.ObjectType{
						AttrTypes: MotherduckValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
			},
			"name": schema.StringAttribute{
				Required: true,
			},
			"neo4j": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"batch_size": schema.Int64Attribute{
						Optional: true,
					},
					"database": schema.StringAttribute{
						Required: true,
					},
					"password": schema.StringAttribute{
						Required: true,
					},
					"uri": schema.StringAttribute{
						Required: true,
					},
					"username": schema.StringAttribute{
						Required: true,
					},
				},
				CustomType: Neo4jType{
					ObjectType: types.ObjectType{
						AttrTypes: Neo4jValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
			},
			"onedrive": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"authority_url": schema.StringAttribute{
						Required: true,
					},
					"client_cred": schema.StringAttribute{
						Required: true,
					},
					"client_id": schema.StringAttribute{
						Required: true,
					},
					"path": schema.StringAttribute{
						Required: true,
					},
					"recursive": schema.BoolAttribute{
						Optional: true,
					},
					"tenant": schema.StringAttribute{
						Required: true,
					},
					"user_pname": schema.StringAttribute{
						Required: true,
					},
				},
				CustomType: OnedriveType{
					ObjectType: types.ObjectType{
						AttrTypes: OnedriveValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
			},
			"pinecone": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"api_key": schema.StringAttribute{
						Required: true,
					},
					"batch_size": schema.Int64Attribute{
						Optional: true,
					},
					"index_name": schema.StringAttribute{
						Required: true,
					},
					"namespace": schema.StringAttribute{
						Required: true,
					},
				},
				CustomType: PineconeType{
					ObjectType: types.ObjectType{
						AttrTypes: PineconeValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
			},
			"postgres": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"batch_size": schema.Int64Attribute{
						Required: true,
					},
					"database": schema.StringAttribute{
						Required: true,
					},
					"host": schema.StringAttribute{
						Required: true,
					},
					"password": schema.StringAttribute{
						Required: true,
					},
					"port": schema.Int64Attribute{
						Required: true,
					},
					"table_name": schema.StringAttribute{
						Required: true,
					},
					"username": schema.StringAttribute{
						Required: true,
					},
				},
				CustomType: PostgresType{
					ObjectType: types.ObjectType{
						AttrTypes: PostgresValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
			},
			"qdrant_cloud": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"api_key": schema.StringAttribute{
						Required: true,
					},
					"batch_size": schema.Int64Attribute{
						Optional: true,
					},
					"collection_name": schema.StringAttribute{
						Required: true,
					},
					"url": schema.StringAttribute{
						Required: true,
					},
				},
				CustomType: QdrantCloudType{
					ObjectType: types.ObjectType{
						AttrTypes: QdrantCloudValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
			},
			"redis": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"batch_size": schema.Int64Attribute{
						Optional: true,
					},
					"database": schema.Int64Attribute{
						Optional: true,
					},
					"host": schema.StringAttribute{
						Required: true,
					},
					"password": schema.StringAttribute{
						Optional: true,
					},
					"port": schema.Int64Attribute{
						Optional: true,
					},
					"ssl": schema.BoolAttribute{
						Optional: true,
					},
					"uri": schema.StringAttribute{
						Optional: true,
					},
					"username": schema.StringAttribute{
						Optional: true,
					},
				},
				CustomType: RedisType{
					ObjectType: types.ObjectType{
						AttrTypes: RedisValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
			},
			"s3": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"anonymous": schema.BoolAttribute{
						Optional: true,
						Computed: true,
					},
					"endpoint_url": schema.StringAttribute{
						Optional: true,
					},
					"key": schema.StringAttribute{
						Optional: true,
					},
					"recursive": schema.BoolAttribute{
						Optional: true,
						Computed: true,
					},
					"remote_url": schema.StringAttribute{
						Required: true,
					},
					"secret": schema.StringAttribute{
						Optional: true,
					},
					"token": schema.StringAttribute{
						Optional: true,
					},
				},
				CustomType: S3Type{
					ObjectType: types.ObjectType{
						AttrTypes: S3Value{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
			},
			"snowflake": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"account": schema.StringAttribute{
						Required: true,
					},
					"batch_size": schema.Int64Attribute{
						Optional: true,
					},
					"database": schema.StringAttribute{
						Required: true,
					},
					"host": schema.StringAttribute{
						Required: true,
					},
					"password": schema.StringAttribute{
						Required: true,
					},
					"port": schema.Int64Attribute{
						Optional: true,
					},
					"record_id_key": schema.StringAttribute{
						Optional: true,
					},
					"role": schema.StringAttribute{
						Required: true,
					},
					"schema": schema.StringAttribute{
						Optional: true,
					},
					"table_name": schema.StringAttribute{
						Required: true,
					},
					"user": schema.StringAttribute{
						Required: true,
					},
				},
				CustomType: SnowflakeType{
					ObjectType: types.ObjectType{
						AttrTypes: SnowflakeValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
			},
			"updated_at": schema.StringAttribute{
				Computed: true,
			},
			"weaviate_cloud": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"api_key": schema.StringAttribute{
						Required: true,
					},
					"cluster_url": schema.StringAttribute{
						Required: true,
					},
					"collection": schema.StringAttribute{
						Optional: true,
					},
				},
				CustomType: WeaviateCloudType{
					ObjectType: types.ObjectType{
						AttrTypes: WeaviateCloudValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
			},
		},
	}
}

type DestinationModel struct {
	Astradb                     AstradbValue                     `tfsdk:"astradb"`
	AzureAiSearch               AzureAiSearchValue               `tfsdk:"azure_ai_search"`
	Couchbase                   CouchbaseValue                   `tfsdk:"couchbase"`
	CreatedAt                   types.String                     `tfsdk:"created_at"`
	DatabricksVolumeDeltaTables DatabricksVolumeDeltaTablesValue `tfsdk:"databricks_volume_delta_tables"`
	DatabricksVolumes           DatabricksVolumesValue           `tfsdk:"databricks_volumes"`
	DeltaTable                  DeltaTableValue                  `tfsdk:"delta_table"`
	Elasticsearch               ElasticsearchValue               `tfsdk:"elasticsearch"`
	Gcs                         GcsValue                         `tfsdk:"gcs"`
	IbmWatsonxS3                IbmWatsonxS3Value                `tfsdk:"ibm_watsonx_s3"`
	Id                          types.String                     `tfsdk:"id"`
	KafkaCloud                  KafkaCloudValue                  `tfsdk:"kafka_cloud"`
	Milvus                      MilvusValue                      `tfsdk:"milvus"`
	Mongodb                     MongodbValue                     `tfsdk:"mongodb"`
	Motherduck                  MotherduckValue                  `tfsdk:"motherduck"`
	Name                        types.String                     `tfsdk:"name"`
	Neo4j                       Neo4jValue                       `tfsdk:"neo4j"`
	Onedrive                    OnedriveValue                    `tfsdk:"onedrive"`
	Pinecone                    PineconeValue                    `tfsdk:"pinecone"`
	Postgres                    PostgresValue                    `tfsdk:"postgres"`
	QdrantCloud                 QdrantCloudValue                 `tfsdk:"qdrant_cloud"`
	Redis                       RedisValue                       `tfsdk:"redis"`
	S3                          S3Value                          `tfsdk:"s3"`
	Snowflake                   SnowflakeValue                   `tfsdk:"snowflake"`
	UpdatedAt                   types.String                     `tfsdk:"updated_at"`
	WeaviateCloud               WeaviateCloudValue               `tfsdk:"weaviate_cloud"`
}

var _ basetypes.ObjectTypable = AstradbType{}

type AstradbType struct {
	basetypes.ObjectType
}

func (t AstradbType) Equal(o attr.Type) bool {
	other, ok := o.(AstradbType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AstradbType) String() string {
	return "AstradbType"
}

func (t AstradbType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	apiEndpointAttribute, ok := attributes["api_endpoint"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`api_endpoint is missing from object`)

		return nil, diags
	}

	apiEndpointVal, ok := apiEndpointAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`api_endpoint expected to be basetypes.StringValue, was: %T`, apiEndpointAttribute))
	}

	batchSizeAttribute, ok := attributes["batch_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`batch_size is missing from object`)

		return nil, diags
	}

	batchSizeVal, ok := batchSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`batch_size expected to be basetypes.Int64Value, was: %T`, batchSizeAttribute))
	}

	collectionNameAttribute, ok := attributes["collection_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`collection_name is missing from object`)

		return nil, diags
	}

	collectionNameVal, ok := collectionNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`collection_name expected to be basetypes.StringValue, was: %T`, collectionNameAttribute))
	}

	keyspaceAttribute, ok := attributes["keyspace"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keyspace is missing from object`)

		return nil, diags
	}

	keyspaceVal, ok := keyspaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keyspace expected to be basetypes.StringValue, was: %T`, keyspaceAttribute))
	}

	tokenAttribute, ok := attributes["token"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`token is missing from object`)

		return nil, diags
	}

	tokenVal, ok := tokenAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`token expected to be basetypes.StringValue, was: %T`, tokenAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AstradbValue{
		ApiEndpoint:    apiEndpointVal,
		BatchSize:      batchSizeVal,
		CollectionName: collectionNameVal,
		Keyspace:       keyspaceVal,
		Token:          tokenVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewAstradbValueNull() AstradbValue {
	return AstradbValue{
		state: attr.ValueStateNull,
	}
}

func NewAstradbValueUnknown() AstradbValue {
	return AstradbValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAstradbValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AstradbValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AstradbValue Attribute Value",
				"While creating a AstradbValue value, a missing attribute value was detected. "+
					"A AstradbValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AstradbValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AstradbValue Attribute Type",
				"While creating a AstradbValue value, an invalid attribute value was detected. "+
					"A AstradbValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AstradbValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AstradbValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AstradbValue Attribute Value",
				"While creating a AstradbValue value, an extra attribute value was detected. "+
					"A AstradbValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AstradbValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAstradbValueUnknown(), diags
	}

	apiEndpointAttribute, ok := attributes["api_endpoint"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`api_endpoint is missing from object`)

		return NewAstradbValueUnknown(), diags
	}

	apiEndpointVal, ok := apiEndpointAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`api_endpoint expected to be basetypes.StringValue, was: %T`, apiEndpointAttribute))
	}

	batchSizeAttribute, ok := attributes["batch_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`batch_size is missing from object`)

		return NewAstradbValueUnknown(), diags
	}

	batchSizeVal, ok := batchSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`batch_size expected to be basetypes.Int64Value, was: %T`, batchSizeAttribute))
	}

	collectionNameAttribute, ok := attributes["collection_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`collection_name is missing from object`)

		return NewAstradbValueUnknown(), diags
	}

	collectionNameVal, ok := collectionNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`collection_name expected to be basetypes.StringValue, was: %T`, collectionNameAttribute))
	}

	keyspaceAttribute, ok := attributes["keyspace"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keyspace is missing from object`)

		return NewAstradbValueUnknown(), diags
	}

	keyspaceVal, ok := keyspaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keyspace expected to be basetypes.StringValue, was: %T`, keyspaceAttribute))
	}

	tokenAttribute, ok := attributes["token"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`token is missing from object`)

		return NewAstradbValueUnknown(), diags
	}

	tokenVal, ok := tokenAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`token expected to be basetypes.StringValue, was: %T`, tokenAttribute))
	}

	if diags.HasError() {
		return NewAstradbValueUnknown(), diags
	}

	return AstradbValue{
		ApiEndpoint:    apiEndpointVal,
		BatchSize:      batchSizeVal,
		CollectionName: collectionNameVal,
		Keyspace:       keyspaceVal,
		Token:          tokenVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewAstradbValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AstradbValue {
	object, diags := NewAstradbValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAstradbValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AstradbType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAstradbValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAstradbValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAstradbValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAstradbValueMust(AstradbValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AstradbType) ValueType(ctx context.Context) attr.Value {
	return AstradbValue{}
}

var _ basetypes.ObjectValuable = AstradbValue{}

type AstradbValue struct {
	ApiEndpoint    basetypes.StringValue `tfsdk:"api_endpoint"`
	BatchSize      basetypes.Int64Value  `tfsdk:"batch_size"`
	CollectionName basetypes.StringValue `tfsdk:"collection_name"`
	Keyspace       basetypes.StringValue `tfsdk:"keyspace"`
	Token          basetypes.StringValue `tfsdk:"token"`
	state          attr.ValueState
}

func (v AstradbValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["api_endpoint"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["batch_size"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["collection_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["keyspace"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["token"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.ApiEndpoint.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["api_endpoint"] = val

		val, err = v.BatchSize.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["batch_size"] = val

		val, err = v.CollectionName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["collection_name"] = val

		val, err = v.Keyspace.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["keyspace"] = val

		val, err = v.Token.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["token"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AstradbValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AstradbValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AstradbValue) String() string {
	return "AstradbValue"
}

func (v AstradbValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"api_endpoint":    basetypes.StringType{},
		"batch_size":      basetypes.Int64Type{},
		"collection_name": basetypes.StringType{},
		"keyspace":        basetypes.StringType{},
		"token":           basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"api_endpoint":    v.ApiEndpoint,
			"batch_size":      v.BatchSize,
			"collection_name": v.CollectionName,
			"keyspace":        v.Keyspace,
			"token":           v.Token,
		})

	return objVal, diags
}

func (v AstradbValue) Equal(o attr.Value) bool {
	other, ok := o.(AstradbValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ApiEndpoint.Equal(other.ApiEndpoint) {
		return false
	}

	if !v.BatchSize.Equal(other.BatchSize) {
		return false
	}

	if !v.CollectionName.Equal(other.CollectionName) {
		return false
	}

	if !v.Keyspace.Equal(other.Keyspace) {
		return false
	}

	if !v.Token.Equal(other.Token) {
		return false
	}

	return true
}

func (v AstradbValue) Type(ctx context.Context) attr.Type {
	return AstradbType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AstradbValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"api_endpoint":    basetypes.StringType{},
		"batch_size":      basetypes.Int64Type{},
		"collection_name": basetypes.StringType{},
		"keyspace":        basetypes.StringType{},
		"token":           basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = AzureAiSearchType{}

type AzureAiSearchType struct {
	basetypes.ObjectType
}

func (t AzureAiSearchType) Equal(o attr.Type) bool {
	other, ok := o.(AzureAiSearchType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AzureAiSearchType) String() string {
	return "AzureAiSearchType"
}

func (t AzureAiSearchType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	endpointAttribute, ok := attributes["endpoint"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`endpoint is missing from object`)

		return nil, diags
	}

	endpointVal, ok := endpointAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`endpoint expected to be basetypes.StringValue, was: %T`, endpointAttribute))
	}

	indexAttribute, ok := attributes["index"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`index is missing from object`)

		return nil, diags
	}

	indexVal, ok := indexAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`index expected to be basetypes.StringValue, was: %T`, indexAttribute))
	}

	keyAttribute, ok := attributes["key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`key is missing from object`)

		return nil, diags
	}

	keyVal, ok := keyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`key expected to be basetypes.StringValue, was: %T`, keyAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AzureAiSearchValue{
		Endpoint: endpointVal,
		Index:    indexVal,
		Key:      keyVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewAzureAiSearchValueNull() AzureAiSearchValue {
	return AzureAiSearchValue{
		state: attr.ValueStateNull,
	}
}

func NewAzureAiSearchValueUnknown() AzureAiSearchValue {
	return AzureAiSearchValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAzureAiSearchValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AzureAiSearchValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AzureAiSearchValue Attribute Value",
				"While creating a AzureAiSearchValue value, a missing attribute value was detected. "+
					"A AzureAiSearchValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AzureAiSearchValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AzureAiSearchValue Attribute Type",
				"While creating a AzureAiSearchValue value, an invalid attribute value was detected. "+
					"A AzureAiSearchValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AzureAiSearchValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AzureAiSearchValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AzureAiSearchValue Attribute Value",
				"While creating a AzureAiSearchValue value, an extra attribute value was detected. "+
					"A AzureAiSearchValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AzureAiSearchValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAzureAiSearchValueUnknown(), diags
	}

	endpointAttribute, ok := attributes["endpoint"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`endpoint is missing from object`)

		return NewAzureAiSearchValueUnknown(), diags
	}

	endpointVal, ok := endpointAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`endpoint expected to be basetypes.StringValue, was: %T`, endpointAttribute))
	}

	indexAttribute, ok := attributes["index"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`index is missing from object`)

		return NewAzureAiSearchValueUnknown(), diags
	}

	indexVal, ok := indexAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`index expected to be basetypes.StringValue, was: %T`, indexAttribute))
	}

	keyAttribute, ok := attributes["key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`key is missing from object`)

		return NewAzureAiSearchValueUnknown(), diags
	}

	keyVal, ok := keyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`key expected to be basetypes.StringValue, was: %T`, keyAttribute))
	}

	if diags.HasError() {
		return NewAzureAiSearchValueUnknown(), diags
	}

	return AzureAiSearchValue{
		Endpoint: endpointVal,
		Index:    indexVal,
		Key:      keyVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewAzureAiSearchValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AzureAiSearchValue {
	object, diags := NewAzureAiSearchValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAzureAiSearchValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AzureAiSearchType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAzureAiSearchValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAzureAiSearchValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAzureAiSearchValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAzureAiSearchValueMust(AzureAiSearchValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AzureAiSearchType) ValueType(ctx context.Context) attr.Value {
	return AzureAiSearchValue{}
}

var _ basetypes.ObjectValuable = AzureAiSearchValue{}

type AzureAiSearchValue struct {
	Endpoint basetypes.StringValue `tfsdk:"endpoint"`
	Index    basetypes.StringValue `tfsdk:"index"`
	Key      basetypes.StringValue `tfsdk:"key"`
	state    attr.ValueState
}

func (v AzureAiSearchValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["endpoint"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["index"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["key"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Endpoint.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["endpoint"] = val

		val, err = v.Index.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["index"] = val

		val, err = v.Key.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["key"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AzureAiSearchValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AzureAiSearchValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AzureAiSearchValue) String() string {
	return "AzureAiSearchValue"
}

func (v AzureAiSearchValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"endpoint": basetypes.StringType{},
		"index":    basetypes.StringType{},
		"key":      basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"endpoint": v.Endpoint,
			"index":    v.Index,
			"key":      v.Key,
		})

	return objVal, diags
}

func (v AzureAiSearchValue) Equal(o attr.Value) bool {
	other, ok := o.(AzureAiSearchValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Endpoint.Equal(other.Endpoint) {
		return false
	}

	if !v.Index.Equal(other.Index) {
		return false
	}

	if !v.Key.Equal(other.Key) {
		return false
	}

	return true
}

func (v AzureAiSearchValue) Type(ctx context.Context) attr.Type {
	return AzureAiSearchType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AzureAiSearchValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"endpoint": basetypes.StringType{},
		"index":    basetypes.StringType{},
		"key":      basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = CouchbaseType{}

type CouchbaseType struct {
	basetypes.ObjectType
}

func (t CouchbaseType) Equal(o attr.Type) bool {
	other, ok := o.(CouchbaseType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t CouchbaseType) String() string {
	return "CouchbaseType"
}

func (t CouchbaseType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	batchSizeAttribute, ok := attributes["batch_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`batch_size is missing from object`)

		return nil, diags
	}

	batchSizeVal, ok := batchSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`batch_size expected to be basetypes.Int64Value, was: %T`, batchSizeAttribute))
	}

	bucketAttribute, ok := attributes["bucket"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bucket is missing from object`)

		return nil, diags
	}

	bucketVal, ok := bucketAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bucket expected to be basetypes.StringValue, was: %T`, bucketAttribute))
	}

	collectionAttribute, ok := attributes["collection"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`collection is missing from object`)

		return nil, diags
	}

	collectionVal, ok := collectionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`collection expected to be basetypes.StringValue, was: %T`, collectionAttribute))
	}

	collectionIdAttribute, ok := attributes["collection_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`collection_id is missing from object`)

		return nil, diags
	}

	collectionIdVal, ok := collectionIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`collection_id expected to be basetypes.StringValue, was: %T`, collectionIdAttribute))
	}

	connectionStringAttribute, ok := attributes["connection_string"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`connection_string is missing from object`)

		return nil, diags
	}

	connectionStringVal, ok := connectionStringAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`connection_string expected to be basetypes.StringValue, was: %T`, connectionStringAttribute))
	}

	passwordAttribute, ok := attributes["password"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`password is missing from object`)

		return nil, diags
	}

	passwordVal, ok := passwordAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`password expected to be basetypes.StringValue, was: %T`, passwordAttribute))
	}

	scopeAttribute, ok := attributes["scope"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`scope is missing from object`)

		return nil, diags
	}

	scopeVal, ok := scopeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`scope expected to be basetypes.StringValue, was: %T`, scopeAttribute))
	}

	usernameAttribute, ok := attributes["username"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`username is missing from object`)

		return nil, diags
	}

	usernameVal, ok := usernameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`username expected to be basetypes.StringValue, was: %T`, usernameAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return CouchbaseValue{
		BatchSize:        batchSizeVal,
		Bucket:           bucketVal,
		Collection:       collectionVal,
		CollectionId:     collectionIdVal,
		ConnectionString: connectionStringVal,
		Password:         passwordVal,
		Scope:            scopeVal,
		Username:         usernameVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewCouchbaseValueNull() CouchbaseValue {
	return CouchbaseValue{
		state: attr.ValueStateNull,
	}
}

func NewCouchbaseValueUnknown() CouchbaseValue {
	return CouchbaseValue{
		state: attr.ValueStateUnknown,
	}
}

func NewCouchbaseValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (CouchbaseValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing CouchbaseValue Attribute Value",
				"While creating a CouchbaseValue value, a missing attribute value was detected. "+
					"A CouchbaseValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CouchbaseValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid CouchbaseValue Attribute Type",
				"While creating a CouchbaseValue value, an invalid attribute value was detected. "+
					"A CouchbaseValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CouchbaseValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("CouchbaseValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra CouchbaseValue Attribute Value",
				"While creating a CouchbaseValue value, an extra attribute value was detected. "+
					"A CouchbaseValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra CouchbaseValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewCouchbaseValueUnknown(), diags
	}

	batchSizeAttribute, ok := attributes["batch_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`batch_size is missing from object`)

		return NewCouchbaseValueUnknown(), diags
	}

	batchSizeVal, ok := batchSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`batch_size expected to be basetypes.Int64Value, was: %T`, batchSizeAttribute))
	}

	bucketAttribute, ok := attributes["bucket"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bucket is missing from object`)

		return NewCouchbaseValueUnknown(), diags
	}

	bucketVal, ok := bucketAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bucket expected to be basetypes.StringValue, was: %T`, bucketAttribute))
	}

	collectionAttribute, ok := attributes["collection"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`collection is missing from object`)

		return NewCouchbaseValueUnknown(), diags
	}

	collectionVal, ok := collectionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`collection expected to be basetypes.StringValue, was: %T`, collectionAttribute))
	}

	collectionIdAttribute, ok := attributes["collection_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`collection_id is missing from object`)

		return NewCouchbaseValueUnknown(), diags
	}

	collectionIdVal, ok := collectionIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`collection_id expected to be basetypes.StringValue, was: %T`, collectionIdAttribute))
	}

	connectionStringAttribute, ok := attributes["connection_string"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`connection_string is missing from object`)

		return NewCouchbaseValueUnknown(), diags
	}

	connectionStringVal, ok := connectionStringAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`connection_string expected to be basetypes.StringValue, was: %T`, connectionStringAttribute))
	}

	passwordAttribute, ok := attributes["password"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`password is missing from object`)

		return NewCouchbaseValueUnknown(), diags
	}

	passwordVal, ok := passwordAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`password expected to be basetypes.StringValue, was: %T`, passwordAttribute))
	}

	scopeAttribute, ok := attributes["scope"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`scope is missing from object`)

		return NewCouchbaseValueUnknown(), diags
	}

	scopeVal, ok := scopeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`scope expected to be basetypes.StringValue, was: %T`, scopeAttribute))
	}

	usernameAttribute, ok := attributes["username"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`username is missing from object`)

		return NewCouchbaseValueUnknown(), diags
	}

	usernameVal, ok := usernameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`username expected to be basetypes.StringValue, was: %T`, usernameAttribute))
	}

	if diags.HasError() {
		return NewCouchbaseValueUnknown(), diags
	}

	return CouchbaseValue{
		BatchSize:        batchSizeVal,
		Bucket:           bucketVal,
		Collection:       collectionVal,
		CollectionId:     collectionIdVal,
		ConnectionString: connectionStringVal,
		Password:         passwordVal,
		Scope:            scopeVal,
		Username:         usernameVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewCouchbaseValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) CouchbaseValue {
	object, diags := NewCouchbaseValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewCouchbaseValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t CouchbaseType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewCouchbaseValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewCouchbaseValueUnknown(), nil
	}

	if in.IsNull() {
		return NewCouchbaseValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewCouchbaseValueMust(CouchbaseValue{}.AttributeTypes(ctx), attributes), nil
}

func (t CouchbaseType) ValueType(ctx context.Context) attr.Value {
	return CouchbaseValue{}
}

var _ basetypes.ObjectValuable = CouchbaseValue{}

type CouchbaseValue struct {
	BatchSize        basetypes.Int64Value  `tfsdk:"batch_size"`
	Bucket           basetypes.StringValue `tfsdk:"bucket"`
	Collection       basetypes.StringValue `tfsdk:"collection"`
	CollectionId     basetypes.StringValue `tfsdk:"collection_id"`
	ConnectionString basetypes.StringValue `tfsdk:"connection_string"`
	Password         basetypes.StringValue `tfsdk:"password"`
	Scope            basetypes.StringValue `tfsdk:"scope"`
	Username         basetypes.StringValue `tfsdk:"username"`
	state            attr.ValueState
}

func (v CouchbaseValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 8)

	var val tftypes.Value
	var err error

	attrTypes["batch_size"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["bucket"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["collection"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["collection_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["connection_string"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["password"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["scope"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["username"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 8)

		val, err = v.BatchSize.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["batch_size"] = val

		val, err = v.Bucket.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bucket"] = val

		val, err = v.Collection.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["collection"] = val

		val, err = v.CollectionId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["collection_id"] = val

		val, err = v.ConnectionString.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["connection_string"] = val

		val, err = v.Password.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["password"] = val

		val, err = v.Scope.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["scope"] = val

		val, err = v.Username.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["username"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v CouchbaseValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v CouchbaseValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v CouchbaseValue) String() string {
	return "CouchbaseValue"
}

func (v CouchbaseValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"batch_size":        basetypes.Int64Type{},
		"bucket":            basetypes.StringType{},
		"collection":        basetypes.StringType{},
		"collection_id":     basetypes.StringType{},
		"connection_string": basetypes.StringType{},
		"password":          basetypes.StringType{},
		"scope":             basetypes.StringType{},
		"username":          basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"batch_size":        v.BatchSize,
			"bucket":            v.Bucket,
			"collection":        v.Collection,
			"collection_id":     v.CollectionId,
			"connection_string": v.ConnectionString,
			"password":          v.Password,
			"scope":             v.Scope,
			"username":          v.Username,
		})

	return objVal, diags
}

func (v CouchbaseValue) Equal(o attr.Value) bool {
	other, ok := o.(CouchbaseValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.BatchSize.Equal(other.BatchSize) {
		return false
	}

	if !v.Bucket.Equal(other.Bucket) {
		return false
	}

	if !v.Collection.Equal(other.Collection) {
		return false
	}

	if !v.CollectionId.Equal(other.CollectionId) {
		return false
	}

	if !v.ConnectionString.Equal(other.ConnectionString) {
		return false
	}

	if !v.Password.Equal(other.Password) {
		return false
	}

	if !v.Scope.Equal(other.Scope) {
		return false
	}

	if !v.Username.Equal(other.Username) {
		return false
	}

	return true
}

func (v CouchbaseValue) Type(ctx context.Context) attr.Type {
	return CouchbaseType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v CouchbaseValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"batch_size":        basetypes.Int64Type{},
		"bucket":            basetypes.StringType{},
		"collection":        basetypes.StringType{},
		"collection_id":     basetypes.StringType{},
		"connection_string": basetypes.StringType{},
		"password":          basetypes.StringType{},
		"scope":             basetypes.StringType{},
		"username":          basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = DatabricksVolumeDeltaTablesType{}

type DatabricksVolumeDeltaTablesType struct {
	basetypes.ObjectType
}

func (t DatabricksVolumeDeltaTablesType) Equal(o attr.Type) bool {
	other, ok := o.(DatabricksVolumeDeltaTablesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t DatabricksVolumeDeltaTablesType) String() string {
	return "DatabricksVolumeDeltaTablesType"
}

func (t DatabricksVolumeDeltaTablesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	catalogAttribute, ok := attributes["catalog"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`catalog is missing from object`)

		return nil, diags
	}

	catalogVal, ok := catalogAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`catalog expected to be basetypes.StringValue, was: %T`, catalogAttribute))
	}

	clientIdAttribute, ok := attributes["client_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`client_id is missing from object`)

		return nil, diags
	}

	clientIdVal, ok := clientIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`client_id expected to be basetypes.StringValue, was: %T`, clientIdAttribute))
	}

	clientSecretAttribute, ok := attributes["client_secret"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`client_secret is missing from object`)

		return nil, diags
	}

	clientSecretVal, ok := clientSecretAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`client_secret expected to be basetypes.StringValue, was: %T`, clientSecretAttribute))
	}

	databaseAttribute, ok := attributes["database"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`database is missing from object`)

		return nil, diags
	}

	databaseVal, ok := databaseAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`database expected to be basetypes.StringValue, was: %T`, databaseAttribute))
	}

	httpPathAttribute, ok := attributes["http_path"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`http_path is missing from object`)

		return nil, diags
	}

	httpPathVal, ok := httpPathAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`http_path expected to be basetypes.StringValue, was: %T`, httpPathAttribute))
	}

	schemaAttribute, ok := attributes["schema"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`schema is missing from object`)

		return nil, diags
	}

	schemaVal, ok := schemaAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`schema expected to be basetypes.StringValue, was: %T`, schemaAttribute))
	}

	serverHostnameAttribute, ok := attributes["server_hostname"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`server_hostname is missing from object`)

		return nil, diags
	}

	serverHostnameVal, ok := serverHostnameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`server_hostname expected to be basetypes.StringValue, was: %T`, serverHostnameAttribute))
	}

	tableNameAttribute, ok := attributes["table_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`table_name is missing from object`)

		return nil, diags
	}

	tableNameVal, ok := tableNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`table_name expected to be basetypes.StringValue, was: %T`, tableNameAttribute))
	}

	tokenAttribute, ok := attributes["token"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`token is missing from object`)

		return nil, diags
	}

	tokenVal, ok := tokenAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`token expected to be basetypes.StringValue, was: %T`, tokenAttribute))
	}

	volumeAttribute, ok := attributes["volume"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume is missing from object`)

		return nil, diags
	}

	volumeVal, ok := volumeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume expected to be basetypes.StringValue, was: %T`, volumeAttribute))
	}

	volumePathAttribute, ok := attributes["volume_path"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_path is missing from object`)

		return nil, diags
	}

	volumePathVal, ok := volumePathAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_path expected to be basetypes.StringValue, was: %T`, volumePathAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return DatabricksVolumeDeltaTablesValue{
		Catalog:        catalogVal,
		ClientId:       clientIdVal,
		ClientSecret:   clientSecretVal,
		Database:       databaseVal,
		HttpPath:       httpPathVal,
		Schema:         schemaVal,
		ServerHostname: serverHostnameVal,
		TableName:      tableNameVal,
		Token:          tokenVal,
		Volume:         volumeVal,
		VolumePath:     volumePathVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewDatabricksVolumeDeltaTablesValueNull() DatabricksVolumeDeltaTablesValue {
	return DatabricksVolumeDeltaTablesValue{
		state: attr.ValueStateNull,
	}
}

func NewDatabricksVolumeDeltaTablesValueUnknown() DatabricksVolumeDeltaTablesValue {
	return DatabricksVolumeDeltaTablesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDatabricksVolumeDeltaTablesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (DatabricksVolumeDeltaTablesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing DatabricksVolumeDeltaTablesValue Attribute Value",
				"While creating a DatabricksVolumeDeltaTablesValue value, a missing attribute value was detected. "+
					"A DatabricksVolumeDeltaTablesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DatabricksVolumeDeltaTablesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid DatabricksVolumeDeltaTablesValue Attribute Type",
				"While creating a DatabricksVolumeDeltaTablesValue value, an invalid attribute value was detected. "+
					"A DatabricksVolumeDeltaTablesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DatabricksVolumeDeltaTablesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("DatabricksVolumeDeltaTablesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra DatabricksVolumeDeltaTablesValue Attribute Value",
				"While creating a DatabricksVolumeDeltaTablesValue value, an extra attribute value was detected. "+
					"A DatabricksVolumeDeltaTablesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra DatabricksVolumeDeltaTablesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDatabricksVolumeDeltaTablesValueUnknown(), diags
	}

	catalogAttribute, ok := attributes["catalog"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`catalog is missing from object`)

		return NewDatabricksVolumeDeltaTablesValueUnknown(), diags
	}

	catalogVal, ok := catalogAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`catalog expected to be basetypes.StringValue, was: %T`, catalogAttribute))
	}

	clientIdAttribute, ok := attributes["client_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`client_id is missing from object`)

		return NewDatabricksVolumeDeltaTablesValueUnknown(), diags
	}

	clientIdVal, ok := clientIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`client_id expected to be basetypes.StringValue, was: %T`, clientIdAttribute))
	}

	clientSecretAttribute, ok := attributes["client_secret"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`client_secret is missing from object`)

		return NewDatabricksVolumeDeltaTablesValueUnknown(), diags
	}

	clientSecretVal, ok := clientSecretAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`client_secret expected to be basetypes.StringValue, was: %T`, clientSecretAttribute))
	}

	databaseAttribute, ok := attributes["database"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`database is missing from object`)

		return NewDatabricksVolumeDeltaTablesValueUnknown(), diags
	}

	databaseVal, ok := databaseAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`database expected to be basetypes.StringValue, was: %T`, databaseAttribute))
	}

	httpPathAttribute, ok := attributes["http_path"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`http_path is missing from object`)

		return NewDatabricksVolumeDeltaTablesValueUnknown(), diags
	}

	httpPathVal, ok := httpPathAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`http_path expected to be basetypes.StringValue, was: %T`, httpPathAttribute))
	}

	schemaAttribute, ok := attributes["schema"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`schema is missing from object`)

		return NewDatabricksVolumeDeltaTablesValueUnknown(), diags
	}

	schemaVal, ok := schemaAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`schema expected to be basetypes.StringValue, was: %T`, schemaAttribute))
	}

	serverHostnameAttribute, ok := attributes["server_hostname"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`server_hostname is missing from object`)

		return NewDatabricksVolumeDeltaTablesValueUnknown(), diags
	}

	serverHostnameVal, ok := serverHostnameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`server_hostname expected to be basetypes.StringValue, was: %T`, serverHostnameAttribute))
	}

	tableNameAttribute, ok := attributes["table_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`table_name is missing from object`)

		return NewDatabricksVolumeDeltaTablesValueUnknown(), diags
	}

	tableNameVal, ok := tableNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`table_name expected to be basetypes.StringValue, was: %T`, tableNameAttribute))
	}

	tokenAttribute, ok := attributes["token"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`token is missing from object`)

		return NewDatabricksVolumeDeltaTablesValueUnknown(), diags
	}

	tokenVal, ok := tokenAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`token expected to be basetypes.StringValue, was: %T`, tokenAttribute))
	}

	volumeAttribute, ok := attributes["volume"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume is missing from object`)

		return NewDatabricksVolumeDeltaTablesValueUnknown(), diags
	}

	volumeVal, ok := volumeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume expected to be basetypes.StringValue, was: %T`, volumeAttribute))
	}

	volumePathAttribute, ok := attributes["volume_path"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_path is missing from object`)

		return NewDatabricksVolumeDeltaTablesValueUnknown(), diags
	}

	volumePathVal, ok := volumePathAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_path expected to be basetypes.StringValue, was: %T`, volumePathAttribute))
	}

	if diags.HasError() {
		return NewDatabricksVolumeDeltaTablesValueUnknown(), diags
	}

	return DatabricksVolumeDeltaTablesValue{
		Catalog:        catalogVal,
		ClientId:       clientIdVal,
		ClientSecret:   clientSecretVal,
		Database:       databaseVal,
		HttpPath:       httpPathVal,
		Schema:         schemaVal,
		ServerHostname: serverHostnameVal,
		TableName:      tableNameVal,
		Token:          tokenVal,
		Volume:         volumeVal,
		VolumePath:     volumePathVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewDatabricksVolumeDeltaTablesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) DatabricksVolumeDeltaTablesValue {
	object, diags := NewDatabricksVolumeDeltaTablesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDatabricksVolumeDeltaTablesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t DatabricksVolumeDeltaTablesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDatabricksVolumeDeltaTablesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDatabricksVolumeDeltaTablesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDatabricksVolumeDeltaTablesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDatabricksVolumeDeltaTablesValueMust(DatabricksVolumeDeltaTablesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t DatabricksVolumeDeltaTablesType) ValueType(ctx context.Context) attr.Value {
	return DatabricksVolumeDeltaTablesValue{}
}

var _ basetypes.ObjectValuable = DatabricksVolumeDeltaTablesValue{}

type DatabricksVolumeDeltaTablesValue struct {
	Catalog        basetypes.StringValue `tfsdk:"catalog"`
	ClientId       basetypes.StringValue `tfsdk:"client_id"`
	ClientSecret   basetypes.StringValue `tfsdk:"client_secret"`
	Database       basetypes.StringValue `tfsdk:"database"`
	HttpPath       basetypes.StringValue `tfsdk:"http_path"`
	Schema         basetypes.StringValue `tfsdk:"schema"`
	ServerHostname basetypes.StringValue `tfsdk:"server_hostname"`
	TableName      basetypes.StringValue `tfsdk:"table_name"`
	Token          basetypes.StringValue `tfsdk:"token"`
	Volume         basetypes.StringValue `tfsdk:"volume"`
	VolumePath     basetypes.StringValue `tfsdk:"volume_path"`
	state          attr.ValueState
}

func (v DatabricksVolumeDeltaTablesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 11)

	var val tftypes.Value
	var err error

	attrTypes["catalog"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["client_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["client_secret"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["database"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["http_path"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["schema"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["server_hostname"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["table_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["token"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["volume"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["volume_path"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 11)

		val, err = v.Catalog.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["catalog"] = val

		val, err = v.ClientId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["client_id"] = val

		val, err = v.ClientSecret.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["client_secret"] = val

		val, err = v.Database.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["database"] = val

		val, err = v.HttpPath.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["http_path"] = val

		val, err = v.Schema.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["schema"] = val

		val, err = v.ServerHostname.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["server_hostname"] = val

		val, err = v.TableName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["table_name"] = val

		val, err = v.Token.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["token"] = val

		val, err = v.Volume.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["volume"] = val

		val, err = v.VolumePath.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["volume_path"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v DatabricksVolumeDeltaTablesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v DatabricksVolumeDeltaTablesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v DatabricksVolumeDeltaTablesValue) String() string {
	return "DatabricksVolumeDeltaTablesValue"
}

func (v DatabricksVolumeDeltaTablesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"catalog":         basetypes.StringType{},
		"client_id":       basetypes.StringType{},
		"client_secret":   basetypes.StringType{},
		"database":        basetypes.StringType{},
		"http_path":       basetypes.StringType{},
		"schema":          basetypes.StringType{},
		"server_hostname": basetypes.StringType{},
		"table_name":      basetypes.StringType{},
		"token":           basetypes.StringType{},
		"volume":          basetypes.StringType{},
		"volume_path":     basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"catalog":         v.Catalog,
			"client_id":       v.ClientId,
			"client_secret":   v.ClientSecret,
			"database":        v.Database,
			"http_path":       v.HttpPath,
			"schema":          v.Schema,
			"server_hostname": v.ServerHostname,
			"table_name":      v.TableName,
			"token":           v.Token,
			"volume":          v.Volume,
			"volume_path":     v.VolumePath,
		})

	return objVal, diags
}

func (v DatabricksVolumeDeltaTablesValue) Equal(o attr.Value) bool {
	other, ok := o.(DatabricksVolumeDeltaTablesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Catalog.Equal(other.Catalog) {
		return false
	}

	if !v.ClientId.Equal(other.ClientId) {
		return false
	}

	if !v.ClientSecret.Equal(other.ClientSecret) {
		return false
	}

	if !v.Database.Equal(other.Database) {
		return false
	}

	if !v.HttpPath.Equal(other.HttpPath) {
		return false
	}

	if !v.Schema.Equal(other.Schema) {
		return false
	}

	if !v.ServerHostname.Equal(other.ServerHostname) {
		return false
	}

	if !v.TableName.Equal(other.TableName) {
		return false
	}

	if !v.Token.Equal(other.Token) {
		return false
	}

	if !v.Volume.Equal(other.Volume) {
		return false
	}

	if !v.VolumePath.Equal(other.VolumePath) {
		return false
	}

	return true
}

func (v DatabricksVolumeDeltaTablesValue) Type(ctx context.Context) attr.Type {
	return DatabricksVolumeDeltaTablesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v DatabricksVolumeDeltaTablesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"catalog":         basetypes.StringType{},
		"client_id":       basetypes.StringType{},
		"client_secret":   basetypes.StringType{},
		"database":        basetypes.StringType{},
		"http_path":       basetypes.StringType{},
		"schema":          basetypes.StringType{},
		"server_hostname": basetypes.StringType{},
		"table_name":      basetypes.StringType{},
		"token":           basetypes.StringType{},
		"volume":          basetypes.StringType{},
		"volume_path":     basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = DatabricksVolumesType{}

type DatabricksVolumesType struct {
	basetypes.ObjectType
}

func (t DatabricksVolumesType) Equal(o attr.Type) bool {
	other, ok := o.(DatabricksVolumesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t DatabricksVolumesType) String() string {
	return "DatabricksVolumesType"
}

func (t DatabricksVolumesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	catalogAttribute, ok := attributes["catalog"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`catalog is missing from object`)

		return nil, diags
	}

	catalogVal, ok := catalogAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`catalog expected to be basetypes.StringValue, was: %T`, catalogAttribute))
	}

	clientIdAttribute, ok := attributes["client_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`client_id is missing from object`)

		return nil, diags
	}

	clientIdVal, ok := clientIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`client_id expected to be basetypes.StringValue, was: %T`, clientIdAttribute))
	}

	clientSecretAttribute, ok := attributes["client_secret"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`client_secret is missing from object`)

		return nil, diags
	}

	clientSecretVal, ok := clientSecretAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`client_secret expected to be basetypes.StringValue, was: %T`, clientSecretAttribute))
	}

	hostAttribute, ok := attributes["host"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`host is missing from object`)

		return nil, diags
	}

	hostVal, ok := hostAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`host expected to be basetypes.StringValue, was: %T`, hostAttribute))
	}

	schemaAttribute, ok := attributes["schema"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`schema is missing from object`)

		return nil, diags
	}

	schemaVal, ok := schemaAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`schema expected to be basetypes.StringValue, was: %T`, schemaAttribute))
	}

	volumeAttribute, ok := attributes["volume"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume is missing from object`)

		return nil, diags
	}

	volumeVal, ok := volumeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume expected to be basetypes.StringValue, was: %T`, volumeAttribute))
	}

	volumePathAttribute, ok := attributes["volume_path"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_path is missing from object`)

		return nil, diags
	}

	volumePathVal, ok := volumePathAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_path expected to be basetypes.StringValue, was: %T`, volumePathAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return DatabricksVolumesValue{
		Catalog:      catalogVal,
		ClientId:     clientIdVal,
		ClientSecret: clientSecretVal,
		Host:         hostVal,
		Schema:       schemaVal,
		Volume:       volumeVal,
		VolumePath:   volumePathVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewDatabricksVolumesValueNull() DatabricksVolumesValue {
	return DatabricksVolumesValue{
		state: attr.ValueStateNull,
	}
}

func NewDatabricksVolumesValueUnknown() DatabricksVolumesValue {
	return DatabricksVolumesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDatabricksVolumesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (DatabricksVolumesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing DatabricksVolumesValue Attribute Value",
				"While creating a DatabricksVolumesValue value, a missing attribute value was detected. "+
					"A DatabricksVolumesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DatabricksVolumesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid DatabricksVolumesValue Attribute Type",
				"While creating a DatabricksVolumesValue value, an invalid attribute value was detected. "+
					"A DatabricksVolumesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DatabricksVolumesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("DatabricksVolumesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra DatabricksVolumesValue Attribute Value",
				"While creating a DatabricksVolumesValue value, an extra attribute value was detected. "+
					"A DatabricksVolumesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra DatabricksVolumesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDatabricksVolumesValueUnknown(), diags
	}

	catalogAttribute, ok := attributes["catalog"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`catalog is missing from object`)

		return NewDatabricksVolumesValueUnknown(), diags
	}

	catalogVal, ok := catalogAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`catalog expected to be basetypes.StringValue, was: %T`, catalogAttribute))
	}

	clientIdAttribute, ok := attributes["client_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`client_id is missing from object`)

		return NewDatabricksVolumesValueUnknown(), diags
	}

	clientIdVal, ok := clientIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`client_id expected to be basetypes.StringValue, was: %T`, clientIdAttribute))
	}

	clientSecretAttribute, ok := attributes["client_secret"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`client_secret is missing from object`)

		return NewDatabricksVolumesValueUnknown(), diags
	}

	clientSecretVal, ok := clientSecretAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`client_secret expected to be basetypes.StringValue, was: %T`, clientSecretAttribute))
	}

	hostAttribute, ok := attributes["host"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`host is missing from object`)

		return NewDatabricksVolumesValueUnknown(), diags
	}

	hostVal, ok := hostAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`host expected to be basetypes.StringValue, was: %T`, hostAttribute))
	}

	schemaAttribute, ok := attributes["schema"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`schema is missing from object`)

		return NewDatabricksVolumesValueUnknown(), diags
	}

	schemaVal, ok := schemaAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`schema expected to be basetypes.StringValue, was: %T`, schemaAttribute))
	}

	volumeAttribute, ok := attributes["volume"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume is missing from object`)

		return NewDatabricksVolumesValueUnknown(), diags
	}

	volumeVal, ok := volumeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume expected to be basetypes.StringValue, was: %T`, volumeAttribute))
	}

	volumePathAttribute, ok := attributes["volume_path"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_path is missing from object`)

		return NewDatabricksVolumesValueUnknown(), diags
	}

	volumePathVal, ok := volumePathAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_path expected to be basetypes.StringValue, was: %T`, volumePathAttribute))
	}

	if diags.HasError() {
		return NewDatabricksVolumesValueUnknown(), diags
	}

	return DatabricksVolumesValue{
		Catalog:      catalogVal,
		ClientId:     clientIdVal,
		ClientSecret: clientSecretVal,
		Host:         hostVal,
		Schema:       schemaVal,
		Volume:       volumeVal,
		VolumePath:   volumePathVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewDatabricksVolumesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) DatabricksVolumesValue {
	object, diags := NewDatabricksVolumesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDatabricksVolumesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t DatabricksVolumesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDatabricksVolumesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDatabricksVolumesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDatabricksVolumesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDatabricksVolumesValueMust(DatabricksVolumesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t DatabricksVolumesType) ValueType(ctx context.Context) attr.Value {
	return DatabricksVolumesValue{}
}

var _ basetypes.ObjectValuable = DatabricksVolumesValue{}

type DatabricksVolumesValue struct {
	Catalog      basetypes.StringValue `tfsdk:"catalog"`
	ClientId     basetypes.StringValue `tfsdk:"client_id"`
	ClientSecret basetypes.StringValue `tfsdk:"client_secret"`
	Host         basetypes.StringValue `tfsdk:"host"`
	Schema       basetypes.StringValue `tfsdk:"schema"`
	Volume       basetypes.StringValue `tfsdk:"volume"`
	VolumePath   basetypes.StringValue `tfsdk:"volume_path"`
	state        attr.ValueState
}

func (v DatabricksVolumesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 7)

	var val tftypes.Value
	var err error

	attrTypes["catalog"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["client_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["client_secret"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["host"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["schema"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["volume"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["volume_path"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 7)

		val, err = v.Catalog.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["catalog"] = val

		val, err = v.ClientId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["client_id"] = val

		val, err = v.ClientSecret.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["client_secret"] = val

		val, err = v.Host.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["host"] = val

		val, err = v.Schema.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["schema"] = val

		val, err = v.Volume.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["volume"] = val

		val, err = v.VolumePath.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["volume_path"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v DatabricksVolumesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v DatabricksVolumesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v DatabricksVolumesValue) String() string {
	return "DatabricksVolumesValue"
}

func (v DatabricksVolumesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"catalog":       basetypes.StringType{},
		"client_id":     basetypes.StringType{},
		"client_secret": basetypes.StringType{},
		"host":          basetypes.StringType{},
		"schema":        basetypes.StringType{},
		"volume":        basetypes.StringType{},
		"volume_path":   basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"catalog":       v.Catalog,
			"client_id":     v.ClientId,
			"client_secret": v.ClientSecret,
			"host":          v.Host,
			"schema":        v.Schema,
			"volume":        v.Volume,
			"volume_path":   v.VolumePath,
		})

	return objVal, diags
}

func (v DatabricksVolumesValue) Equal(o attr.Value) bool {
	other, ok := o.(DatabricksVolumesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Catalog.Equal(other.Catalog) {
		return false
	}

	if !v.ClientId.Equal(other.ClientId) {
		return false
	}

	if !v.ClientSecret.Equal(other.ClientSecret) {
		return false
	}

	if !v.Host.Equal(other.Host) {
		return false
	}

	if !v.Schema.Equal(other.Schema) {
		return false
	}

	if !v.Volume.Equal(other.Volume) {
		return false
	}

	if !v.VolumePath.Equal(other.VolumePath) {
		return false
	}

	return true
}

func (v DatabricksVolumesValue) Type(ctx context.Context) attr.Type {
	return DatabricksVolumesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v DatabricksVolumesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"catalog":       basetypes.StringType{},
		"client_id":     basetypes.StringType{},
		"client_secret": basetypes.StringType{},
		"host":          basetypes.StringType{},
		"schema":        basetypes.StringType{},
		"volume":        basetypes.StringType{},
		"volume_path":   basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = DeltaTableType{}

type DeltaTableType struct {
	basetypes.ObjectType
}

func (t DeltaTableType) Equal(o attr.Type) bool {
	other, ok := o.(DeltaTableType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t DeltaTableType) String() string {
	return "DeltaTableType"
}

func (t DeltaTableType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	awsAccessKeyIdAttribute, ok := attributes["aws_access_key_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`aws_access_key_id is missing from object`)

		return nil, diags
	}

	awsAccessKeyIdVal, ok := awsAccessKeyIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`aws_access_key_id expected to be basetypes.StringValue, was: %T`, awsAccessKeyIdAttribute))
	}

	awsRegionAttribute, ok := attributes["aws_region"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`aws_region is missing from object`)

		return nil, diags
	}

	awsRegionVal, ok := awsRegionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`aws_region expected to be basetypes.StringValue, was: %T`, awsRegionAttribute))
	}

	awsSecretAccessKeyAttribute, ok := attributes["aws_secret_access_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`aws_secret_access_key is missing from object`)

		return nil, diags
	}

	awsSecretAccessKeyVal, ok := awsSecretAccessKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`aws_secret_access_key expected to be basetypes.StringValue, was: %T`, awsSecretAccessKeyAttribute))
	}

	tableUriAttribute, ok := attributes["table_uri"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`table_uri is missing from object`)

		return nil, diags
	}

	tableUriVal, ok := tableUriAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`table_uri expected to be basetypes.StringValue, was: %T`, tableUriAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return DeltaTableValue{
		AwsAccessKeyId:     awsAccessKeyIdVal,
		AwsRegion:          awsRegionVal,
		AwsSecretAccessKey: awsSecretAccessKeyVal,
		TableUri:           tableUriVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewDeltaTableValueNull() DeltaTableValue {
	return DeltaTableValue{
		state: attr.ValueStateNull,
	}
}

func NewDeltaTableValueUnknown() DeltaTableValue {
	return DeltaTableValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDeltaTableValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (DeltaTableValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing DeltaTableValue Attribute Value",
				"While creating a DeltaTableValue value, a missing attribute value was detected. "+
					"A DeltaTableValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DeltaTableValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid DeltaTableValue Attribute Type",
				"While creating a DeltaTableValue value, an invalid attribute value was detected. "+
					"A DeltaTableValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DeltaTableValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("DeltaTableValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra DeltaTableValue Attribute Value",
				"While creating a DeltaTableValue value, an extra attribute value was detected. "+
					"A DeltaTableValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra DeltaTableValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDeltaTableValueUnknown(), diags
	}

	awsAccessKeyIdAttribute, ok := attributes["aws_access_key_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`aws_access_key_id is missing from object`)

		return NewDeltaTableValueUnknown(), diags
	}

	awsAccessKeyIdVal, ok := awsAccessKeyIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`aws_access_key_id expected to be basetypes.StringValue, was: %T`, awsAccessKeyIdAttribute))
	}

	awsRegionAttribute, ok := attributes["aws_region"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`aws_region is missing from object`)

		return NewDeltaTableValueUnknown(), diags
	}

	awsRegionVal, ok := awsRegionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`aws_region expected to be basetypes.StringValue, was: %T`, awsRegionAttribute))
	}

	awsSecretAccessKeyAttribute, ok := attributes["aws_secret_access_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`aws_secret_access_key is missing from object`)

		return NewDeltaTableValueUnknown(), diags
	}

	awsSecretAccessKeyVal, ok := awsSecretAccessKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`aws_secret_access_key expected to be basetypes.StringValue, was: %T`, awsSecretAccessKeyAttribute))
	}

	tableUriAttribute, ok := attributes["table_uri"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`table_uri is missing from object`)

		return NewDeltaTableValueUnknown(), diags
	}

	tableUriVal, ok := tableUriAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`table_uri expected to be basetypes.StringValue, was: %T`, tableUriAttribute))
	}

	if diags.HasError() {
		return NewDeltaTableValueUnknown(), diags
	}

	return DeltaTableValue{
		AwsAccessKeyId:     awsAccessKeyIdVal,
		AwsRegion:          awsRegionVal,
		AwsSecretAccessKey: awsSecretAccessKeyVal,
		TableUri:           tableUriVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewDeltaTableValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) DeltaTableValue {
	object, diags := NewDeltaTableValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDeltaTableValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t DeltaTableType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDeltaTableValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDeltaTableValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDeltaTableValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDeltaTableValueMust(DeltaTableValue{}.AttributeTypes(ctx), attributes), nil
}

func (t DeltaTableType) ValueType(ctx context.Context) attr.Value {
	return DeltaTableValue{}
}

var _ basetypes.ObjectValuable = DeltaTableValue{}

type DeltaTableValue struct {
	AwsAccessKeyId     basetypes.StringValue `tfsdk:"aws_access_key_id"`
	AwsRegion          basetypes.StringValue `tfsdk:"aws_region"`
	AwsSecretAccessKey basetypes.StringValue `tfsdk:"aws_secret_access_key"`
	TableUri           basetypes.StringValue `tfsdk:"table_uri"`
	state              attr.ValueState
}

func (v DeltaTableValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["aws_access_key_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["aws_region"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["aws_secret_access_key"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["table_uri"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.AwsAccessKeyId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["aws_access_key_id"] = val

		val, err = v.AwsRegion.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["aws_region"] = val

		val, err = v.AwsSecretAccessKey.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["aws_secret_access_key"] = val

		val, err = v.TableUri.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["table_uri"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v DeltaTableValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v DeltaTableValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v DeltaTableValue) String() string {
	return "DeltaTableValue"
}

func (v DeltaTableValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"aws_access_key_id":     basetypes.StringType{},
		"aws_region":            basetypes.StringType{},
		"aws_secret_access_key": basetypes.StringType{},
		"table_uri":             basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"aws_access_key_id":     v.AwsAccessKeyId,
			"aws_region":            v.AwsRegion,
			"aws_secret_access_key": v.AwsSecretAccessKey,
			"table_uri":             v.TableUri,
		})

	return objVal, diags
}

func (v DeltaTableValue) Equal(o attr.Value) bool {
	other, ok := o.(DeltaTableValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AwsAccessKeyId.Equal(other.AwsAccessKeyId) {
		return false
	}

	if !v.AwsRegion.Equal(other.AwsRegion) {
		return false
	}

	if !v.AwsSecretAccessKey.Equal(other.AwsSecretAccessKey) {
		return false
	}

	if !v.TableUri.Equal(other.TableUri) {
		return false
	}

	return true
}

func (v DeltaTableValue) Type(ctx context.Context) attr.Type {
	return DeltaTableType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v DeltaTableValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"aws_access_key_id":     basetypes.StringType{},
		"aws_region":            basetypes.StringType{},
		"aws_secret_access_key": basetypes.StringType{},
		"table_uri":             basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = ElasticsearchType{}

type ElasticsearchType struct {
	basetypes.ObjectType
}

func (t ElasticsearchType) Equal(o attr.Type) bool {
	other, ok := o.(ElasticsearchType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ElasticsearchType) String() string {
	return "ElasticsearchType"
}

func (t ElasticsearchType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	esApiKeyAttribute, ok := attributes["es_api_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`es_api_key is missing from object`)

		return nil, diags
	}

	esApiKeyVal, ok := esApiKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`es_api_key expected to be basetypes.StringValue, was: %T`, esApiKeyAttribute))
	}

	hostsAttribute, ok := attributes["hosts"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`hosts is missing from object`)

		return nil, diags
	}

	hostsVal, ok := hostsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`hosts expected to be basetypes.ListValue, was: %T`, hostsAttribute))
	}

	indexNameAttribute, ok := attributes["index_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`index_name is missing from object`)

		return nil, diags
	}

	indexNameVal, ok := indexNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`index_name expected to be basetypes.StringValue, was: %T`, indexNameAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ElasticsearchValue{
		EsApiKey:  esApiKeyVal,
		Hosts:     hostsVal,
		IndexName: indexNameVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewElasticsearchValueNull() ElasticsearchValue {
	return ElasticsearchValue{
		state: attr.ValueStateNull,
	}
}

func NewElasticsearchValueUnknown() ElasticsearchValue {
	return ElasticsearchValue{
		state: attr.ValueStateUnknown,
	}
}

func NewElasticsearchValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ElasticsearchValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ElasticsearchValue Attribute Value",
				"While creating a ElasticsearchValue value, a missing attribute value was detected. "+
					"A ElasticsearchValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ElasticsearchValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ElasticsearchValue Attribute Type",
				"While creating a ElasticsearchValue value, an invalid attribute value was detected. "+
					"A ElasticsearchValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ElasticsearchValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ElasticsearchValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ElasticsearchValue Attribute Value",
				"While creating a ElasticsearchValue value, an extra attribute value was detected. "+
					"A ElasticsearchValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ElasticsearchValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewElasticsearchValueUnknown(), diags
	}

	esApiKeyAttribute, ok := attributes["es_api_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`es_api_key is missing from object`)

		return NewElasticsearchValueUnknown(), diags
	}

	esApiKeyVal, ok := esApiKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`es_api_key expected to be basetypes.StringValue, was: %T`, esApiKeyAttribute))
	}

	hostsAttribute, ok := attributes["hosts"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`hosts is missing from object`)

		return NewElasticsearchValueUnknown(), diags
	}

	hostsVal, ok := hostsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`hosts expected to be basetypes.ListValue, was: %T`, hostsAttribute))
	}

	indexNameAttribute, ok := attributes["index_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`index_name is missing from object`)

		return NewElasticsearchValueUnknown(), diags
	}

	indexNameVal, ok := indexNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`index_name expected to be basetypes.StringValue, was: %T`, indexNameAttribute))
	}

	if diags.HasError() {
		return NewElasticsearchValueUnknown(), diags
	}

	return ElasticsearchValue{
		EsApiKey:  esApiKeyVal,
		Hosts:     hostsVal,
		IndexName: indexNameVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewElasticsearchValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ElasticsearchValue {
	object, diags := NewElasticsearchValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewElasticsearchValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ElasticsearchType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewElasticsearchValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewElasticsearchValueUnknown(), nil
	}

	if in.IsNull() {
		return NewElasticsearchValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewElasticsearchValueMust(ElasticsearchValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ElasticsearchType) ValueType(ctx context.Context) attr.Value {
	return ElasticsearchValue{}
}

var _ basetypes.ObjectValuable = ElasticsearchValue{}

type ElasticsearchValue struct {
	EsApiKey  basetypes.StringValue `tfsdk:"es_api_key"`
	Hosts     basetypes.ListValue   `tfsdk:"hosts"`
	IndexName basetypes.StringValue `tfsdk:"index_name"`
	state     attr.ValueState
}

func (v ElasticsearchValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["es_api_key"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["hosts"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["index_name"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.EsApiKey.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["es_api_key"] = val

		val, err = v.Hosts.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["hosts"] = val

		val, err = v.IndexName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["index_name"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ElasticsearchValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ElasticsearchValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ElasticsearchValue) String() string {
	return "ElasticsearchValue"
}

func (v ElasticsearchValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var hostsVal basetypes.ListValue
	switch {
	case v.Hosts.IsUnknown():
		hostsVal = types.ListUnknown(types.StringType)
	case v.Hosts.IsNull():
		hostsVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		hostsVal, d = types.ListValue(types.StringType, v.Hosts.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"es_api_key": basetypes.StringType{},
			"hosts": basetypes.ListType{
				ElemType: types.StringType,
			},
			"index_name": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"es_api_key": basetypes.StringType{},
		"hosts": basetypes.ListType{
			ElemType: types.StringType,
		},
		"index_name": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"es_api_key": v.EsApiKey,
			"hosts":      hostsVal,
			"index_name": v.IndexName,
		})

	return objVal, diags
}

func (v ElasticsearchValue) Equal(o attr.Value) bool {
	other, ok := o.(ElasticsearchValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.EsApiKey.Equal(other.EsApiKey) {
		return false
	}

	if !v.Hosts.Equal(other.Hosts) {
		return false
	}

	if !v.IndexName.Equal(other.IndexName) {
		return false
	}

	return true
}

func (v ElasticsearchValue) Type(ctx context.Context) attr.Type {
	return ElasticsearchType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ElasticsearchValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"es_api_key": basetypes.StringType{},
		"hosts": basetypes.ListType{
			ElemType: types.StringType,
		},
		"index_name": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = GcsType{}

type GcsType struct {
	basetypes.ObjectType
}

func (t GcsType) Equal(o attr.Type) bool {
	other, ok := o.(GcsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t GcsType) String() string {
	return "GcsType"
}

func (t GcsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	remoteUrlAttribute, ok := attributes["remote_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remote_url is missing from object`)

		return nil, diags
	}

	remoteUrlVal, ok := remoteUrlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remote_url expected to be basetypes.StringValue, was: %T`, remoteUrlAttribute))
	}

	serviceAccountKeyAttribute, ok := attributes["service_account_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`service_account_key is missing from object`)

		return nil, diags
	}

	serviceAccountKeyVal, ok := serviceAccountKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`service_account_key expected to be basetypes.StringValue, was: %T`, serviceAccountKeyAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return GcsValue{
		RemoteUrl:         remoteUrlVal,
		ServiceAccountKey: serviceAccountKeyVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewGcsValueNull() GcsValue {
	return GcsValue{
		state: attr.ValueStateNull,
	}
}

func NewGcsValueUnknown() GcsValue {
	return GcsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewGcsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (GcsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing GcsValue Attribute Value",
				"While creating a GcsValue value, a missing attribute value was detected. "+
					"A GcsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("GcsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid GcsValue Attribute Type",
				"While creating a GcsValue value, an invalid attribute value was detected. "+
					"A GcsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("GcsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("GcsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra GcsValue Attribute Value",
				"While creating a GcsValue value, an extra attribute value was detected. "+
					"A GcsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra GcsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewGcsValueUnknown(), diags
	}

	remoteUrlAttribute, ok := attributes["remote_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remote_url is missing from object`)

		return NewGcsValueUnknown(), diags
	}

	remoteUrlVal, ok := remoteUrlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remote_url expected to be basetypes.StringValue, was: %T`, remoteUrlAttribute))
	}

	serviceAccountKeyAttribute, ok := attributes["service_account_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`service_account_key is missing from object`)

		return NewGcsValueUnknown(), diags
	}

	serviceAccountKeyVal, ok := serviceAccountKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`service_account_key expected to be basetypes.StringValue, was: %T`, serviceAccountKeyAttribute))
	}

	if diags.HasError() {
		return NewGcsValueUnknown(), diags
	}

	return GcsValue{
		RemoteUrl:         remoteUrlVal,
		ServiceAccountKey: serviceAccountKeyVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewGcsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) GcsValue {
	object, diags := NewGcsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewGcsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t GcsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewGcsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewGcsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewGcsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewGcsValueMust(GcsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t GcsType) ValueType(ctx context.Context) attr.Value {
	return GcsValue{}
}

var _ basetypes.ObjectValuable = GcsValue{}

type GcsValue struct {
	RemoteUrl         basetypes.StringValue `tfsdk:"remote_url"`
	ServiceAccountKey basetypes.StringValue `tfsdk:"service_account_key"`
	state             attr.ValueState
}

func (v GcsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["remote_url"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["service_account_key"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.RemoteUrl.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["remote_url"] = val

		val, err = v.ServiceAccountKey.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["service_account_key"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v GcsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v GcsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v GcsValue) String() string {
	return "GcsValue"
}

func (v GcsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"remote_url":          basetypes.StringType{},
		"service_account_key": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"remote_url":          v.RemoteUrl,
			"service_account_key": v.ServiceAccountKey,
		})

	return objVal, diags
}

func (v GcsValue) Equal(o attr.Value) bool {
	other, ok := o.(GcsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.RemoteUrl.Equal(other.RemoteUrl) {
		return false
	}

	if !v.ServiceAccountKey.Equal(other.ServiceAccountKey) {
		return false
	}

	return true
}

func (v GcsValue) Type(ctx context.Context) attr.Type {
	return GcsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v GcsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"remote_url":          basetypes.StringType{},
		"service_account_key": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = IbmWatsonxS3Type{}

type IbmWatsonxS3Type struct {
	basetypes.ObjectType
}

func (t IbmWatsonxS3Type) Equal(o attr.Type) bool {
	other, ok := o.(IbmWatsonxS3Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t IbmWatsonxS3Type) String() string {
	return "IbmWatsonxS3Type"
}

func (t IbmWatsonxS3Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	accessKeyIdAttribute, ok := attributes["access_key_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`access_key_id is missing from object`)

		return nil, diags
	}

	accessKeyIdVal, ok := accessKeyIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`access_key_id expected to be basetypes.StringValue, was: %T`, accessKeyIdAttribute))
	}

	catalogAttribute, ok := attributes["catalog"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`catalog is missing from object`)

		return nil, diags
	}

	catalogVal, ok := catalogAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`catalog expected to be basetypes.StringValue, was: %T`, catalogAttribute))
	}

	iamApiKeyAttribute, ok := attributes["iam_api_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`iam_api_key is missing from object`)

		return nil, diags
	}

	iamApiKeyVal, ok := iamApiKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`iam_api_key expected to be basetypes.StringValue, was: %T`, iamApiKeyAttribute))
	}

	icebergEndpointAttribute, ok := attributes["iceberg_endpoint"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`iceberg_endpoint is missing from object`)

		return nil, diags
	}

	icebergEndpointVal, ok := icebergEndpointAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`iceberg_endpoint expected to be basetypes.StringValue, was: %T`, icebergEndpointAttribute))
	}

	maxRetriesAttribute, ok := attributes["max_retries"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_retries is missing from object`)

		return nil, diags
	}

	maxRetriesVal, ok := maxRetriesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_retries expected to be basetypes.Int64Value, was: %T`, maxRetriesAttribute))
	}

	maxRetriesConnectionAttribute, ok := attributes["max_retries_connection"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_retries_connection is missing from object`)

		return nil, diags
	}

	maxRetriesConnectionVal, ok := maxRetriesConnectionAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_retries_connection expected to be basetypes.Int64Value, was: %T`, maxRetriesConnectionAttribute))
	}

	namespaceAttribute, ok := attributes["namespace"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`namespace is missing from object`)

		return nil, diags
	}

	namespaceVal, ok := namespaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`namespace expected to be basetypes.StringValue, was: %T`, namespaceAttribute))
	}

	objectStorageEndpointAttribute, ok := attributes["object_storage_endpoint"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`object_storage_endpoint is missing from object`)

		return nil, diags
	}

	objectStorageEndpointVal, ok := objectStorageEndpointAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`object_storage_endpoint expected to be basetypes.StringValue, was: %T`, objectStorageEndpointAttribute))
	}

	objectStorageRegionAttribute, ok := attributes["object_storage_region"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`object_storage_region is missing from object`)

		return nil, diags
	}

	objectStorageRegionVal, ok := objectStorageRegionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`object_storage_region expected to be basetypes.StringValue, was: %T`, objectStorageRegionAttribute))
	}

	recordIdKeyAttribute, ok := attributes["record_id_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`record_id_key is missing from object`)

		return nil, diags
	}

	recordIdKeyVal, ok := recordIdKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`record_id_key expected to be basetypes.StringValue, was: %T`, recordIdKeyAttribute))
	}

	secretAccessKeyAttribute, ok := attributes["secret_access_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`secret_access_key is missing from object`)

		return nil, diags
	}

	secretAccessKeyVal, ok := secretAccessKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`secret_access_key expected to be basetypes.StringValue, was: %T`, secretAccessKeyAttribute))
	}

	tableAttribute, ok := attributes["table"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`table is missing from object`)

		return nil, diags
	}

	tableVal, ok := tableAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`table expected to be basetypes.StringValue, was: %T`, tableAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return IbmWatsonxS3Value{
		AccessKeyId:           accessKeyIdVal,
		Catalog:               catalogVal,
		IamApiKey:             iamApiKeyVal,
		IcebergEndpoint:       icebergEndpointVal,
		MaxRetries:            maxRetriesVal,
		MaxRetriesConnection:  maxRetriesConnectionVal,
		Namespace:             namespaceVal,
		ObjectStorageEndpoint: objectStorageEndpointVal,
		ObjectStorageRegion:   objectStorageRegionVal,
		RecordIdKey:           recordIdKeyVal,
		SecretAccessKey:       secretAccessKeyVal,
		Table:                 tableVal,
		state:                 attr.ValueStateKnown,
	}, diags
}

func NewIbmWatsonxS3ValueNull() IbmWatsonxS3Value {
	return IbmWatsonxS3Value{
		state: attr.ValueStateNull,
	}
}

func NewIbmWatsonxS3ValueUnknown() IbmWatsonxS3Value {
	return IbmWatsonxS3Value{
		state: attr.ValueStateUnknown,
	}
}

func NewIbmWatsonxS3Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (IbmWatsonxS3Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing IbmWatsonxS3Value Attribute Value",
				"While creating a IbmWatsonxS3Value value, a missing attribute value was detected. "+
					"A IbmWatsonxS3Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IbmWatsonxS3Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid IbmWatsonxS3Value Attribute Type",
				"While creating a IbmWatsonxS3Value value, an invalid attribute value was detected. "+
					"A IbmWatsonxS3Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IbmWatsonxS3Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("IbmWatsonxS3Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra IbmWatsonxS3Value Attribute Value",
				"While creating a IbmWatsonxS3Value value, an extra attribute value was detected. "+
					"A IbmWatsonxS3Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra IbmWatsonxS3Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewIbmWatsonxS3ValueUnknown(), diags
	}

	accessKeyIdAttribute, ok := attributes["access_key_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`access_key_id is missing from object`)

		return NewIbmWatsonxS3ValueUnknown(), diags
	}

	accessKeyIdVal, ok := accessKeyIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`access_key_id expected to be basetypes.StringValue, was: %T`, accessKeyIdAttribute))
	}

	catalogAttribute, ok := attributes["catalog"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`catalog is missing from object`)

		return NewIbmWatsonxS3ValueUnknown(), diags
	}

	catalogVal, ok := catalogAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`catalog expected to be basetypes.StringValue, was: %T`, catalogAttribute))
	}

	iamApiKeyAttribute, ok := attributes["iam_api_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`iam_api_key is missing from object`)

		return NewIbmWatsonxS3ValueUnknown(), diags
	}

	iamApiKeyVal, ok := iamApiKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`iam_api_key expected to be basetypes.StringValue, was: %T`, iamApiKeyAttribute))
	}

	icebergEndpointAttribute, ok := attributes["iceberg_endpoint"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`iceberg_endpoint is missing from object`)

		return NewIbmWatsonxS3ValueUnknown(), diags
	}

	icebergEndpointVal, ok := icebergEndpointAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`iceberg_endpoint expected to be basetypes.StringValue, was: %T`, icebergEndpointAttribute))
	}

	maxRetriesAttribute, ok := attributes["max_retries"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_retries is missing from object`)

		return NewIbmWatsonxS3ValueUnknown(), diags
	}

	maxRetriesVal, ok := maxRetriesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_retries expected to be basetypes.Int64Value, was: %T`, maxRetriesAttribute))
	}

	maxRetriesConnectionAttribute, ok := attributes["max_retries_connection"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_retries_connection is missing from object`)

		return NewIbmWatsonxS3ValueUnknown(), diags
	}

	maxRetriesConnectionVal, ok := maxRetriesConnectionAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_retries_connection expected to be basetypes.Int64Value, was: %T`, maxRetriesConnectionAttribute))
	}

	namespaceAttribute, ok := attributes["namespace"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`namespace is missing from object`)

		return NewIbmWatsonxS3ValueUnknown(), diags
	}

	namespaceVal, ok := namespaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`namespace expected to be basetypes.StringValue, was: %T`, namespaceAttribute))
	}

	objectStorageEndpointAttribute, ok := attributes["object_storage_endpoint"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`object_storage_endpoint is missing from object`)

		return NewIbmWatsonxS3ValueUnknown(), diags
	}

	objectStorageEndpointVal, ok := objectStorageEndpointAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`object_storage_endpoint expected to be basetypes.StringValue, was: %T`, objectStorageEndpointAttribute))
	}

	objectStorageRegionAttribute, ok := attributes["object_storage_region"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`object_storage_region is missing from object`)

		return NewIbmWatsonxS3ValueUnknown(), diags
	}

	objectStorageRegionVal, ok := objectStorageRegionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`object_storage_region expected to be basetypes.StringValue, was: %T`, objectStorageRegionAttribute))
	}

	recordIdKeyAttribute, ok := attributes["record_id_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`record_id_key is missing from object`)

		return NewIbmWatsonxS3ValueUnknown(), diags
	}

	recordIdKeyVal, ok := recordIdKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`record_id_key expected to be basetypes.StringValue, was: %T`, recordIdKeyAttribute))
	}

	secretAccessKeyAttribute, ok := attributes["secret_access_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`secret_access_key is missing from object`)

		return NewIbmWatsonxS3ValueUnknown(), diags
	}

	secretAccessKeyVal, ok := secretAccessKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`secret_access_key expected to be basetypes.StringValue, was: %T`, secretAccessKeyAttribute))
	}

	tableAttribute, ok := attributes["table"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`table is missing from object`)

		return NewIbmWatsonxS3ValueUnknown(), diags
	}

	tableVal, ok := tableAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`table expected to be basetypes.StringValue, was: %T`, tableAttribute))
	}

	if diags.HasError() {
		return NewIbmWatsonxS3ValueUnknown(), diags
	}

	return IbmWatsonxS3Value{
		AccessKeyId:           accessKeyIdVal,
		Catalog:               catalogVal,
		IamApiKey:             iamApiKeyVal,
		IcebergEndpoint:       icebergEndpointVal,
		MaxRetries:            maxRetriesVal,
		MaxRetriesConnection:  maxRetriesConnectionVal,
		Namespace:             namespaceVal,
		ObjectStorageEndpoint: objectStorageEndpointVal,
		ObjectStorageRegion:   objectStorageRegionVal,
		RecordIdKey:           recordIdKeyVal,
		SecretAccessKey:       secretAccessKeyVal,
		Table:                 tableVal,
		state:                 attr.ValueStateKnown,
	}, diags
}

func NewIbmWatsonxS3ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) IbmWatsonxS3Value {
	object, diags := NewIbmWatsonxS3Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewIbmWatsonxS3ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t IbmWatsonxS3Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewIbmWatsonxS3ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewIbmWatsonxS3ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewIbmWatsonxS3ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewIbmWatsonxS3ValueMust(IbmWatsonxS3Value{}.AttributeTypes(ctx), attributes), nil
}

func (t IbmWatsonxS3Type) ValueType(ctx context.Context) attr.Value {
	return IbmWatsonxS3Value{}
}

var _ basetypes.ObjectValuable = IbmWatsonxS3Value{}

type IbmWatsonxS3Value struct {
	AccessKeyId           basetypes.StringValue `tfsdk:"access_key_id"`
	Catalog               basetypes.StringValue `tfsdk:"catalog"`
	IamApiKey             basetypes.StringValue `tfsdk:"iam_api_key"`
	IcebergEndpoint       basetypes.StringValue `tfsdk:"iceberg_endpoint"`
	MaxRetries            basetypes.Int64Value  `tfsdk:"max_retries"`
	MaxRetriesConnection  basetypes.Int64Value  `tfsdk:"max_retries_connection"`
	Namespace             basetypes.StringValue `tfsdk:"namespace"`
	ObjectStorageEndpoint basetypes.StringValue `tfsdk:"object_storage_endpoint"`
	ObjectStorageRegion   basetypes.StringValue `tfsdk:"object_storage_region"`
	RecordIdKey           basetypes.StringValue `tfsdk:"record_id_key"`
	SecretAccessKey       basetypes.StringValue `tfsdk:"secret_access_key"`
	Table                 basetypes.StringValue `tfsdk:"table"`
	state                 attr.ValueState
}

func (v IbmWatsonxS3Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 12)

	var val tftypes.Value
	var err error

	attrTypes["access_key_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["catalog"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["iam_api_key"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["iceberg_endpoint"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["max_retries"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["max_retries_connection"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["namespace"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["object_storage_endpoint"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["object_storage_region"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["record_id_key"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["secret_access_key"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["table"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 12)

		val, err = v.AccessKeyId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["access_key_id"] = val

		val, err = v.Catalog.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["catalog"] = val

		val, err = v.IamApiKey.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["iam_api_key"] = val

		val, err = v.IcebergEndpoint.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["iceberg_endpoint"] = val

		val, err = v.MaxRetries.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_retries"] = val

		val, err = v.MaxRetriesConnection.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_retries_connection"] = val

		val, err = v.Namespace.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["namespace"] = val

		val, err = v.ObjectStorageEndpoint.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["object_storage_endpoint"] = val

		val, err = v.ObjectStorageRegion.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["object_storage_region"] = val

		val, err = v.RecordIdKey.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["record_id_key"] = val

		val, err = v.SecretAccessKey.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["secret_access_key"] = val

		val, err = v.Table.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["table"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v IbmWatsonxS3Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v IbmWatsonxS3Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v IbmWatsonxS3Value) String() string {
	return "IbmWatsonxS3Value"
}

func (v IbmWatsonxS3Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"access_key_id":           basetypes.StringType{},
		"catalog":                 basetypes.StringType{},
		"iam_api_key":             basetypes.StringType{},
		"iceberg_endpoint":        basetypes.StringType{},
		"max_retries":             basetypes.Int64Type{},
		"max_retries_connection":  basetypes.Int64Type{},
		"namespace":               basetypes.StringType{},
		"object_storage_endpoint": basetypes.StringType{},
		"object_storage_region":   basetypes.StringType{},
		"record_id_key":           basetypes.StringType{},
		"secret_access_key":       basetypes.StringType{},
		"table":                   basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"access_key_id":           v.AccessKeyId,
			"catalog":                 v.Catalog,
			"iam_api_key":             v.IamApiKey,
			"iceberg_endpoint":        v.IcebergEndpoint,
			"max_retries":             v.MaxRetries,
			"max_retries_connection":  v.MaxRetriesConnection,
			"namespace":               v.Namespace,
			"object_storage_endpoint": v.ObjectStorageEndpoint,
			"object_storage_region":   v.ObjectStorageRegion,
			"record_id_key":           v.RecordIdKey,
			"secret_access_key":       v.SecretAccessKey,
			"table":                   v.Table,
		})

	return objVal, diags
}

func (v IbmWatsonxS3Value) Equal(o attr.Value) bool {
	other, ok := o.(IbmWatsonxS3Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AccessKeyId.Equal(other.AccessKeyId) {
		return false
	}

	if !v.Catalog.Equal(other.Catalog) {
		return false
	}

	if !v.IamApiKey.Equal(other.IamApiKey) {
		return false
	}

	if !v.IcebergEndpoint.Equal(other.IcebergEndpoint) {
		return false
	}

	if !v.MaxRetries.Equal(other.MaxRetries) {
		return false
	}

	if !v.MaxRetriesConnection.Equal(other.MaxRetriesConnection) {
		return false
	}

	if !v.Namespace.Equal(other.Namespace) {
		return false
	}

	if !v.ObjectStorageEndpoint.Equal(other.ObjectStorageEndpoint) {
		return false
	}

	if !v.ObjectStorageRegion.Equal(other.ObjectStorageRegion) {
		return false
	}

	if !v.RecordIdKey.Equal(other.RecordIdKey) {
		return false
	}

	if !v.SecretAccessKey.Equal(other.SecretAccessKey) {
		return false
	}

	if !v.Table.Equal(other.Table) {
		return false
	}

	return true
}

func (v IbmWatsonxS3Value) Type(ctx context.Context) attr.Type {
	return IbmWatsonxS3Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v IbmWatsonxS3Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"access_key_id":           basetypes.StringType{},
		"catalog":                 basetypes.StringType{},
		"iam_api_key":             basetypes.StringType{},
		"iceberg_endpoint":        basetypes.StringType{},
		"max_retries":             basetypes.Int64Type{},
		"max_retries_connection":  basetypes.Int64Type{},
		"namespace":               basetypes.StringType{},
		"object_storage_endpoint": basetypes.StringType{},
		"object_storage_region":   basetypes.StringType{},
		"record_id_key":           basetypes.StringType{},
		"secret_access_key":       basetypes.StringType{},
		"table":                   basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = KafkaCloudType{}

type KafkaCloudType struct {
	basetypes.ObjectType
}

func (t KafkaCloudType) Equal(o attr.Type) bool {
	other, ok := o.(KafkaCloudType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t KafkaCloudType) String() string {
	return "KafkaCloudType"
}

func (t KafkaCloudType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	batchSizeAttribute, ok := attributes["batch_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`batch_size is missing from object`)

		return nil, diags
	}

	batchSizeVal, ok := batchSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`batch_size expected to be basetypes.Int64Value, was: %T`, batchSizeAttribute))
	}

	bootstrapServersAttribute, ok := attributes["bootstrap_servers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bootstrap_servers is missing from object`)

		return nil, diags
	}

	bootstrapServersVal, ok := bootstrapServersAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bootstrap_servers expected to be basetypes.StringValue, was: %T`, bootstrapServersAttribute))
	}

	groupIdAttribute, ok := attributes["group_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`group_id is missing from object`)

		return nil, diags
	}

	groupIdVal, ok := groupIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`group_id expected to be basetypes.StringValue, was: %T`, groupIdAttribute))
	}

	kafkaApiKeyAttribute, ok := attributes["kafka_api_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`kafka_api_key is missing from object`)

		return nil, diags
	}

	kafkaApiKeyVal, ok := kafkaApiKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`kafka_api_key expected to be basetypes.StringValue, was: %T`, kafkaApiKeyAttribute))
	}

	portAttribute, ok := attributes["port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port is missing from object`)

		return nil, diags
	}

	portVal, ok := portAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port expected to be basetypes.Int64Value, was: %T`, portAttribute))
	}

	secretAttribute, ok := attributes["secret"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`secret is missing from object`)

		return nil, diags
	}

	secretVal, ok := secretAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`secret expected to be basetypes.StringValue, was: %T`, secretAttribute))
	}

	topicAttribute, ok := attributes["topic"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`topic is missing from object`)

		return nil, diags
	}

	topicVal, ok := topicAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`topic expected to be basetypes.StringValue, was: %T`, topicAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return KafkaCloudValue{
		BatchSize:        batchSizeVal,
		BootstrapServers: bootstrapServersVal,
		GroupId:          groupIdVal,
		KafkaApiKey:      kafkaApiKeyVal,
		Port:             portVal,
		Secret:           secretVal,
		Topic:            topicVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewKafkaCloudValueNull() KafkaCloudValue {
	return KafkaCloudValue{
		state: attr.ValueStateNull,
	}
}

func NewKafkaCloudValueUnknown() KafkaCloudValue {
	return KafkaCloudValue{
		state: attr.ValueStateUnknown,
	}
}

func NewKafkaCloudValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (KafkaCloudValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing KafkaCloudValue Attribute Value",
				"While creating a KafkaCloudValue value, a missing attribute value was detected. "+
					"A KafkaCloudValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("KafkaCloudValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid KafkaCloudValue Attribute Type",
				"While creating a KafkaCloudValue value, an invalid attribute value was detected. "+
					"A KafkaCloudValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("KafkaCloudValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("KafkaCloudValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra KafkaCloudValue Attribute Value",
				"While creating a KafkaCloudValue value, an extra attribute value was detected. "+
					"A KafkaCloudValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra KafkaCloudValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewKafkaCloudValueUnknown(), diags
	}

	batchSizeAttribute, ok := attributes["batch_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`batch_size is missing from object`)

		return NewKafkaCloudValueUnknown(), diags
	}

	batchSizeVal, ok := batchSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`batch_size expected to be basetypes.Int64Value, was: %T`, batchSizeAttribute))
	}

	bootstrapServersAttribute, ok := attributes["bootstrap_servers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bootstrap_servers is missing from object`)

		return NewKafkaCloudValueUnknown(), diags
	}

	bootstrapServersVal, ok := bootstrapServersAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bootstrap_servers expected to be basetypes.StringValue, was: %T`, bootstrapServersAttribute))
	}

	groupIdAttribute, ok := attributes["group_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`group_id is missing from object`)

		return NewKafkaCloudValueUnknown(), diags
	}

	groupIdVal, ok := groupIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`group_id expected to be basetypes.StringValue, was: %T`, groupIdAttribute))
	}

	kafkaApiKeyAttribute, ok := attributes["kafka_api_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`kafka_api_key is missing from object`)

		return NewKafkaCloudValueUnknown(), diags
	}

	kafkaApiKeyVal, ok := kafkaApiKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`kafka_api_key expected to be basetypes.StringValue, was: %T`, kafkaApiKeyAttribute))
	}

	portAttribute, ok := attributes["port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port is missing from object`)

		return NewKafkaCloudValueUnknown(), diags
	}

	portVal, ok := portAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port expected to be basetypes.Int64Value, was: %T`, portAttribute))
	}

	secretAttribute, ok := attributes["secret"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`secret is missing from object`)

		return NewKafkaCloudValueUnknown(), diags
	}

	secretVal, ok := secretAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`secret expected to be basetypes.StringValue, was: %T`, secretAttribute))
	}

	topicAttribute, ok := attributes["topic"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`topic is missing from object`)

		return NewKafkaCloudValueUnknown(), diags
	}

	topicVal, ok := topicAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`topic expected to be basetypes.StringValue, was: %T`, topicAttribute))
	}

	if diags.HasError() {
		return NewKafkaCloudValueUnknown(), diags
	}

	return KafkaCloudValue{
		BatchSize:        batchSizeVal,
		BootstrapServers: bootstrapServersVal,
		GroupId:          groupIdVal,
		KafkaApiKey:      kafkaApiKeyVal,
		Port:             portVal,
		Secret:           secretVal,
		Topic:            topicVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewKafkaCloudValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) KafkaCloudValue {
	object, diags := NewKafkaCloudValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewKafkaCloudValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t KafkaCloudType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewKafkaCloudValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewKafkaCloudValueUnknown(), nil
	}

	if in.IsNull() {
		return NewKafkaCloudValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewKafkaCloudValueMust(KafkaCloudValue{}.AttributeTypes(ctx), attributes), nil
}

func (t KafkaCloudType) ValueType(ctx context.Context) attr.Value {
	return KafkaCloudValue{}
}

var _ basetypes.ObjectValuable = KafkaCloudValue{}

type KafkaCloudValue struct {
	BatchSize        basetypes.Int64Value  `tfsdk:"batch_size"`
	BootstrapServers basetypes.StringValue `tfsdk:"bootstrap_servers"`
	GroupId          basetypes.StringValue `tfsdk:"group_id"`
	KafkaApiKey      basetypes.StringValue `tfsdk:"kafka_api_key"`
	Port             basetypes.Int64Value  `tfsdk:"port"`
	Secret           basetypes.StringValue `tfsdk:"secret"`
	Topic            basetypes.StringValue `tfsdk:"topic"`
	state            attr.ValueState
}

func (v KafkaCloudValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 7)

	var val tftypes.Value
	var err error

	attrTypes["batch_size"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["bootstrap_servers"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["group_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["kafka_api_key"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["port"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["secret"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["topic"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 7)

		val, err = v.BatchSize.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["batch_size"] = val

		val, err = v.BootstrapServers.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bootstrap_servers"] = val

		val, err = v.GroupId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["group_id"] = val

		val, err = v.KafkaApiKey.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["kafka_api_key"] = val

		val, err = v.Port.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port"] = val

		val, err = v.Secret.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["secret"] = val

		val, err = v.Topic.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["topic"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v KafkaCloudValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v KafkaCloudValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v KafkaCloudValue) String() string {
	return "KafkaCloudValue"
}

func (v KafkaCloudValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"batch_size":        basetypes.Int64Type{},
		"bootstrap_servers": basetypes.StringType{},
		"group_id":          basetypes.StringType{},
		"kafka_api_key":     basetypes.StringType{},
		"port":              basetypes.Int64Type{},
		"secret":            basetypes.StringType{},
		"topic":             basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"batch_size":        v.BatchSize,
			"bootstrap_servers": v.BootstrapServers,
			"group_id":          v.GroupId,
			"kafka_api_key":     v.KafkaApiKey,
			"port":              v.Port,
			"secret":            v.Secret,
			"topic":             v.Topic,
		})

	return objVal, diags
}

func (v KafkaCloudValue) Equal(o attr.Value) bool {
	other, ok := o.(KafkaCloudValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.BatchSize.Equal(other.BatchSize) {
		return false
	}

	if !v.BootstrapServers.Equal(other.BootstrapServers) {
		return false
	}

	if !v.GroupId.Equal(other.GroupId) {
		return false
	}

	if !v.KafkaApiKey.Equal(other.KafkaApiKey) {
		return false
	}

	if !v.Port.Equal(other.Port) {
		return false
	}

	if !v.Secret.Equal(other.Secret) {
		return false
	}

	if !v.Topic.Equal(other.Topic) {
		return false
	}

	return true
}

func (v KafkaCloudValue) Type(ctx context.Context) attr.Type {
	return KafkaCloudType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v KafkaCloudValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"batch_size":        basetypes.Int64Type{},
		"bootstrap_servers": basetypes.StringType{},
		"group_id":          basetypes.StringType{},
		"kafka_api_key":     basetypes.StringType{},
		"port":              basetypes.Int64Type{},
		"secret":            basetypes.StringType{},
		"topic":             basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = MilvusType{}

type MilvusType struct {
	basetypes.ObjectType
}

func (t MilvusType) Equal(o attr.Type) bool {
	other, ok := o.(MilvusType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t MilvusType) String() string {
	return "MilvusType"
}

func (t MilvusType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	collectionNameAttribute, ok := attributes["collection_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`collection_name is missing from object`)

		return nil, diags
	}

	collectionNameVal, ok := collectionNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`collection_name expected to be basetypes.StringValue, was: %T`, collectionNameAttribute))
	}

	dbNameAttribute, ok := attributes["db_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`db_name is missing from object`)

		return nil, diags
	}

	dbNameVal, ok := dbNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`db_name expected to be basetypes.StringValue, was: %T`, dbNameAttribute))
	}

	passwordAttribute, ok := attributes["password"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`password is missing from object`)

		return nil, diags
	}

	passwordVal, ok := passwordAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`password expected to be basetypes.StringValue, was: %T`, passwordAttribute))
	}

	recordIdKeyAttribute, ok := attributes["record_id_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`record_id_key is missing from object`)

		return nil, diags
	}

	recordIdKeyVal, ok := recordIdKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`record_id_key expected to be basetypes.StringValue, was: %T`, recordIdKeyAttribute))
	}

	tokenAttribute, ok := attributes["token"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`token is missing from object`)

		return nil, diags
	}

	tokenVal, ok := tokenAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`token expected to be basetypes.StringValue, was: %T`, tokenAttribute))
	}

	uriAttribute, ok := attributes["uri"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uri is missing from object`)

		return nil, diags
	}

	uriVal, ok := uriAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uri expected to be basetypes.StringValue, was: %T`, uriAttribute))
	}

	userAttribute, ok := attributes["user"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`user is missing from object`)

		return nil, diags
	}

	userVal, ok := userAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`user expected to be basetypes.StringValue, was: %T`, userAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return MilvusValue{
		CollectionName: collectionNameVal,
		DbName:         dbNameVal,
		Password:       passwordVal,
		RecordIdKey:    recordIdKeyVal,
		Token:          tokenVal,
		Uri:            uriVal,
		User:           userVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewMilvusValueNull() MilvusValue {
	return MilvusValue{
		state: attr.ValueStateNull,
	}
}

func NewMilvusValueUnknown() MilvusValue {
	return MilvusValue{
		state: attr.ValueStateUnknown,
	}
}

func NewMilvusValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (MilvusValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing MilvusValue Attribute Value",
				"While creating a MilvusValue value, a missing attribute value was detected. "+
					"A MilvusValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MilvusValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid MilvusValue Attribute Type",
				"While creating a MilvusValue value, an invalid attribute value was detected. "+
					"A MilvusValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MilvusValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("MilvusValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra MilvusValue Attribute Value",
				"While creating a MilvusValue value, an extra attribute value was detected. "+
					"A MilvusValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra MilvusValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMilvusValueUnknown(), diags
	}

	collectionNameAttribute, ok := attributes["collection_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`collection_name is missing from object`)

		return NewMilvusValueUnknown(), diags
	}

	collectionNameVal, ok := collectionNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`collection_name expected to be basetypes.StringValue, was: %T`, collectionNameAttribute))
	}

	dbNameAttribute, ok := attributes["db_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`db_name is missing from object`)

		return NewMilvusValueUnknown(), diags
	}

	dbNameVal, ok := dbNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`db_name expected to be basetypes.StringValue, was: %T`, dbNameAttribute))
	}

	passwordAttribute, ok := attributes["password"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`password is missing from object`)

		return NewMilvusValueUnknown(), diags
	}

	passwordVal, ok := passwordAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`password expected to be basetypes.StringValue, was: %T`, passwordAttribute))
	}

	recordIdKeyAttribute, ok := attributes["record_id_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`record_id_key is missing from object`)

		return NewMilvusValueUnknown(), diags
	}

	recordIdKeyVal, ok := recordIdKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`record_id_key expected to be basetypes.StringValue, was: %T`, recordIdKeyAttribute))
	}

	tokenAttribute, ok := attributes["token"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`token is missing from object`)

		return NewMilvusValueUnknown(), diags
	}

	tokenVal, ok := tokenAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`token expected to be basetypes.StringValue, was: %T`, tokenAttribute))
	}

	uriAttribute, ok := attributes["uri"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uri is missing from object`)

		return NewMilvusValueUnknown(), diags
	}

	uriVal, ok := uriAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uri expected to be basetypes.StringValue, was: %T`, uriAttribute))
	}

	userAttribute, ok := attributes["user"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`user is missing from object`)

		return NewMilvusValueUnknown(), diags
	}

	userVal, ok := userAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`user expected to be basetypes.StringValue, was: %T`, userAttribute))
	}

	if diags.HasError() {
		return NewMilvusValueUnknown(), diags
	}

	return MilvusValue{
		CollectionName: collectionNameVal,
		DbName:         dbNameVal,
		Password:       passwordVal,
		RecordIdKey:    recordIdKeyVal,
		Token:          tokenVal,
		Uri:            uriVal,
		User:           userVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewMilvusValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) MilvusValue {
	object, diags := NewMilvusValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMilvusValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t MilvusType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMilvusValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMilvusValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMilvusValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMilvusValueMust(MilvusValue{}.AttributeTypes(ctx), attributes), nil
}

func (t MilvusType) ValueType(ctx context.Context) attr.Value {
	return MilvusValue{}
}

var _ basetypes.ObjectValuable = MilvusValue{}

type MilvusValue struct {
	CollectionName basetypes.StringValue `tfsdk:"collection_name"`
	DbName         basetypes.StringValue `tfsdk:"db_name"`
	Password       basetypes.StringValue `tfsdk:"password"`
	RecordIdKey    basetypes.StringValue `tfsdk:"record_id_key"`
	Token          basetypes.StringValue `tfsdk:"token"`
	Uri            basetypes.StringValue `tfsdk:"uri"`
	User           basetypes.StringValue `tfsdk:"user"`
	state          attr.ValueState
}

func (v MilvusValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 7)

	var val tftypes.Value
	var err error

	attrTypes["collection_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["db_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["password"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["record_id_key"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["token"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["uri"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["user"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 7)

		val, err = v.CollectionName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["collection_name"] = val

		val, err = v.DbName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["db_name"] = val

		val, err = v.Password.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["password"] = val

		val, err = v.RecordIdKey.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["record_id_key"] = val

		val, err = v.Token.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["token"] = val

		val, err = v.Uri.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["uri"] = val

		val, err = v.User.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["user"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v MilvusValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v MilvusValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v MilvusValue) String() string {
	return "MilvusValue"
}

func (v MilvusValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"collection_name": basetypes.StringType{},
		"db_name":         basetypes.StringType{},
		"password":        basetypes.StringType{},
		"record_id_key":   basetypes.StringType{},
		"token":           basetypes.StringType{},
		"uri":             basetypes.StringType{},
		"user":            basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"collection_name": v.CollectionName,
			"db_name":         v.DbName,
			"password":        v.Password,
			"record_id_key":   v.RecordIdKey,
			"token":           v.Token,
			"uri":             v.Uri,
			"user":            v.User,
		})

	return objVal, diags
}

func (v MilvusValue) Equal(o attr.Value) bool {
	other, ok := o.(MilvusValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.CollectionName.Equal(other.CollectionName) {
		return false
	}

	if !v.DbName.Equal(other.DbName) {
		return false
	}

	if !v.Password.Equal(other.Password) {
		return false
	}

	if !v.RecordIdKey.Equal(other.RecordIdKey) {
		return false
	}

	if !v.Token.Equal(other.Token) {
		return false
	}

	if !v.Uri.Equal(other.Uri) {
		return false
	}

	if !v.User.Equal(other.User) {
		return false
	}

	return true
}

func (v MilvusValue) Type(ctx context.Context) attr.Type {
	return MilvusType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v MilvusValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"collection_name": basetypes.StringType{},
		"db_name":         basetypes.StringType{},
		"password":        basetypes.StringType{},
		"record_id_key":   basetypes.StringType{},
		"token":           basetypes.StringType{},
		"uri":             basetypes.StringType{},
		"user":            basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = MongodbType{}

type MongodbType struct {
	basetypes.ObjectType
}

func (t MongodbType) Equal(o attr.Type) bool {
	other, ok := o.(MongodbType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t MongodbType) String() string {
	return "MongodbType"
}

func (t MongodbType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	collectionAttribute, ok := attributes["collection"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`collection is missing from object`)

		return nil, diags
	}

	collectionVal, ok := collectionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`collection expected to be basetypes.StringValue, was: %T`, collectionAttribute))
	}

	databaseAttribute, ok := attributes["database"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`database is missing from object`)

		return nil, diags
	}

	databaseVal, ok := databaseAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`database expected to be basetypes.StringValue, was: %T`, databaseAttribute))
	}

	uriAttribute, ok := attributes["uri"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uri is missing from object`)

		return nil, diags
	}

	uriVal, ok := uriAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uri expected to be basetypes.StringValue, was: %T`, uriAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return MongodbValue{
		Collection: collectionVal,
		Database:   databaseVal,
		Uri:        uriVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewMongodbValueNull() MongodbValue {
	return MongodbValue{
		state: attr.ValueStateNull,
	}
}

func NewMongodbValueUnknown() MongodbValue {
	return MongodbValue{
		state: attr.ValueStateUnknown,
	}
}

func NewMongodbValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (MongodbValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing MongodbValue Attribute Value",
				"While creating a MongodbValue value, a missing attribute value was detected. "+
					"A MongodbValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MongodbValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid MongodbValue Attribute Type",
				"While creating a MongodbValue value, an invalid attribute value was detected. "+
					"A MongodbValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MongodbValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("MongodbValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra MongodbValue Attribute Value",
				"While creating a MongodbValue value, an extra attribute value was detected. "+
					"A MongodbValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra MongodbValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMongodbValueUnknown(), diags
	}

	collectionAttribute, ok := attributes["collection"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`collection is missing from object`)

		return NewMongodbValueUnknown(), diags
	}

	collectionVal, ok := collectionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`collection expected to be basetypes.StringValue, was: %T`, collectionAttribute))
	}

	databaseAttribute, ok := attributes["database"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`database is missing from object`)

		return NewMongodbValueUnknown(), diags
	}

	databaseVal, ok := databaseAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`database expected to be basetypes.StringValue, was: %T`, databaseAttribute))
	}

	uriAttribute, ok := attributes["uri"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uri is missing from object`)

		return NewMongodbValueUnknown(), diags
	}

	uriVal, ok := uriAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uri expected to be basetypes.StringValue, was: %T`, uriAttribute))
	}

	if diags.HasError() {
		return NewMongodbValueUnknown(), diags
	}

	return MongodbValue{
		Collection: collectionVal,
		Database:   databaseVal,
		Uri:        uriVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewMongodbValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) MongodbValue {
	object, diags := NewMongodbValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMongodbValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t MongodbType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMongodbValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMongodbValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMongodbValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMongodbValueMust(MongodbValue{}.AttributeTypes(ctx), attributes), nil
}

func (t MongodbType) ValueType(ctx context.Context) attr.Value {
	return MongodbValue{}
}

var _ basetypes.ObjectValuable = MongodbValue{}

type MongodbValue struct {
	Collection basetypes.StringValue `tfsdk:"collection"`
	Database   basetypes.StringValue `tfsdk:"database"`
	Uri        basetypes.StringValue `tfsdk:"uri"`
	state      attr.ValueState
}

func (v MongodbValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["collection"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["database"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["uri"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Collection.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["collection"] = val

		val, err = v.Database.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["database"] = val

		val, err = v.Uri.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["uri"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v MongodbValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v MongodbValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v MongodbValue) String() string {
	return "MongodbValue"
}

func (v MongodbValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"collection": basetypes.StringType{},
		"database":   basetypes.StringType{},
		"uri":        basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"collection": v.Collection,
			"database":   v.Database,
			"uri":        v.Uri,
		})

	return objVal, diags
}

func (v MongodbValue) Equal(o attr.Value) bool {
	other, ok := o.(MongodbValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Collection.Equal(other.Collection) {
		return false
	}

	if !v.Database.Equal(other.Database) {
		return false
	}

	if !v.Uri.Equal(other.Uri) {
		return false
	}

	return true
}

func (v MongodbValue) Type(ctx context.Context) attr.Type {
	return MongodbType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v MongodbValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"collection": basetypes.StringType{},
		"database":   basetypes.StringType{},
		"uri":        basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = MotherduckType{}

type MotherduckType struct {
	basetypes.ObjectType
}

func (t MotherduckType) Equal(o attr.Type) bool {
	other, ok := o.(MotherduckType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t MotherduckType) String() string {
	return "MotherduckType"
}

func (t MotherduckType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	accountAttribute, ok := attributes["account"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`account is missing from object`)

		return nil, diags
	}

	accountVal, ok := accountAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`account expected to be basetypes.StringValue, was: %T`, accountAttribute))
	}

	batchSizeAttribute, ok := attributes["batch_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`batch_size is missing from object`)

		return nil, diags
	}

	batchSizeVal, ok := batchSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`batch_size expected to be basetypes.Int64Value, was: %T`, batchSizeAttribute))
	}

	databaseAttribute, ok := attributes["database"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`database is missing from object`)

		return nil, diags
	}

	databaseVal, ok := databaseAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`database expected to be basetypes.StringValue, was: %T`, databaseAttribute))
	}

	hostAttribute, ok := attributes["host"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`host is missing from object`)

		return nil, diags
	}

	hostVal, ok := hostAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`host expected to be basetypes.StringValue, was: %T`, hostAttribute))
	}

	passwordAttribute, ok := attributes["password"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`password is missing from object`)

		return nil, diags
	}

	passwordVal, ok := passwordAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`password expected to be basetypes.StringValue, was: %T`, passwordAttribute))
	}

	portAttribute, ok := attributes["port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port is missing from object`)

		return nil, diags
	}

	portVal, ok := portAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port expected to be basetypes.Int64Value, was: %T`, portAttribute))
	}

	recordIdKeyAttribute, ok := attributes["record_id_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`record_id_key is missing from object`)

		return nil, diags
	}

	recordIdKeyVal, ok := recordIdKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`record_id_key expected to be basetypes.StringValue, was: %T`, recordIdKeyAttribute))
	}

	roleAttribute, ok := attributes["role"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`role is missing from object`)

		return nil, diags
	}

	roleVal, ok := roleAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`role expected to be basetypes.StringValue, was: %T`, roleAttribute))
	}

	schemaAttribute, ok := attributes["schema"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`schema is missing from object`)

		return nil, diags
	}

	schemaVal, ok := schemaAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`schema expected to be basetypes.StringValue, was: %T`, schemaAttribute))
	}

	tableNameAttribute, ok := attributes["table_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`table_name is missing from object`)

		return nil, diags
	}

	tableNameVal, ok := tableNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`table_name expected to be basetypes.StringValue, was: %T`, tableNameAttribute))
	}

	userAttribute, ok := attributes["user"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`user is missing from object`)

		return nil, diags
	}

	userVal, ok := userAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`user expected to be basetypes.StringValue, was: %T`, userAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return MotherduckValue{
		Account:     accountVal,
		BatchSize:   batchSizeVal,
		Database:    databaseVal,
		Host:        hostVal,
		Password:    passwordVal,
		Port:        portVal,
		RecordIdKey: recordIdKeyVal,
		Role:        roleVal,
		Schema:      schemaVal,
		TableName:   tableNameVal,
		User:        userVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewMotherduckValueNull() MotherduckValue {
	return MotherduckValue{
		state: attr.ValueStateNull,
	}
}

func NewMotherduckValueUnknown() MotherduckValue {
	return MotherduckValue{
		state: attr.ValueStateUnknown,
	}
}

func NewMotherduckValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (MotherduckValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing MotherduckValue Attribute Value",
				"While creating a MotherduckValue value, a missing attribute value was detected. "+
					"A MotherduckValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MotherduckValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid MotherduckValue Attribute Type",
				"While creating a MotherduckValue value, an invalid attribute value was detected. "+
					"A MotherduckValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MotherduckValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("MotherduckValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra MotherduckValue Attribute Value",
				"While creating a MotherduckValue value, an extra attribute value was detected. "+
					"A MotherduckValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra MotherduckValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMotherduckValueUnknown(), diags
	}

	accountAttribute, ok := attributes["account"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`account is missing from object`)

		return NewMotherduckValueUnknown(), diags
	}

	accountVal, ok := accountAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`account expected to be basetypes.StringValue, was: %T`, accountAttribute))
	}

	batchSizeAttribute, ok := attributes["batch_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`batch_size is missing from object`)

		return NewMotherduckValueUnknown(), diags
	}

	batchSizeVal, ok := batchSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`batch_size expected to be basetypes.Int64Value, was: %T`, batchSizeAttribute))
	}

	databaseAttribute, ok := attributes["database"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`database is missing from object`)

		return NewMotherduckValueUnknown(), diags
	}

	databaseVal, ok := databaseAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`database expected to be basetypes.StringValue, was: %T`, databaseAttribute))
	}

	hostAttribute, ok := attributes["host"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`host is missing from object`)

		return NewMotherduckValueUnknown(), diags
	}

	hostVal, ok := hostAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`host expected to be basetypes.StringValue, was: %T`, hostAttribute))
	}

	passwordAttribute, ok := attributes["password"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`password is missing from object`)

		return NewMotherduckValueUnknown(), diags
	}

	passwordVal, ok := passwordAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`password expected to be basetypes.StringValue, was: %T`, passwordAttribute))
	}

	portAttribute, ok := attributes["port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port is missing from object`)

		return NewMotherduckValueUnknown(), diags
	}

	portVal, ok := portAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port expected to be basetypes.Int64Value, was: %T`, portAttribute))
	}

	recordIdKeyAttribute, ok := attributes["record_id_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`record_id_key is missing from object`)

		return NewMotherduckValueUnknown(), diags
	}

	recordIdKeyVal, ok := recordIdKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`record_id_key expected to be basetypes.StringValue, was: %T`, recordIdKeyAttribute))
	}

	roleAttribute, ok := attributes["role"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`role is missing from object`)

		return NewMotherduckValueUnknown(), diags
	}

	roleVal, ok := roleAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`role expected to be basetypes.StringValue, was: %T`, roleAttribute))
	}

	schemaAttribute, ok := attributes["schema"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`schema is missing from object`)

		return NewMotherduckValueUnknown(), diags
	}

	schemaVal, ok := schemaAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`schema expected to be basetypes.StringValue, was: %T`, schemaAttribute))
	}

	tableNameAttribute, ok := attributes["table_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`table_name is missing from object`)

		return NewMotherduckValueUnknown(), diags
	}

	tableNameVal, ok := tableNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`table_name expected to be basetypes.StringValue, was: %T`, tableNameAttribute))
	}

	userAttribute, ok := attributes["user"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`user is missing from object`)

		return NewMotherduckValueUnknown(), diags
	}

	userVal, ok := userAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`user expected to be basetypes.StringValue, was: %T`, userAttribute))
	}

	if diags.HasError() {
		return NewMotherduckValueUnknown(), diags
	}

	return MotherduckValue{
		Account:     accountVal,
		BatchSize:   batchSizeVal,
		Database:    databaseVal,
		Host:        hostVal,
		Password:    passwordVal,
		Port:        portVal,
		RecordIdKey: recordIdKeyVal,
		Role:        roleVal,
		Schema:      schemaVal,
		TableName:   tableNameVal,
		User:        userVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewMotherduckValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) MotherduckValue {
	object, diags := NewMotherduckValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMotherduckValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t MotherduckType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMotherduckValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMotherduckValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMotherduckValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMotherduckValueMust(MotherduckValue{}.AttributeTypes(ctx), attributes), nil
}

func (t MotherduckType) ValueType(ctx context.Context) attr.Value {
	return MotherduckValue{}
}

var _ basetypes.ObjectValuable = MotherduckValue{}

type MotherduckValue struct {
	Account     basetypes.StringValue `tfsdk:"account"`
	BatchSize   basetypes.Int64Value  `tfsdk:"batch_size"`
	Database    basetypes.StringValue `tfsdk:"database"`
	Host        basetypes.StringValue `tfsdk:"host"`
	Password    basetypes.StringValue `tfsdk:"password"`
	Port        basetypes.Int64Value  `tfsdk:"port"`
	RecordIdKey basetypes.StringValue `tfsdk:"record_id_key"`
	Role        basetypes.StringValue `tfsdk:"role"`
	Schema      basetypes.StringValue `tfsdk:"schema"`
	TableName   basetypes.StringValue `tfsdk:"table_name"`
	User        basetypes.StringValue `tfsdk:"user"`
	state       attr.ValueState
}

func (v MotherduckValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 11)

	var val tftypes.Value
	var err error

	attrTypes["account"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["batch_size"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["database"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["host"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["password"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["port"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["record_id_key"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["role"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["schema"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["table_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["user"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 11)

		val, err = v.Account.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["account"] = val

		val, err = v.BatchSize.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["batch_size"] = val

		val, err = v.Database.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["database"] = val

		val, err = v.Host.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["host"] = val

		val, err = v.Password.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["password"] = val

		val, err = v.Port.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port"] = val

		val, err = v.RecordIdKey.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["record_id_key"] = val

		val, err = v.Role.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["role"] = val

		val, err = v.Schema.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["schema"] = val

		val, err = v.TableName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["table_name"] = val

		val, err = v.User.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["user"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v MotherduckValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v MotherduckValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v MotherduckValue) String() string {
	return "MotherduckValue"
}

func (v MotherduckValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"account":       basetypes.StringType{},
		"batch_size":    basetypes.Int64Type{},
		"database":      basetypes.StringType{},
		"host":          basetypes.StringType{},
		"password":      basetypes.StringType{},
		"port":          basetypes.Int64Type{},
		"record_id_key": basetypes.StringType{},
		"role":          basetypes.StringType{},
		"schema":        basetypes.StringType{},
		"table_name":    basetypes.StringType{},
		"user":          basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"account":       v.Account,
			"batch_size":    v.BatchSize,
			"database":      v.Database,
			"host":          v.Host,
			"password":      v.Password,
			"port":          v.Port,
			"record_id_key": v.RecordIdKey,
			"role":          v.Role,
			"schema":        v.Schema,
			"table_name":    v.TableName,
			"user":          v.User,
		})

	return objVal, diags
}

func (v MotherduckValue) Equal(o attr.Value) bool {
	other, ok := o.(MotherduckValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Account.Equal(other.Account) {
		return false
	}

	if !v.BatchSize.Equal(other.BatchSize) {
		return false
	}

	if !v.Database.Equal(other.Database) {
		return false
	}

	if !v.Host.Equal(other.Host) {
		return false
	}

	if !v.Password.Equal(other.Password) {
		return false
	}

	if !v.Port.Equal(other.Port) {
		return false
	}

	if !v.RecordIdKey.Equal(other.RecordIdKey) {
		return false
	}

	if !v.Role.Equal(other.Role) {
		return false
	}

	if !v.Schema.Equal(other.Schema) {
		return false
	}

	if !v.TableName.Equal(other.TableName) {
		return false
	}

	if !v.User.Equal(other.User) {
		return false
	}

	return true
}

func (v MotherduckValue) Type(ctx context.Context) attr.Type {
	return MotherduckType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v MotherduckValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"account":       basetypes.StringType{},
		"batch_size":    basetypes.Int64Type{},
		"database":      basetypes.StringType{},
		"host":          basetypes.StringType{},
		"password":      basetypes.StringType{},
		"port":          basetypes.Int64Type{},
		"record_id_key": basetypes.StringType{},
		"role":          basetypes.StringType{},
		"schema":        basetypes.StringType{},
		"table_name":    basetypes.StringType{},
		"user":          basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = Neo4jType{}

type Neo4jType struct {
	basetypes.ObjectType
}

func (t Neo4jType) Equal(o attr.Type) bool {
	other, ok := o.(Neo4jType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Neo4jType) String() string {
	return "Neo4jType"
}

func (t Neo4jType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	batchSizeAttribute, ok := attributes["batch_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`batch_size is missing from object`)

		return nil, diags
	}

	batchSizeVal, ok := batchSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`batch_size expected to be basetypes.Int64Value, was: %T`, batchSizeAttribute))
	}

	databaseAttribute, ok := attributes["database"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`database is missing from object`)

		return nil, diags
	}

	databaseVal, ok := databaseAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`database expected to be basetypes.StringValue, was: %T`, databaseAttribute))
	}

	passwordAttribute, ok := attributes["password"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`password is missing from object`)

		return nil, diags
	}

	passwordVal, ok := passwordAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`password expected to be basetypes.StringValue, was: %T`, passwordAttribute))
	}

	uriAttribute, ok := attributes["uri"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uri is missing from object`)

		return nil, diags
	}

	uriVal, ok := uriAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uri expected to be basetypes.StringValue, was: %T`, uriAttribute))
	}

	usernameAttribute, ok := attributes["username"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`username is missing from object`)

		return nil, diags
	}

	usernameVal, ok := usernameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`username expected to be basetypes.StringValue, was: %T`, usernameAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Neo4jValue{
		BatchSize: batchSizeVal,
		Database:  databaseVal,
		Password:  passwordVal,
		Uri:       uriVal,
		Username:  usernameVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewNeo4jValueNull() Neo4jValue {
	return Neo4jValue{
		state: attr.ValueStateNull,
	}
}

func NewNeo4jValueUnknown() Neo4jValue {
	return Neo4jValue{
		state: attr.ValueStateUnknown,
	}
}

func NewNeo4jValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Neo4jValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Neo4jValue Attribute Value",
				"While creating a Neo4jValue value, a missing attribute value was detected. "+
					"A Neo4jValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Neo4jValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Neo4jValue Attribute Type",
				"While creating a Neo4jValue value, an invalid attribute value was detected. "+
					"A Neo4jValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Neo4jValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Neo4jValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Neo4jValue Attribute Value",
				"While creating a Neo4jValue value, an extra attribute value was detected. "+
					"A Neo4jValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Neo4jValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewNeo4jValueUnknown(), diags
	}

	batchSizeAttribute, ok := attributes["batch_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`batch_size is missing from object`)

		return NewNeo4jValueUnknown(), diags
	}

	batchSizeVal, ok := batchSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`batch_size expected to be basetypes.Int64Value, was: %T`, batchSizeAttribute))
	}

	databaseAttribute, ok := attributes["database"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`database is missing from object`)

		return NewNeo4jValueUnknown(), diags
	}

	databaseVal, ok := databaseAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`database expected to be basetypes.StringValue, was: %T`, databaseAttribute))
	}

	passwordAttribute, ok := attributes["password"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`password is missing from object`)

		return NewNeo4jValueUnknown(), diags
	}

	passwordVal, ok := passwordAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`password expected to be basetypes.StringValue, was: %T`, passwordAttribute))
	}

	uriAttribute, ok := attributes["uri"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uri is missing from object`)

		return NewNeo4jValueUnknown(), diags
	}

	uriVal, ok := uriAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uri expected to be basetypes.StringValue, was: %T`, uriAttribute))
	}

	usernameAttribute, ok := attributes["username"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`username is missing from object`)

		return NewNeo4jValueUnknown(), diags
	}

	usernameVal, ok := usernameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`username expected to be basetypes.StringValue, was: %T`, usernameAttribute))
	}

	if diags.HasError() {
		return NewNeo4jValueUnknown(), diags
	}

	return Neo4jValue{
		BatchSize: batchSizeVal,
		Database:  databaseVal,
		Password:  passwordVal,
		Uri:       uriVal,
		Username:  usernameVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewNeo4jValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Neo4jValue {
	object, diags := NewNeo4jValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewNeo4jValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Neo4jType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewNeo4jValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewNeo4jValueUnknown(), nil
	}

	if in.IsNull() {
		return NewNeo4jValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewNeo4jValueMust(Neo4jValue{}.AttributeTypes(ctx), attributes), nil
}

func (t Neo4jType) ValueType(ctx context.Context) attr.Value {
	return Neo4jValue{}
}

var _ basetypes.ObjectValuable = Neo4jValue{}

type Neo4jValue struct {
	BatchSize basetypes.Int64Value  `tfsdk:"batch_size"`
	Database  basetypes.StringValue `tfsdk:"database"`
	Password  basetypes.StringValue `tfsdk:"password"`
	Uri       basetypes.StringValue `tfsdk:"uri"`
	Username  basetypes.StringValue `tfsdk:"username"`
	state     attr.ValueState
}

func (v Neo4jValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["batch_size"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["database"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["password"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["uri"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["username"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.BatchSize.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["batch_size"] = val

		val, err = v.Database.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["database"] = val

		val, err = v.Password.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["password"] = val

		val, err = v.Uri.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["uri"] = val

		val, err = v.Username.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["username"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Neo4jValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Neo4jValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Neo4jValue) String() string {
	return "Neo4jValue"
}

func (v Neo4jValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"batch_size": basetypes.Int64Type{},
		"database":   basetypes.StringType{},
		"password":   basetypes.StringType{},
		"uri":        basetypes.StringType{},
		"username":   basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"batch_size": v.BatchSize,
			"database":   v.Database,
			"password":   v.Password,
			"uri":        v.Uri,
			"username":   v.Username,
		})

	return objVal, diags
}

func (v Neo4jValue) Equal(o attr.Value) bool {
	other, ok := o.(Neo4jValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.BatchSize.Equal(other.BatchSize) {
		return false
	}

	if !v.Database.Equal(other.Database) {
		return false
	}

	if !v.Password.Equal(other.Password) {
		return false
	}

	if !v.Uri.Equal(other.Uri) {
		return false
	}

	if !v.Username.Equal(other.Username) {
		return false
	}

	return true
}

func (v Neo4jValue) Type(ctx context.Context) attr.Type {
	return Neo4jType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Neo4jValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"batch_size": basetypes.Int64Type{},
		"database":   basetypes.StringType{},
		"password":   basetypes.StringType{},
		"uri":        basetypes.StringType{},
		"username":   basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = OnedriveType{}

type OnedriveType struct {
	basetypes.ObjectType
}

func (t OnedriveType) Equal(o attr.Type) bool {
	other, ok := o.(OnedriveType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t OnedriveType) String() string {
	return "OnedriveType"
}

func (t OnedriveType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	authorityUrlAttribute, ok := attributes["authority_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`authority_url is missing from object`)

		return nil, diags
	}

	authorityUrlVal, ok := authorityUrlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`authority_url expected to be basetypes.StringValue, was: %T`, authorityUrlAttribute))
	}

	clientCredAttribute, ok := attributes["client_cred"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`client_cred is missing from object`)

		return nil, diags
	}

	clientCredVal, ok := clientCredAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`client_cred expected to be basetypes.StringValue, was: %T`, clientCredAttribute))
	}

	clientIdAttribute, ok := attributes["client_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`client_id is missing from object`)

		return nil, diags
	}

	clientIdVal, ok := clientIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`client_id expected to be basetypes.StringValue, was: %T`, clientIdAttribute))
	}

	pathAttribute, ok := attributes["path"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`path is missing from object`)

		return nil, diags
	}

	pathVal, ok := pathAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`path expected to be basetypes.StringValue, was: %T`, pathAttribute))
	}

	recursiveAttribute, ok := attributes["recursive"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`recursive is missing from object`)

		return nil, diags
	}

	recursiveVal, ok := recursiveAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`recursive expected to be basetypes.BoolValue, was: %T`, recursiveAttribute))
	}

	tenantAttribute, ok := attributes["tenant"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tenant is missing from object`)

		return nil, diags
	}

	tenantVal, ok := tenantAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tenant expected to be basetypes.StringValue, was: %T`, tenantAttribute))
	}

	userPnameAttribute, ok := attributes["user_pname"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`user_pname is missing from object`)

		return nil, diags
	}

	userPnameVal, ok := userPnameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`user_pname expected to be basetypes.StringValue, was: %T`, userPnameAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return OnedriveValue{
		AuthorityUrl: authorityUrlVal,
		ClientCred:   clientCredVal,
		ClientId:     clientIdVal,
		Path:         pathVal,
		Recursive:    recursiveVal,
		Tenant:       tenantVal,
		UserPname:    userPnameVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewOnedriveValueNull() OnedriveValue {
	return OnedriveValue{
		state: attr.ValueStateNull,
	}
}

func NewOnedriveValueUnknown() OnedriveValue {
	return OnedriveValue{
		state: attr.ValueStateUnknown,
	}
}

func NewOnedriveValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (OnedriveValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing OnedriveValue Attribute Value",
				"While creating a OnedriveValue value, a missing attribute value was detected. "+
					"A OnedriveValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OnedriveValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid OnedriveValue Attribute Type",
				"While creating a OnedriveValue value, an invalid attribute value was detected. "+
					"A OnedriveValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OnedriveValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("OnedriveValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra OnedriveValue Attribute Value",
				"While creating a OnedriveValue value, an extra attribute value was detected. "+
					"A OnedriveValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra OnedriveValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewOnedriveValueUnknown(), diags
	}

	authorityUrlAttribute, ok := attributes["authority_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`authority_url is missing from object`)

		return NewOnedriveValueUnknown(), diags
	}

	authorityUrlVal, ok := authorityUrlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`authority_url expected to be basetypes.StringValue, was: %T`, authorityUrlAttribute))
	}

	clientCredAttribute, ok := attributes["client_cred"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`client_cred is missing from object`)

		return NewOnedriveValueUnknown(), diags
	}

	clientCredVal, ok := clientCredAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`client_cred expected to be basetypes.StringValue, was: %T`, clientCredAttribute))
	}

	clientIdAttribute, ok := attributes["client_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`client_id is missing from object`)

		return NewOnedriveValueUnknown(), diags
	}

	clientIdVal, ok := clientIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`client_id expected to be basetypes.StringValue, was: %T`, clientIdAttribute))
	}

	pathAttribute, ok := attributes["path"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`path is missing from object`)

		return NewOnedriveValueUnknown(), diags
	}

	pathVal, ok := pathAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`path expected to be basetypes.StringValue, was: %T`, pathAttribute))
	}

	recursiveAttribute, ok := attributes["recursive"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`recursive is missing from object`)

		return NewOnedriveValueUnknown(), diags
	}

	recursiveVal, ok := recursiveAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`recursive expected to be basetypes.BoolValue, was: %T`, recursiveAttribute))
	}

	tenantAttribute, ok := attributes["tenant"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tenant is missing from object`)

		return NewOnedriveValueUnknown(), diags
	}

	tenantVal, ok := tenantAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tenant expected to be basetypes.StringValue, was: %T`, tenantAttribute))
	}

	userPnameAttribute, ok := attributes["user_pname"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`user_pname is missing from object`)

		return NewOnedriveValueUnknown(), diags
	}

	userPnameVal, ok := userPnameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`user_pname expected to be basetypes.StringValue, was: %T`, userPnameAttribute))
	}

	if diags.HasError() {
		return NewOnedriveValueUnknown(), diags
	}

	return OnedriveValue{
		AuthorityUrl: authorityUrlVal,
		ClientCred:   clientCredVal,
		ClientId:     clientIdVal,
		Path:         pathVal,
		Recursive:    recursiveVal,
		Tenant:       tenantVal,
		UserPname:    userPnameVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewOnedriveValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) OnedriveValue {
	object, diags := NewOnedriveValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewOnedriveValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t OnedriveType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewOnedriveValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewOnedriveValueUnknown(), nil
	}

	if in.IsNull() {
		return NewOnedriveValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewOnedriveValueMust(OnedriveValue{}.AttributeTypes(ctx), attributes), nil
}

func (t OnedriveType) ValueType(ctx context.Context) attr.Value {
	return OnedriveValue{}
}

var _ basetypes.ObjectValuable = OnedriveValue{}

type OnedriveValue struct {
	AuthorityUrl basetypes.StringValue `tfsdk:"authority_url"`
	ClientCred   basetypes.StringValue `tfsdk:"client_cred"`
	ClientId     basetypes.StringValue `tfsdk:"client_id"`
	Path         basetypes.StringValue `tfsdk:"path"`
	Recursive    basetypes.BoolValue   `tfsdk:"recursive"`
	Tenant       basetypes.StringValue `tfsdk:"tenant"`
	UserPname    basetypes.StringValue `tfsdk:"user_pname"`
	state        attr.ValueState
}

func (v OnedriveValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 7)

	var val tftypes.Value
	var err error

	attrTypes["authority_url"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["client_cred"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["client_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["path"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["recursive"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["tenant"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["user_pname"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 7)

		val, err = v.AuthorityUrl.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["authority_url"] = val

		val, err = v.ClientCred.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["client_cred"] = val

		val, err = v.ClientId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["client_id"] = val

		val, err = v.Path.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["path"] = val

		val, err = v.Recursive.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["recursive"] = val

		val, err = v.Tenant.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tenant"] = val

		val, err = v.UserPname.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["user_pname"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v OnedriveValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v OnedriveValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v OnedriveValue) String() string {
	return "OnedriveValue"
}

func (v OnedriveValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"authority_url": basetypes.StringType{},
		"client_cred":   basetypes.StringType{},
		"client_id":     basetypes.StringType{},
		"path":          basetypes.StringType{},
		"recursive":     basetypes.BoolType{},
		"tenant":        basetypes.StringType{},
		"user_pname":    basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"authority_url": v.AuthorityUrl,
			"client_cred":   v.ClientCred,
			"client_id":     v.ClientId,
			"path":          v.Path,
			"recursive":     v.Recursive,
			"tenant":        v.Tenant,
			"user_pname":    v.UserPname,
		})

	return objVal, diags
}

func (v OnedriveValue) Equal(o attr.Value) bool {
	other, ok := o.(OnedriveValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AuthorityUrl.Equal(other.AuthorityUrl) {
		return false
	}

	if !v.ClientCred.Equal(other.ClientCred) {
		return false
	}

	if !v.ClientId.Equal(other.ClientId) {
		return false
	}

	if !v.Path.Equal(other.Path) {
		return false
	}

	if !v.Recursive.Equal(other.Recursive) {
		return false
	}

	if !v.Tenant.Equal(other.Tenant) {
		return false
	}

	if !v.UserPname.Equal(other.UserPname) {
		return false
	}

	return true
}

func (v OnedriveValue) Type(ctx context.Context) attr.Type {
	return OnedriveType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v OnedriveValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"authority_url": basetypes.StringType{},
		"client_cred":   basetypes.StringType{},
		"client_id":     basetypes.StringType{},
		"path":          basetypes.StringType{},
		"recursive":     basetypes.BoolType{},
		"tenant":        basetypes.StringType{},
		"user_pname":    basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = PineconeType{}

type PineconeType struct {
	basetypes.ObjectType
}

func (t PineconeType) Equal(o attr.Type) bool {
	other, ok := o.(PineconeType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PineconeType) String() string {
	return "PineconeType"
}

func (t PineconeType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	apiKeyAttribute, ok := attributes["api_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`api_key is missing from object`)

		return nil, diags
	}

	apiKeyVal, ok := apiKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`api_key expected to be basetypes.StringValue, was: %T`, apiKeyAttribute))
	}

	batchSizeAttribute, ok := attributes["batch_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`batch_size is missing from object`)

		return nil, diags
	}

	batchSizeVal, ok := batchSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`batch_size expected to be basetypes.Int64Value, was: %T`, batchSizeAttribute))
	}

	indexNameAttribute, ok := attributes["index_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`index_name is missing from object`)

		return nil, diags
	}

	indexNameVal, ok := indexNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`index_name expected to be basetypes.StringValue, was: %T`, indexNameAttribute))
	}

	namespaceAttribute, ok := attributes["namespace"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`namespace is missing from object`)

		return nil, diags
	}

	namespaceVal, ok := namespaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`namespace expected to be basetypes.StringValue, was: %T`, namespaceAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PineconeValue{
		ApiKey:    apiKeyVal,
		BatchSize: batchSizeVal,
		IndexName: indexNameVal,
		Namespace: namespaceVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewPineconeValueNull() PineconeValue {
	return PineconeValue{
		state: attr.ValueStateNull,
	}
}

func NewPineconeValueUnknown() PineconeValue {
	return PineconeValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPineconeValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PineconeValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PineconeValue Attribute Value",
				"While creating a PineconeValue value, a missing attribute value was detected. "+
					"A PineconeValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PineconeValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PineconeValue Attribute Type",
				"While creating a PineconeValue value, an invalid attribute value was detected. "+
					"A PineconeValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PineconeValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PineconeValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PineconeValue Attribute Value",
				"While creating a PineconeValue value, an extra attribute value was detected. "+
					"A PineconeValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PineconeValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPineconeValueUnknown(), diags
	}

	apiKeyAttribute, ok := attributes["api_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`api_key is missing from object`)

		return NewPineconeValueUnknown(), diags
	}

	apiKeyVal, ok := apiKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`api_key expected to be basetypes.StringValue, was: %T`, apiKeyAttribute))
	}

	batchSizeAttribute, ok := attributes["batch_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`batch_size is missing from object`)

		return NewPineconeValueUnknown(), diags
	}

	batchSizeVal, ok := batchSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`batch_size expected to be basetypes.Int64Value, was: %T`, batchSizeAttribute))
	}

	indexNameAttribute, ok := attributes["index_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`index_name is missing from object`)

		return NewPineconeValueUnknown(), diags
	}

	indexNameVal, ok := indexNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`index_name expected to be basetypes.StringValue, was: %T`, indexNameAttribute))
	}

	namespaceAttribute, ok := attributes["namespace"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`namespace is missing from object`)

		return NewPineconeValueUnknown(), diags
	}

	namespaceVal, ok := namespaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`namespace expected to be basetypes.StringValue, was: %T`, namespaceAttribute))
	}

	if diags.HasError() {
		return NewPineconeValueUnknown(), diags
	}

	return PineconeValue{
		ApiKey:    apiKeyVal,
		BatchSize: batchSizeVal,
		IndexName: indexNameVal,
		Namespace: namespaceVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewPineconeValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PineconeValue {
	object, diags := NewPineconeValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPineconeValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PineconeType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPineconeValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPineconeValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPineconeValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPineconeValueMust(PineconeValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PineconeType) ValueType(ctx context.Context) attr.Value {
	return PineconeValue{}
}

var _ basetypes.ObjectValuable = PineconeValue{}

type PineconeValue struct {
	ApiKey    basetypes.StringValue `tfsdk:"api_key"`
	BatchSize basetypes.Int64Value  `tfsdk:"batch_size"`
	IndexName basetypes.StringValue `tfsdk:"index_name"`
	Namespace basetypes.StringValue `tfsdk:"namespace"`
	state     attr.ValueState
}

func (v PineconeValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["api_key"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["batch_size"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["index_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["namespace"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.ApiKey.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["api_key"] = val

		val, err = v.BatchSize.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["batch_size"] = val

		val, err = v.IndexName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["index_name"] = val

		val, err = v.Namespace.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["namespace"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PineconeValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PineconeValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PineconeValue) String() string {
	return "PineconeValue"
}

func (v PineconeValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"api_key":    basetypes.StringType{},
		"batch_size": basetypes.Int64Type{},
		"index_name": basetypes.StringType{},
		"namespace":  basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"api_key":    v.ApiKey,
			"batch_size": v.BatchSize,
			"index_name": v.IndexName,
			"namespace":  v.Namespace,
		})

	return objVal, diags
}

func (v PineconeValue) Equal(o attr.Value) bool {
	other, ok := o.(PineconeValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ApiKey.Equal(other.ApiKey) {
		return false
	}

	if !v.BatchSize.Equal(other.BatchSize) {
		return false
	}

	if !v.IndexName.Equal(other.IndexName) {
		return false
	}

	if !v.Namespace.Equal(other.Namespace) {
		return false
	}

	return true
}

func (v PineconeValue) Type(ctx context.Context) attr.Type {
	return PineconeType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PineconeValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"api_key":    basetypes.StringType{},
		"batch_size": basetypes.Int64Type{},
		"index_name": basetypes.StringType{},
		"namespace":  basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = PostgresType{}

type PostgresType struct {
	basetypes.ObjectType
}

func (t PostgresType) Equal(o attr.Type) bool {
	other, ok := o.(PostgresType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PostgresType) String() string {
	return "PostgresType"
}

func (t PostgresType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	batchSizeAttribute, ok := attributes["batch_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`batch_size is missing from object`)

		return nil, diags
	}

	batchSizeVal, ok := batchSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`batch_size expected to be basetypes.Int64Value, was: %T`, batchSizeAttribute))
	}

	databaseAttribute, ok := attributes["database"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`database is missing from object`)

		return nil, diags
	}

	databaseVal, ok := databaseAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`database expected to be basetypes.StringValue, was: %T`, databaseAttribute))
	}

	hostAttribute, ok := attributes["host"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`host is missing from object`)

		return nil, diags
	}

	hostVal, ok := hostAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`host expected to be basetypes.StringValue, was: %T`, hostAttribute))
	}

	passwordAttribute, ok := attributes["password"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`password is missing from object`)

		return nil, diags
	}

	passwordVal, ok := passwordAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`password expected to be basetypes.StringValue, was: %T`, passwordAttribute))
	}

	portAttribute, ok := attributes["port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port is missing from object`)

		return nil, diags
	}

	portVal, ok := portAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port expected to be basetypes.Int64Value, was: %T`, portAttribute))
	}

	tableNameAttribute, ok := attributes["table_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`table_name is missing from object`)

		return nil, diags
	}

	tableNameVal, ok := tableNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`table_name expected to be basetypes.StringValue, was: %T`, tableNameAttribute))
	}

	usernameAttribute, ok := attributes["username"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`username is missing from object`)

		return nil, diags
	}

	usernameVal, ok := usernameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`username expected to be basetypes.StringValue, was: %T`, usernameAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PostgresValue{
		BatchSize: batchSizeVal,
		Database:  databaseVal,
		Host:      hostVal,
		Password:  passwordVal,
		Port:      portVal,
		TableName: tableNameVal,
		Username:  usernameVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewPostgresValueNull() PostgresValue {
	return PostgresValue{
		state: attr.ValueStateNull,
	}
}

func NewPostgresValueUnknown() PostgresValue {
	return PostgresValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPostgresValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PostgresValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PostgresValue Attribute Value",
				"While creating a PostgresValue value, a missing attribute value was detected. "+
					"A PostgresValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PostgresValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PostgresValue Attribute Type",
				"While creating a PostgresValue value, an invalid attribute value was detected. "+
					"A PostgresValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PostgresValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PostgresValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PostgresValue Attribute Value",
				"While creating a PostgresValue value, an extra attribute value was detected. "+
					"A PostgresValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PostgresValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPostgresValueUnknown(), diags
	}

	batchSizeAttribute, ok := attributes["batch_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`batch_size is missing from object`)

		return NewPostgresValueUnknown(), diags
	}

	batchSizeVal, ok := batchSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`batch_size expected to be basetypes.Int64Value, was: %T`, batchSizeAttribute))
	}

	databaseAttribute, ok := attributes["database"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`database is missing from object`)

		return NewPostgresValueUnknown(), diags
	}

	databaseVal, ok := databaseAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`database expected to be basetypes.StringValue, was: %T`, databaseAttribute))
	}

	hostAttribute, ok := attributes["host"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`host is missing from object`)

		return NewPostgresValueUnknown(), diags
	}

	hostVal, ok := hostAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`host expected to be basetypes.StringValue, was: %T`, hostAttribute))
	}

	passwordAttribute, ok := attributes["password"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`password is missing from object`)

		return NewPostgresValueUnknown(), diags
	}

	passwordVal, ok := passwordAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`password expected to be basetypes.StringValue, was: %T`, passwordAttribute))
	}

	portAttribute, ok := attributes["port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port is missing from object`)

		return NewPostgresValueUnknown(), diags
	}

	portVal, ok := portAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port expected to be basetypes.Int64Value, was: %T`, portAttribute))
	}

	tableNameAttribute, ok := attributes["table_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`table_name is missing from object`)

		return NewPostgresValueUnknown(), diags
	}

	tableNameVal, ok := tableNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`table_name expected to be basetypes.StringValue, was: %T`, tableNameAttribute))
	}

	usernameAttribute, ok := attributes["username"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`username is missing from object`)

		return NewPostgresValueUnknown(), diags
	}

	usernameVal, ok := usernameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`username expected to be basetypes.StringValue, was: %T`, usernameAttribute))
	}

	if diags.HasError() {
		return NewPostgresValueUnknown(), diags
	}

	return PostgresValue{
		BatchSize: batchSizeVal,
		Database:  databaseVal,
		Host:      hostVal,
		Password:  passwordVal,
		Port:      portVal,
		TableName: tableNameVal,
		Username:  usernameVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewPostgresValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PostgresValue {
	object, diags := NewPostgresValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPostgresValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PostgresType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPostgresValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPostgresValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPostgresValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPostgresValueMust(PostgresValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PostgresType) ValueType(ctx context.Context) attr.Value {
	return PostgresValue{}
}

var _ basetypes.ObjectValuable = PostgresValue{}

type PostgresValue struct {
	BatchSize basetypes.Int64Value  `tfsdk:"batch_size"`
	Database  basetypes.StringValue `tfsdk:"database"`
	Host      basetypes.StringValue `tfsdk:"host"`
	Password  basetypes.StringValue `tfsdk:"password"`
	Port      basetypes.Int64Value  `tfsdk:"port"`
	TableName basetypes.StringValue `tfsdk:"table_name"`
	Username  basetypes.StringValue `tfsdk:"username"`
	state     attr.ValueState
}

func (v PostgresValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 7)

	var val tftypes.Value
	var err error

	attrTypes["batch_size"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["database"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["host"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["password"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["port"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["table_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["username"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 7)

		val, err = v.BatchSize.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["batch_size"] = val

		val, err = v.Database.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["database"] = val

		val, err = v.Host.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["host"] = val

		val, err = v.Password.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["password"] = val

		val, err = v.Port.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port"] = val

		val, err = v.TableName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["table_name"] = val

		val, err = v.Username.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["username"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PostgresValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PostgresValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PostgresValue) String() string {
	return "PostgresValue"
}

func (v PostgresValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"batch_size": basetypes.Int64Type{},
		"database":   basetypes.StringType{},
		"host":       basetypes.StringType{},
		"password":   basetypes.StringType{},
		"port":       basetypes.Int64Type{},
		"table_name": basetypes.StringType{},
		"username":   basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"batch_size": v.BatchSize,
			"database":   v.Database,
			"host":       v.Host,
			"password":   v.Password,
			"port":       v.Port,
			"table_name": v.TableName,
			"username":   v.Username,
		})

	return objVal, diags
}

func (v PostgresValue) Equal(o attr.Value) bool {
	other, ok := o.(PostgresValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.BatchSize.Equal(other.BatchSize) {
		return false
	}

	if !v.Database.Equal(other.Database) {
		return false
	}

	if !v.Host.Equal(other.Host) {
		return false
	}

	if !v.Password.Equal(other.Password) {
		return false
	}

	if !v.Port.Equal(other.Port) {
		return false
	}

	if !v.TableName.Equal(other.TableName) {
		return false
	}

	if !v.Username.Equal(other.Username) {
		return false
	}

	return true
}

func (v PostgresValue) Type(ctx context.Context) attr.Type {
	return PostgresType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PostgresValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"batch_size": basetypes.Int64Type{},
		"database":   basetypes.StringType{},
		"host":       basetypes.StringType{},
		"password":   basetypes.StringType{},
		"port":       basetypes.Int64Type{},
		"table_name": basetypes.StringType{},
		"username":   basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = QdrantCloudType{}

type QdrantCloudType struct {
	basetypes.ObjectType
}

func (t QdrantCloudType) Equal(o attr.Type) bool {
	other, ok := o.(QdrantCloudType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t QdrantCloudType) String() string {
	return "QdrantCloudType"
}

func (t QdrantCloudType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	apiKeyAttribute, ok := attributes["api_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`api_key is missing from object`)

		return nil, diags
	}

	apiKeyVal, ok := apiKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`api_key expected to be basetypes.StringValue, was: %T`, apiKeyAttribute))
	}

	batchSizeAttribute, ok := attributes["batch_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`batch_size is missing from object`)

		return nil, diags
	}

	batchSizeVal, ok := batchSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`batch_size expected to be basetypes.Int64Value, was: %T`, batchSizeAttribute))
	}

	collectionNameAttribute, ok := attributes["collection_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`collection_name is missing from object`)

		return nil, diags
	}

	collectionNameVal, ok := collectionNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`collection_name expected to be basetypes.StringValue, was: %T`, collectionNameAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return nil, diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return QdrantCloudValue{
		ApiKey:         apiKeyVal,
		BatchSize:      batchSizeVal,
		CollectionName: collectionNameVal,
		Url:            urlVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewQdrantCloudValueNull() QdrantCloudValue {
	return QdrantCloudValue{
		state: attr.ValueStateNull,
	}
}

func NewQdrantCloudValueUnknown() QdrantCloudValue {
	return QdrantCloudValue{
		state: attr.ValueStateUnknown,
	}
}

func NewQdrantCloudValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (QdrantCloudValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing QdrantCloudValue Attribute Value",
				"While creating a QdrantCloudValue value, a missing attribute value was detected. "+
					"A QdrantCloudValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("QdrantCloudValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid QdrantCloudValue Attribute Type",
				"While creating a QdrantCloudValue value, an invalid attribute value was detected. "+
					"A QdrantCloudValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("QdrantCloudValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("QdrantCloudValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra QdrantCloudValue Attribute Value",
				"While creating a QdrantCloudValue value, an extra attribute value was detected. "+
					"A QdrantCloudValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra QdrantCloudValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewQdrantCloudValueUnknown(), diags
	}

	apiKeyAttribute, ok := attributes["api_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`api_key is missing from object`)

		return NewQdrantCloudValueUnknown(), diags
	}

	apiKeyVal, ok := apiKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`api_key expected to be basetypes.StringValue, was: %T`, apiKeyAttribute))
	}

	batchSizeAttribute, ok := attributes["batch_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`batch_size is missing from object`)

		return NewQdrantCloudValueUnknown(), diags
	}

	batchSizeVal, ok := batchSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`batch_size expected to be basetypes.Int64Value, was: %T`, batchSizeAttribute))
	}

	collectionNameAttribute, ok := attributes["collection_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`collection_name is missing from object`)

		return NewQdrantCloudValueUnknown(), diags
	}

	collectionNameVal, ok := collectionNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`collection_name expected to be basetypes.StringValue, was: %T`, collectionNameAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return NewQdrantCloudValueUnknown(), diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	if diags.HasError() {
		return NewQdrantCloudValueUnknown(), diags
	}

	return QdrantCloudValue{
		ApiKey:         apiKeyVal,
		BatchSize:      batchSizeVal,
		CollectionName: collectionNameVal,
		Url:            urlVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewQdrantCloudValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) QdrantCloudValue {
	object, diags := NewQdrantCloudValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewQdrantCloudValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t QdrantCloudType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewQdrantCloudValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewQdrantCloudValueUnknown(), nil
	}

	if in.IsNull() {
		return NewQdrantCloudValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewQdrantCloudValueMust(QdrantCloudValue{}.AttributeTypes(ctx), attributes), nil
}

func (t QdrantCloudType) ValueType(ctx context.Context) attr.Value {
	return QdrantCloudValue{}
}

var _ basetypes.ObjectValuable = QdrantCloudValue{}

type QdrantCloudValue struct {
	ApiKey         basetypes.StringValue `tfsdk:"api_key"`
	BatchSize      basetypes.Int64Value  `tfsdk:"batch_size"`
	CollectionName basetypes.StringValue `tfsdk:"collection_name"`
	Url            basetypes.StringValue `tfsdk:"url"`
	state          attr.ValueState
}

func (v QdrantCloudValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["api_key"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["batch_size"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["collection_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["url"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.ApiKey.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["api_key"] = val

		val, err = v.BatchSize.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["batch_size"] = val

		val, err = v.CollectionName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["collection_name"] = val

		val, err = v.Url.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["url"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v QdrantCloudValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v QdrantCloudValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v QdrantCloudValue) String() string {
	return "QdrantCloudValue"
}

func (v QdrantCloudValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"api_key":         basetypes.StringType{},
		"batch_size":      basetypes.Int64Type{},
		"collection_name": basetypes.StringType{},
		"url":             basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"api_key":         v.ApiKey,
			"batch_size":      v.BatchSize,
			"collection_name": v.CollectionName,
			"url":             v.Url,
		})

	return objVal, diags
}

func (v QdrantCloudValue) Equal(o attr.Value) bool {
	other, ok := o.(QdrantCloudValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ApiKey.Equal(other.ApiKey) {
		return false
	}

	if !v.BatchSize.Equal(other.BatchSize) {
		return false
	}

	if !v.CollectionName.Equal(other.CollectionName) {
		return false
	}

	if !v.Url.Equal(other.Url) {
		return false
	}

	return true
}

func (v QdrantCloudValue) Type(ctx context.Context) attr.Type {
	return QdrantCloudType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v QdrantCloudValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"api_key":         basetypes.StringType{},
		"batch_size":      basetypes.Int64Type{},
		"collection_name": basetypes.StringType{},
		"url":             basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = RedisType{}

type RedisType struct {
	basetypes.ObjectType
}

func (t RedisType) Equal(o attr.Type) bool {
	other, ok := o.(RedisType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t RedisType) String() string {
	return "RedisType"
}

func (t RedisType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	batchSizeAttribute, ok := attributes["batch_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`batch_size is missing from object`)

		return nil, diags
	}

	batchSizeVal, ok := batchSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`batch_size expected to be basetypes.Int64Value, was: %T`, batchSizeAttribute))
	}

	databaseAttribute, ok := attributes["database"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`database is missing from object`)

		return nil, diags
	}

	databaseVal, ok := databaseAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`database expected to be basetypes.Int64Value, was: %T`, databaseAttribute))
	}

	hostAttribute, ok := attributes["host"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`host is missing from object`)

		return nil, diags
	}

	hostVal, ok := hostAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`host expected to be basetypes.StringValue, was: %T`, hostAttribute))
	}

	passwordAttribute, ok := attributes["password"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`password is missing from object`)

		return nil, diags
	}

	passwordVal, ok := passwordAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`password expected to be basetypes.StringValue, was: %T`, passwordAttribute))
	}

	portAttribute, ok := attributes["port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port is missing from object`)

		return nil, diags
	}

	portVal, ok := portAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port expected to be basetypes.Int64Value, was: %T`, portAttribute))
	}

	sslAttribute, ok := attributes["ssl"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ssl is missing from object`)

		return nil, diags
	}

	sslVal, ok := sslAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ssl expected to be basetypes.BoolValue, was: %T`, sslAttribute))
	}

	uriAttribute, ok := attributes["uri"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uri is missing from object`)

		return nil, diags
	}

	uriVal, ok := uriAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uri expected to be basetypes.StringValue, was: %T`, uriAttribute))
	}

	usernameAttribute, ok := attributes["username"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`username is missing from object`)

		return nil, diags
	}

	usernameVal, ok := usernameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`username expected to be basetypes.StringValue, was: %T`, usernameAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return RedisValue{
		BatchSize: batchSizeVal,
		Database:  databaseVal,
		Host:      hostVal,
		Password:  passwordVal,
		Port:      portVal,
		Ssl:       sslVal,
		Uri:       uriVal,
		Username:  usernameVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewRedisValueNull() RedisValue {
	return RedisValue{
		state: attr.ValueStateNull,
	}
}

func NewRedisValueUnknown() RedisValue {
	return RedisValue{
		state: attr.ValueStateUnknown,
	}
}

func NewRedisValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (RedisValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing RedisValue Attribute Value",
				"While creating a RedisValue value, a missing attribute value was detected. "+
					"A RedisValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RedisValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid RedisValue Attribute Type",
				"While creating a RedisValue value, an invalid attribute value was detected. "+
					"A RedisValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RedisValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("RedisValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra RedisValue Attribute Value",
				"While creating a RedisValue value, an extra attribute value was detected. "+
					"A RedisValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra RedisValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewRedisValueUnknown(), diags
	}

	batchSizeAttribute, ok := attributes["batch_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`batch_size is missing from object`)

		return NewRedisValueUnknown(), diags
	}

	batchSizeVal, ok := batchSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`batch_size expected to be basetypes.Int64Value, was: %T`, batchSizeAttribute))
	}

	databaseAttribute, ok := attributes["database"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`database is missing from object`)

		return NewRedisValueUnknown(), diags
	}

	databaseVal, ok := databaseAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`database expected to be basetypes.Int64Value, was: %T`, databaseAttribute))
	}

	hostAttribute, ok := attributes["host"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`host is missing from object`)

		return NewRedisValueUnknown(), diags
	}

	hostVal, ok := hostAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`host expected to be basetypes.StringValue, was: %T`, hostAttribute))
	}

	passwordAttribute, ok := attributes["password"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`password is missing from object`)

		return NewRedisValueUnknown(), diags
	}

	passwordVal, ok := passwordAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`password expected to be basetypes.StringValue, was: %T`, passwordAttribute))
	}

	portAttribute, ok := attributes["port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port is missing from object`)

		return NewRedisValueUnknown(), diags
	}

	portVal, ok := portAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port expected to be basetypes.Int64Value, was: %T`, portAttribute))
	}

	sslAttribute, ok := attributes["ssl"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ssl is missing from object`)

		return NewRedisValueUnknown(), diags
	}

	sslVal, ok := sslAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ssl expected to be basetypes.BoolValue, was: %T`, sslAttribute))
	}

	uriAttribute, ok := attributes["uri"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uri is missing from object`)

		return NewRedisValueUnknown(), diags
	}

	uriVal, ok := uriAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uri expected to be basetypes.StringValue, was: %T`, uriAttribute))
	}

	usernameAttribute, ok := attributes["username"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`username is missing from object`)

		return NewRedisValueUnknown(), diags
	}

	usernameVal, ok := usernameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`username expected to be basetypes.StringValue, was: %T`, usernameAttribute))
	}

	if diags.HasError() {
		return NewRedisValueUnknown(), diags
	}

	return RedisValue{
		BatchSize: batchSizeVal,
		Database:  databaseVal,
		Host:      hostVal,
		Password:  passwordVal,
		Port:      portVal,
		Ssl:       sslVal,
		Uri:       uriVal,
		Username:  usernameVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewRedisValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) RedisValue {
	object, diags := NewRedisValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewRedisValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t RedisType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewRedisValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewRedisValueUnknown(), nil
	}

	if in.IsNull() {
		return NewRedisValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewRedisValueMust(RedisValue{}.AttributeTypes(ctx), attributes), nil
}

func (t RedisType) ValueType(ctx context.Context) attr.Value {
	return RedisValue{}
}

var _ basetypes.ObjectValuable = RedisValue{}

type RedisValue struct {
	BatchSize basetypes.Int64Value  `tfsdk:"batch_size"`
	Database  basetypes.Int64Value  `tfsdk:"database"`
	Host      basetypes.StringValue `tfsdk:"host"`
	Password  basetypes.StringValue `tfsdk:"password"`
	Port      basetypes.Int64Value  `tfsdk:"port"`
	Ssl       basetypes.BoolValue   `tfsdk:"ssl"`
	Uri       basetypes.StringValue `tfsdk:"uri"`
	Username  basetypes.StringValue `tfsdk:"username"`
	state     attr.ValueState
}

func (v RedisValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 8)

	var val tftypes.Value
	var err error

	attrTypes["batch_size"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["database"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["host"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["password"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["port"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["ssl"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["uri"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["username"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 8)

		val, err = v.BatchSize.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["batch_size"] = val

		val, err = v.Database.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["database"] = val

		val, err = v.Host.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["host"] = val

		val, err = v.Password.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["password"] = val

		val, err = v.Port.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port"] = val

		val, err = v.Ssl.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ssl"] = val

		val, err = v.Uri.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["uri"] = val

		val, err = v.Username.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["username"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v RedisValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v RedisValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v RedisValue) String() string {
	return "RedisValue"
}

func (v RedisValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"batch_size": basetypes.Int64Type{},
		"database":   basetypes.Int64Type{},
		"host":       basetypes.StringType{},
		"password":   basetypes.StringType{},
		"port":       basetypes.Int64Type{},
		"ssl":        basetypes.BoolType{},
		"uri":        basetypes.StringType{},
		"username":   basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"batch_size": v.BatchSize,
			"database":   v.Database,
			"host":       v.Host,
			"password":   v.Password,
			"port":       v.Port,
			"ssl":        v.Ssl,
			"uri":        v.Uri,
			"username":   v.Username,
		})

	return objVal, diags
}

func (v RedisValue) Equal(o attr.Value) bool {
	other, ok := o.(RedisValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.BatchSize.Equal(other.BatchSize) {
		return false
	}

	if !v.Database.Equal(other.Database) {
		return false
	}

	if !v.Host.Equal(other.Host) {
		return false
	}

	if !v.Password.Equal(other.Password) {
		return false
	}

	if !v.Port.Equal(other.Port) {
		return false
	}

	if !v.Ssl.Equal(other.Ssl) {
		return false
	}

	if !v.Uri.Equal(other.Uri) {
		return false
	}

	if !v.Username.Equal(other.Username) {
		return false
	}

	return true
}

func (v RedisValue) Type(ctx context.Context) attr.Type {
	return RedisType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v RedisValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"batch_size": basetypes.Int64Type{},
		"database":   basetypes.Int64Type{},
		"host":       basetypes.StringType{},
		"password":   basetypes.StringType{},
		"port":       basetypes.Int64Type{},
		"ssl":        basetypes.BoolType{},
		"uri":        basetypes.StringType{},
		"username":   basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = S3Type{}

type S3Type struct {
	basetypes.ObjectType
}

func (t S3Type) Equal(o attr.Type) bool {
	other, ok := o.(S3Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t S3Type) String() string {
	return "S3Type"
}

func (t S3Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	anonymousAttribute, ok := attributes["anonymous"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`anonymous is missing from object`)

		return nil, diags
	}

	anonymousVal, ok := anonymousAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`anonymous expected to be basetypes.BoolValue, was: %T`, anonymousAttribute))
	}

	endpointUrlAttribute, ok := attributes["endpoint_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`endpoint_url is missing from object`)

		return nil, diags
	}

	endpointUrlVal, ok := endpointUrlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`endpoint_url expected to be basetypes.StringValue, was: %T`, endpointUrlAttribute))
	}

	keyAttribute, ok := attributes["key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`key is missing from object`)

		return nil, diags
	}

	keyVal, ok := keyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`key expected to be basetypes.StringValue, was: %T`, keyAttribute))
	}

	recursiveAttribute, ok := attributes["recursive"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`recursive is missing from object`)

		return nil, diags
	}

	recursiveVal, ok := recursiveAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`recursive expected to be basetypes.BoolValue, was: %T`, recursiveAttribute))
	}

	remoteUrlAttribute, ok := attributes["remote_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remote_url is missing from object`)

		return nil, diags
	}

	remoteUrlVal, ok := remoteUrlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remote_url expected to be basetypes.StringValue, was: %T`, remoteUrlAttribute))
	}

	secretAttribute, ok := attributes["secret"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`secret is missing from object`)

		return nil, diags
	}

	secretVal, ok := secretAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`secret expected to be basetypes.StringValue, was: %T`, secretAttribute))
	}

	tokenAttribute, ok := attributes["token"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`token is missing from object`)

		return nil, diags
	}

	tokenVal, ok := tokenAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`token expected to be basetypes.StringValue, was: %T`, tokenAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return S3Value{
		Anonymous:   anonymousVal,
		EndpointUrl: endpointUrlVal,
		Key:         keyVal,
		Recursive:   recursiveVal,
		RemoteUrl:   remoteUrlVal,
		Secret:      secretVal,
		Token:       tokenVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewS3ValueNull() S3Value {
	return S3Value{
		state: attr.ValueStateNull,
	}
}

func NewS3ValueUnknown() S3Value {
	return S3Value{
		state: attr.ValueStateUnknown,
	}
}

func NewS3Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (S3Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing S3Value Attribute Value",
				"While creating a S3Value value, a missing attribute value was detected. "+
					"A S3Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("S3Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid S3Value Attribute Type",
				"While creating a S3Value value, an invalid attribute value was detected. "+
					"A S3Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("S3Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("S3Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra S3Value Attribute Value",
				"While creating a S3Value value, an extra attribute value was detected. "+
					"A S3Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra S3Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewS3ValueUnknown(), diags
	}

	anonymousAttribute, ok := attributes["anonymous"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`anonymous is missing from object`)

		return NewS3ValueUnknown(), diags
	}

	anonymousVal, ok := anonymousAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`anonymous expected to be basetypes.BoolValue, was: %T`, anonymousAttribute))
	}

	endpointUrlAttribute, ok := attributes["endpoint_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`endpoint_url is missing from object`)

		return NewS3ValueUnknown(), diags
	}

	endpointUrlVal, ok := endpointUrlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`endpoint_url expected to be basetypes.StringValue, was: %T`, endpointUrlAttribute))
	}

	keyAttribute, ok := attributes["key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`key is missing from object`)

		return NewS3ValueUnknown(), diags
	}

	keyVal, ok := keyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`key expected to be basetypes.StringValue, was: %T`, keyAttribute))
	}

	recursiveAttribute, ok := attributes["recursive"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`recursive is missing from object`)

		return NewS3ValueUnknown(), diags
	}

	recursiveVal, ok := recursiveAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`recursive expected to be basetypes.BoolValue, was: %T`, recursiveAttribute))
	}

	remoteUrlAttribute, ok := attributes["remote_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remote_url is missing from object`)

		return NewS3ValueUnknown(), diags
	}

	remoteUrlVal, ok := remoteUrlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remote_url expected to be basetypes.StringValue, was: %T`, remoteUrlAttribute))
	}

	secretAttribute, ok := attributes["secret"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`secret is missing from object`)

		return NewS3ValueUnknown(), diags
	}

	secretVal, ok := secretAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`secret expected to be basetypes.StringValue, was: %T`, secretAttribute))
	}

	tokenAttribute, ok := attributes["token"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`token is missing from object`)

		return NewS3ValueUnknown(), diags
	}

	tokenVal, ok := tokenAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`token expected to be basetypes.StringValue, was: %T`, tokenAttribute))
	}

	if diags.HasError() {
		return NewS3ValueUnknown(), diags
	}

	return S3Value{
		Anonymous:   anonymousVal,
		EndpointUrl: endpointUrlVal,
		Key:         keyVal,
		Recursive:   recursiveVal,
		RemoteUrl:   remoteUrlVal,
		Secret:      secretVal,
		Token:       tokenVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewS3ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) S3Value {
	object, diags := NewS3Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewS3ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t S3Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewS3ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewS3ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewS3ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewS3ValueMust(S3Value{}.AttributeTypes(ctx), attributes), nil
}

func (t S3Type) ValueType(ctx context.Context) attr.Value {
	return S3Value{}
}

var _ basetypes.ObjectValuable = S3Value{}

type S3Value struct {
	Anonymous   basetypes.BoolValue   `tfsdk:"anonymous"`
	EndpointUrl basetypes.StringValue `tfsdk:"endpoint_url"`
	Key         basetypes.StringValue `tfsdk:"key"`
	Recursive   basetypes.BoolValue   `tfsdk:"recursive"`
	RemoteUrl   basetypes.StringValue `tfsdk:"remote_url"`
	Secret      basetypes.StringValue `tfsdk:"secret"`
	Token       basetypes.StringValue `tfsdk:"token"`
	state       attr.ValueState
}

func (v S3Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 7)

	var val tftypes.Value
	var err error

	attrTypes["anonymous"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["endpoint_url"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["key"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["recursive"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["remote_url"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["secret"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["token"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 7)

		val, err = v.Anonymous.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["anonymous"] = val

		val, err = v.EndpointUrl.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["endpoint_url"] = val

		val, err = v.Key.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["key"] = val

		val, err = v.Recursive.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["recursive"] = val

		val, err = v.RemoteUrl.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["remote_url"] = val

		val, err = v.Secret.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["secret"] = val

		val, err = v.Token.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["token"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v S3Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v S3Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v S3Value) String() string {
	return "S3Value"
}

func (v S3Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"anonymous":    basetypes.BoolType{},
		"endpoint_url": basetypes.StringType{},
		"key":          basetypes.StringType{},
		"recursive":    basetypes.BoolType{},
		"remote_url":   basetypes.StringType{},
		"secret":       basetypes.StringType{},
		"token":        basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"anonymous":    v.Anonymous,
			"endpoint_url": v.EndpointUrl,
			"key":          v.Key,
			"recursive":    v.Recursive,
			"remote_url":   v.RemoteUrl,
			"secret":       v.Secret,
			"token":        v.Token,
		})

	return objVal, diags
}

func (v S3Value) Equal(o attr.Value) bool {
	other, ok := o.(S3Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Anonymous.Equal(other.Anonymous) {
		return false
	}

	if !v.EndpointUrl.Equal(other.EndpointUrl) {
		return false
	}

	if !v.Key.Equal(other.Key) {
		return false
	}

	if !v.Recursive.Equal(other.Recursive) {
		return false
	}

	if !v.RemoteUrl.Equal(other.RemoteUrl) {
		return false
	}

	if !v.Secret.Equal(other.Secret) {
		return false
	}

	if !v.Token.Equal(other.Token) {
		return false
	}

	return true
}

func (v S3Value) Type(ctx context.Context) attr.Type {
	return S3Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v S3Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"anonymous":    basetypes.BoolType{},
		"endpoint_url": basetypes.StringType{},
		"key":          basetypes.StringType{},
		"recursive":    basetypes.BoolType{},
		"remote_url":   basetypes.StringType{},
		"secret":       basetypes.StringType{},
		"token":        basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = SnowflakeType{}

type SnowflakeType struct {
	basetypes.ObjectType
}

func (t SnowflakeType) Equal(o attr.Type) bool {
	other, ok := o.(SnowflakeType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SnowflakeType) String() string {
	return "SnowflakeType"
}

func (t SnowflakeType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	accountAttribute, ok := attributes["account"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`account is missing from object`)

		return nil, diags
	}

	accountVal, ok := accountAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`account expected to be basetypes.StringValue, was: %T`, accountAttribute))
	}

	batchSizeAttribute, ok := attributes["batch_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`batch_size is missing from object`)

		return nil, diags
	}

	batchSizeVal, ok := batchSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`batch_size expected to be basetypes.Int64Value, was: %T`, batchSizeAttribute))
	}

	databaseAttribute, ok := attributes["database"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`database is missing from object`)

		return nil, diags
	}

	databaseVal, ok := databaseAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`database expected to be basetypes.StringValue, was: %T`, databaseAttribute))
	}

	hostAttribute, ok := attributes["host"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`host is missing from object`)

		return nil, diags
	}

	hostVal, ok := hostAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`host expected to be basetypes.StringValue, was: %T`, hostAttribute))
	}

	passwordAttribute, ok := attributes["password"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`password is missing from object`)

		return nil, diags
	}

	passwordVal, ok := passwordAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`password expected to be basetypes.StringValue, was: %T`, passwordAttribute))
	}

	portAttribute, ok := attributes["port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port is missing from object`)

		return nil, diags
	}

	portVal, ok := portAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port expected to be basetypes.Int64Value, was: %T`, portAttribute))
	}

	recordIdKeyAttribute, ok := attributes["record_id_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`record_id_key is missing from object`)

		return nil, diags
	}

	recordIdKeyVal, ok := recordIdKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`record_id_key expected to be basetypes.StringValue, was: %T`, recordIdKeyAttribute))
	}

	roleAttribute, ok := attributes["role"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`role is missing from object`)

		return nil, diags
	}

	roleVal, ok := roleAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`role expected to be basetypes.StringValue, was: %T`, roleAttribute))
	}

	schemaAttribute, ok := attributes["schema"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`schema is missing from object`)

		return nil, diags
	}

	schemaVal, ok := schemaAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`schema expected to be basetypes.StringValue, was: %T`, schemaAttribute))
	}

	tableNameAttribute, ok := attributes["table_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`table_name is missing from object`)

		return nil, diags
	}

	tableNameVal, ok := tableNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`table_name expected to be basetypes.StringValue, was: %T`, tableNameAttribute))
	}

	userAttribute, ok := attributes["user"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`user is missing from object`)

		return nil, diags
	}

	userVal, ok := userAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`user expected to be basetypes.StringValue, was: %T`, userAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SnowflakeValue{
		Account:     accountVal,
		BatchSize:   batchSizeVal,
		Database:    databaseVal,
		Host:        hostVal,
		Password:    passwordVal,
		Port:        portVal,
		RecordIdKey: recordIdKeyVal,
		Role:        roleVal,
		Schema:      schemaVal,
		TableName:   tableNameVal,
		User:        userVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewSnowflakeValueNull() SnowflakeValue {
	return SnowflakeValue{
		state: attr.ValueStateNull,
	}
}

func NewSnowflakeValueUnknown() SnowflakeValue {
	return SnowflakeValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSnowflakeValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SnowflakeValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SnowflakeValue Attribute Value",
				"While creating a SnowflakeValue value, a missing attribute value was detected. "+
					"A SnowflakeValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SnowflakeValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SnowflakeValue Attribute Type",
				"While creating a SnowflakeValue value, an invalid attribute value was detected. "+
					"A SnowflakeValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SnowflakeValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SnowflakeValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SnowflakeValue Attribute Value",
				"While creating a SnowflakeValue value, an extra attribute value was detected. "+
					"A SnowflakeValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SnowflakeValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSnowflakeValueUnknown(), diags
	}

	accountAttribute, ok := attributes["account"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`account is missing from object`)

		return NewSnowflakeValueUnknown(), diags
	}

	accountVal, ok := accountAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`account expected to be basetypes.StringValue, was: %T`, accountAttribute))
	}

	batchSizeAttribute, ok := attributes["batch_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`batch_size is missing from object`)

		return NewSnowflakeValueUnknown(), diags
	}

	batchSizeVal, ok := batchSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`batch_size expected to be basetypes.Int64Value, was: %T`, batchSizeAttribute))
	}

	databaseAttribute, ok := attributes["database"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`database is missing from object`)

		return NewSnowflakeValueUnknown(), diags
	}

	databaseVal, ok := databaseAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`database expected to be basetypes.StringValue, was: %T`, databaseAttribute))
	}

	hostAttribute, ok := attributes["host"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`host is missing from object`)

		return NewSnowflakeValueUnknown(), diags
	}

	hostVal, ok := hostAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`host expected to be basetypes.StringValue, was: %T`, hostAttribute))
	}

	passwordAttribute, ok := attributes["password"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`password is missing from object`)

		return NewSnowflakeValueUnknown(), diags
	}

	passwordVal, ok := passwordAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`password expected to be basetypes.StringValue, was: %T`, passwordAttribute))
	}

	portAttribute, ok := attributes["port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port is missing from object`)

		return NewSnowflakeValueUnknown(), diags
	}

	portVal, ok := portAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port expected to be basetypes.Int64Value, was: %T`, portAttribute))
	}

	recordIdKeyAttribute, ok := attributes["record_id_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`record_id_key is missing from object`)

		return NewSnowflakeValueUnknown(), diags
	}

	recordIdKeyVal, ok := recordIdKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`record_id_key expected to be basetypes.StringValue, was: %T`, recordIdKeyAttribute))
	}

	roleAttribute, ok := attributes["role"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`role is missing from object`)

		return NewSnowflakeValueUnknown(), diags
	}

	roleVal, ok := roleAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`role expected to be basetypes.StringValue, was: %T`, roleAttribute))
	}

	schemaAttribute, ok := attributes["schema"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`schema is missing from object`)

		return NewSnowflakeValueUnknown(), diags
	}

	schemaVal, ok := schemaAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`schema expected to be basetypes.StringValue, was: %T`, schemaAttribute))
	}

	tableNameAttribute, ok := attributes["table_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`table_name is missing from object`)

		return NewSnowflakeValueUnknown(), diags
	}

	tableNameVal, ok := tableNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`table_name expected to be basetypes.StringValue, was: %T`, tableNameAttribute))
	}

	userAttribute, ok := attributes["user"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`user is missing from object`)

		return NewSnowflakeValueUnknown(), diags
	}

	userVal, ok := userAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`user expected to be basetypes.StringValue, was: %T`, userAttribute))
	}

	if diags.HasError() {
		return NewSnowflakeValueUnknown(), diags
	}

	return SnowflakeValue{
		Account:     accountVal,
		BatchSize:   batchSizeVal,
		Database:    databaseVal,
		Host:        hostVal,
		Password:    passwordVal,
		Port:        portVal,
		RecordIdKey: recordIdKeyVal,
		Role:        roleVal,
		Schema:      schemaVal,
		TableName:   tableNameVal,
		User:        userVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewSnowflakeValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SnowflakeValue {
	object, diags := NewSnowflakeValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSnowflakeValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SnowflakeType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSnowflakeValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSnowflakeValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSnowflakeValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSnowflakeValueMust(SnowflakeValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SnowflakeType) ValueType(ctx context.Context) attr.Value {
	return SnowflakeValue{}
}

var _ basetypes.ObjectValuable = SnowflakeValue{}

type SnowflakeValue struct {
	Account     basetypes.StringValue `tfsdk:"account"`
	BatchSize   basetypes.Int64Value  `tfsdk:"batch_size"`
	Database    basetypes.StringValue `tfsdk:"database"`
	Host        basetypes.StringValue `tfsdk:"host"`
	Password    basetypes.StringValue `tfsdk:"password"`
	Port        basetypes.Int64Value  `tfsdk:"port"`
	RecordIdKey basetypes.StringValue `tfsdk:"record_id_key"`
	Role        basetypes.StringValue `tfsdk:"role"`
	Schema      basetypes.StringValue `tfsdk:"schema"`
	TableName   basetypes.StringValue `tfsdk:"table_name"`
	User        basetypes.StringValue `tfsdk:"user"`
	state       attr.ValueState
}

func (v SnowflakeValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 11)

	var val tftypes.Value
	var err error

	attrTypes["account"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["batch_size"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["database"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["host"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["password"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["port"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["record_id_key"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["role"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["schema"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["table_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["user"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 11)

		val, err = v.Account.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["account"] = val

		val, err = v.BatchSize.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["batch_size"] = val

		val, err = v.Database.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["database"] = val

		val, err = v.Host.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["host"] = val

		val, err = v.Password.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["password"] = val

		val, err = v.Port.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port"] = val

		val, err = v.RecordIdKey.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["record_id_key"] = val

		val, err = v.Role.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["role"] = val

		val, err = v.Schema.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["schema"] = val

		val, err = v.TableName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["table_name"] = val

		val, err = v.User.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["user"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SnowflakeValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SnowflakeValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SnowflakeValue) String() string {
	return "SnowflakeValue"
}

func (v SnowflakeValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"account":       basetypes.StringType{},
		"batch_size":    basetypes.Int64Type{},
		"database":      basetypes.StringType{},
		"host":          basetypes.StringType{},
		"password":      basetypes.StringType{},
		"port":          basetypes.Int64Type{},
		"record_id_key": basetypes.StringType{},
		"role":          basetypes.StringType{},
		"schema":        basetypes.StringType{},
		"table_name":    basetypes.StringType{},
		"user":          basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"account":       v.Account,
			"batch_size":    v.BatchSize,
			"database":      v.Database,
			"host":          v.Host,
			"password":      v.Password,
			"port":          v.Port,
			"record_id_key": v.RecordIdKey,
			"role":          v.Role,
			"schema":        v.Schema,
			"table_name":    v.TableName,
			"user":          v.User,
		})

	return objVal, diags
}

func (v SnowflakeValue) Equal(o attr.Value) bool {
	other, ok := o.(SnowflakeValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Account.Equal(other.Account) {
		return false
	}

	if !v.BatchSize.Equal(other.BatchSize) {
		return false
	}

	if !v.Database.Equal(other.Database) {
		return false
	}

	if !v.Host.Equal(other.Host) {
		return false
	}

	if !v.Password.Equal(other.Password) {
		return false
	}

	if !v.Port.Equal(other.Port) {
		return false
	}

	if !v.RecordIdKey.Equal(other.RecordIdKey) {
		return false
	}

	if !v.Role.Equal(other.Role) {
		return false
	}

	if !v.Schema.Equal(other.Schema) {
		return false
	}

	if !v.TableName.Equal(other.TableName) {
		return false
	}

	if !v.User.Equal(other.User) {
		return false
	}

	return true
}

func (v SnowflakeValue) Type(ctx context.Context) attr.Type {
	return SnowflakeType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SnowflakeValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"account":       basetypes.StringType{},
		"batch_size":    basetypes.Int64Type{},
		"database":      basetypes.StringType{},
		"host":          basetypes.StringType{},
		"password":      basetypes.StringType{},
		"port":          basetypes.Int64Type{},
		"record_id_key": basetypes.StringType{},
		"role":          basetypes.StringType{},
		"schema":        basetypes.StringType{},
		"table_name":    basetypes.StringType{},
		"user":          basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = WeaviateCloudType{}

type WeaviateCloudType struct {
	basetypes.ObjectType
}

func (t WeaviateCloudType) Equal(o attr.Type) bool {
	other, ok := o.(WeaviateCloudType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t WeaviateCloudType) String() string {
	return "WeaviateCloudType"
}

func (t WeaviateCloudType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	apiKeyAttribute, ok := attributes["api_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`api_key is missing from object`)

		return nil, diags
	}

	apiKeyVal, ok := apiKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`api_key expected to be basetypes.StringValue, was: %T`, apiKeyAttribute))
	}

	clusterUrlAttribute, ok := attributes["cluster_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cluster_url is missing from object`)

		return nil, diags
	}

	clusterUrlVal, ok := clusterUrlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cluster_url expected to be basetypes.StringValue, was: %T`, clusterUrlAttribute))
	}

	collectionAttribute, ok := attributes["collection"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`collection is missing from object`)

		return nil, diags
	}

	collectionVal, ok := collectionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`collection expected to be basetypes.StringValue, was: %T`, collectionAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return WeaviateCloudValue{
		ApiKey:     apiKeyVal,
		ClusterUrl: clusterUrlVal,
		Collection: collectionVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewWeaviateCloudValueNull() WeaviateCloudValue {
	return WeaviateCloudValue{
		state: attr.ValueStateNull,
	}
}

func NewWeaviateCloudValueUnknown() WeaviateCloudValue {
	return WeaviateCloudValue{
		state: attr.ValueStateUnknown,
	}
}

func NewWeaviateCloudValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (WeaviateCloudValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing WeaviateCloudValue Attribute Value",
				"While creating a WeaviateCloudValue value, a missing attribute value was detected. "+
					"A WeaviateCloudValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("WeaviateCloudValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid WeaviateCloudValue Attribute Type",
				"While creating a WeaviateCloudValue value, an invalid attribute value was detected. "+
					"A WeaviateCloudValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("WeaviateCloudValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("WeaviateCloudValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra WeaviateCloudValue Attribute Value",
				"While creating a WeaviateCloudValue value, an extra attribute value was detected. "+
					"A WeaviateCloudValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra WeaviateCloudValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewWeaviateCloudValueUnknown(), diags
	}

	apiKeyAttribute, ok := attributes["api_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`api_key is missing from object`)

		return NewWeaviateCloudValueUnknown(), diags
	}

	apiKeyVal, ok := apiKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`api_key expected to be basetypes.StringValue, was: %T`, apiKeyAttribute))
	}

	clusterUrlAttribute, ok := attributes["cluster_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cluster_url is missing from object`)

		return NewWeaviateCloudValueUnknown(), diags
	}

	clusterUrlVal, ok := clusterUrlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cluster_url expected to be basetypes.StringValue, was: %T`, clusterUrlAttribute))
	}

	collectionAttribute, ok := attributes["collection"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`collection is missing from object`)

		return NewWeaviateCloudValueUnknown(), diags
	}

	collectionVal, ok := collectionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`collection expected to be basetypes.StringValue, was: %T`, collectionAttribute))
	}

	if diags.HasError() {
		return NewWeaviateCloudValueUnknown(), diags
	}

	return WeaviateCloudValue{
		ApiKey:     apiKeyVal,
		ClusterUrl: clusterUrlVal,
		Collection: collectionVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewWeaviateCloudValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) WeaviateCloudValue {
	object, diags := NewWeaviateCloudValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewWeaviateCloudValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t WeaviateCloudType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewWeaviateCloudValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewWeaviateCloudValueUnknown(), nil
	}

	if in.IsNull() {
		return NewWeaviateCloudValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewWeaviateCloudValueMust(WeaviateCloudValue{}.AttributeTypes(ctx), attributes), nil
}

func (t WeaviateCloudType) ValueType(ctx context.Context) attr.Value {
	return WeaviateCloudValue{}
}

var _ basetypes.ObjectValuable = WeaviateCloudValue{}

type WeaviateCloudValue struct {
	ApiKey     basetypes.StringValue `tfsdk:"api_key"`
	ClusterUrl basetypes.StringValue `tfsdk:"cluster_url"`
	Collection basetypes.StringValue `tfsdk:"collection"`
	state      attr.ValueState
}

func (v WeaviateCloudValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["api_key"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["cluster_url"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["collection"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.ApiKey.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["api_key"] = val

		val, err = v.ClusterUrl.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cluster_url"] = val

		val, err = v.Collection.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["collection"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v WeaviateCloudValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v WeaviateCloudValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v WeaviateCloudValue) String() string {
	return "WeaviateCloudValue"
}

func (v WeaviateCloudValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"api_key":     basetypes.StringType{},
		"cluster_url": basetypes.StringType{},
		"collection":  basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"api_key":     v.ApiKey,
			"cluster_url": v.ClusterUrl,
			"collection":  v.Collection,
		})

	return objVal, diags
}

func (v WeaviateCloudValue) Equal(o attr.Value) bool {
	other, ok := o.(WeaviateCloudValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ApiKey.Equal(other.ApiKey) {
		return false
	}

	if !v.ClusterUrl.Equal(other.ClusterUrl) {
		return false
	}

	if !v.Collection.Equal(other.Collection) {
		return false
	}

	return true
}

func (v WeaviateCloudValue) Type(ctx context.Context) attr.Type {
	return WeaviateCloudType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v WeaviateCloudValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"api_key":     basetypes.StringType{},
		"cluster_url": basetypes.StringType{},
		"collection":  basetypes.StringType{},
	}
}
